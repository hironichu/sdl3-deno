/**
 * # CategoryEvents
 *
 * Event queue management.
 *
 * It's extremely common--often required--that an app deal with SDL's event
 * queue. Almost all useful information about interactions with the real world
 * flow through here: the user interacting with the computer and app, hardware
 * coming and going, the system changing in some way, etc.
 *
 * An app generally takes a moment, perhaps at the start of a new frame, to
 * examine any events that have occured since the last time and process or
 * ignore them. This is generally done by calling SDL_PollEvent() in a loop
 * until it returns false (or, if using the main callbacks, events are
 * provided one at a time in calls to SDL_AppEvent() before the next call to
 * SDL_AppIterate(); in this scenario, the app does not call SDL_PollEvent()
 * at all).
 *
 * There is other forms of control, too: SDL_PeepEvents() has more
 * functionality at the cost of more complexity, and SDL_WaitEvent() can block
 * the process until something interesting happens, which might be beneficial
 * for certain types of programs on low-power hardware. One may also call
 * SDL_AddEventWatch() to set a callback when new events arrive.
 *
 * The app is free to generate their own events, too: SDL_PushEvent allows the
 * app to put events onto the queue for later retrieval; SDL_RegisterEvents
 * can guarantee that these events have a type that isn't in use by other
 * parts of the system.
 *
 * @module
 */

/*
  Simple DirectMedia Layer
  Copyright (C) 1997-2025 Sam Lantinga <slouken@libsdl.org>

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
*/

import * as _ from "@denosaurs/byte-type";


/**
 * Fields shared by every event
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:286 
 */
export const SDL_CommonEvent = new _.Struct({
  type: _.u32, /**< Uint32 : Event type, shared with all events, Uint32 to cover user events which are not in the SDL_EventType enumeration */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
});



/**
 * Display state change event data (event.display.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:298 
 */
export const SDL_DisplayEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_DISPLAYEVENT_* */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  displayID: _.u32, /**< SDL_DisplayID : The associated display */
  data1: _.i32, /**< Sint32 : event dependent data */
  data2: _.i32, /**< Sint32 : event dependent data */
});



/**
 * Window state change event data (event.window.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:313 
 */
export const SDL_WindowEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_WINDOW_* */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The associated window */
  data1: _.i32, /**< Sint32 : event dependent data */
  data2: _.i32, /**< Sint32 : event dependent data */
});



/**
 * Keyboard device event structure (event.kdevice.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:328 
 */
export const SDL_KeyboardDeviceEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_KEYBOARD_ADDED or SDL_EVENT_KEYBOARD_REMOVED */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_KeyboardID : The keyboard instance id */
});



/**
 * Keyboard button event structure (event.key.*)
 *
 * The `key` is the base SDL_Keycode generated by pressing the `scancode`
 * using the current keyboard layout, applying any options specified in
 * SDL_HINT_KEYCODE_OPTIONS. You can get the SDL_Keycode corresponding to the
 * event scancode and modifiers directly from the keyboard layout, bypassing
 * SDL_HINT_KEYCODE_OPTIONS, by calling SDL_GetKeyFromScancode().
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyFromScancode
 * @sa SDL_HINT_KEYCODE_OPTIONS
 *
 * @from SDL_events.h:350 
 */
export const SDL_KeyboardEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_KEY_DOWN or SDL_EVENT_KEY_UP */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with keyboard focus, if any */
  which: _.u32, /**< SDL_KeyboardID : The keyboard instance id, or 0 if unknown or virtual */
  scancode: _.u32, /**< SDL_Scancode : SDL physical key code */
  key: _.u32, /**< SDL_Keycode : SDL virtual key code */
  mod: _.u16, /**< SDL_Keymod : current key modifiers */
  raw: _.u16, /**< Uint16 : The platform dependent scancode for this event */
  down: _.bool, /**< bool : true if the key is pressed */
  repeat: _.bool, /**< bool : true if this is a key repeat */
});



/**
 * Keyboard text editing event structure (event.edit.*)
 *
 * The start cursor is the position, in UTF-8 characters, where new typing
 * will be inserted into the editing text. The length is the number of UTF-8
 * characters that will be replaced by new typing.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:374 
 */
export const SDL_TextEditingEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_TEXT_EDITING */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with keyboard focus, if any */
  text: _.u64, /**< const char * : The editing text */
  start: _.i32, /**< Sint32 : The start cursor of selected editing text, or -1 if not set */
  length: _.i32, /**< Sint32 : The length of selected editing text, or -1 if not set */
});



/**
 * Keyboard IME candidates event structure (event.edit_candidates.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:390 
 */
export const SDL_TextEditingCandidatesEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_TEXT_EDITING_CANDIDATES */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with keyboard focus, if any */
  candidates: _.u64, /**< const char * const * : The list of candidates, or NULL if there are no candidates available */
  num_candidates: _.i32, /**< Sint32 : The number of strings in `candidates` */
  selected_candidate: _.i32, /**< Sint32 : The index of the selected candidate, or -1 if no candidate is selected */
  horizontal: _.bool, /**< bool : true if the list is horizontal, false if it's vertical */
  padding1: _.u8, /* Uint8 */
  padding2: _.u8, /* Uint8 */
  padding3: _.u8, /* Uint8 */
});



/**
 * Keyboard text input event structure (event.text.*)
 *
 * This event will never be delivered unless text input is enabled by calling
 * SDL_StartTextInput(). Text input is disabled by default!
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa SDL_StartTextInput
 * @sa SDL_StopTextInput
 *
 * @from SDL_events.h:416 
 */
export const SDL_TextInputEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_TEXT_INPUT */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with keyboard focus, if any */
  text: _.u64, /**< const char * : The input text, UTF-8 encoded */
});



/**
 * Mouse device event structure (event.mdevice.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:430 
 */
export const SDL_MouseDeviceEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_MOUSE_ADDED or SDL_EVENT_MOUSE_REMOVED */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_MouseID : The mouse instance id */
});



/**
 * Mouse motion event structure (event.motion.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:443 
 */
export const SDL_MouseMotionEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_MOUSE_MOTION */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with mouse focus, if any */
  which: _.u32, /**< SDL_MouseID : The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0 */
  state: _.u32, /**< SDL_MouseButtonFlags : The current button state */
  x: _.f32, /**< float : X coordinate, relative to window */
  y: _.f32, /**< float : Y coordinate, relative to window */
  xrel: _.f32, /**< float : The relative motion in the X direction */
  yrel: _.f32, /**< float : The relative motion in the Y direction */
});



/**
 * Mouse button event structure (event.button.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:462 
 */
export const SDL_MouseButtonEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_MOUSE_BUTTON_DOWN or SDL_EVENT_MOUSE_BUTTON_UP */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with mouse focus, if any */
  which: _.u32, /**< SDL_MouseID : The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0 */
  button: _.u8, /**< Uint8 : The mouse button index */
  down: _.bool, /**< bool : true if the button is pressed */
  clicks: _.u8, /**< Uint8 : 1 for single-click, 2 for double-click, etc. */
  padding: _.u8, /* Uint8 */
  x: _.f32, /**< float : X coordinate, relative to window */
  y: _.f32, /**< float : Y coordinate, relative to window */
});



/**
 * Mouse wheel event structure (event.wheel.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:482 
 */
export const SDL_MouseWheelEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_MOUSE_WHEEL */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with mouse focus, if any */
  which: _.u32, /**< SDL_MouseID : The mouse instance id in relative mode or 0 */
  x: _.f32, /**< float : The amount scrolled horizontally, positive to the right and negative to the left */
  y: _.f32, /**< float : The amount scrolled vertically, positive away from the user and negative toward the user */
  direction: _.u32, /**< SDL_MouseWheelDirection : Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back */
  mouse_x: _.f32, /**< float : X coordinate, relative to window */
  mouse_y: _.f32, /**< float : Y coordinate, relative to window */
});



/**
 * Joystick axis motion event structure (event.jaxis.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:501 
 */
export const SDL_JoyAxisEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_JOYSTICK_AXIS_MOTION */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  axis: _.u8, /**< Uint8 : The joystick axis index */
  padding1: _.u8, /* Uint8 */
  padding2: _.u8, /* Uint8 */
  padding3: _.u8, /* Uint8 */
  value: _.i16, /**< Sint16 : The axis value (range: -32768 to 32767) */
  padding4: _.u16, /* Uint16 */
});



/**
 * Joystick trackball motion event structure (event.jball.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:520 
 */
export const SDL_JoyBallEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_JOYSTICK_BALL_MOTION */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  ball: _.u8, /**< Uint8 : The joystick trackball index */
  padding1: _.u8, /* Uint8 */
  padding2: _.u8, /* Uint8 */
  padding3: _.u8, /* Uint8 */
  xrel: _.i16, /**< Sint16 : The relative motion in the X direction */
  yrel: _.i16, /**< Sint16 : The relative motion in the Y direction */
});



/**
 * Joystick hat position change event structure (event.jhat.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:539 
 */
export const SDL_JoyHatEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_JOYSTICK_HAT_MOTION */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  hat: _.u8, /**< Uint8 : The joystick hat index */
  value: _.u8, /**< Uint8 : The hat position value.
                         *   \sa SDL_HAT_LEFTUP SDL_HAT_UP SDL_HAT_RIGHTUP
                         *   \sa SDL_HAT_LEFT SDL_HAT_CENTERED SDL_HAT_RIGHT
                         *   \sa SDL_HAT_LEFTDOWN SDL_HAT_DOWN SDL_HAT_RIGHTDOWN
                         *
                         *   Note that zero means the POV is centered.
                         */
  padding1: _.u8, /* Uint8 */
  padding2: _.u8, /* Uint8 */
});



/**
 * Joystick button event structure (event.jbutton.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:562 
 */
export const SDL_JoyButtonEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_JOYSTICK_BUTTON_DOWN or SDL_EVENT_JOYSTICK_BUTTON_UP */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  button: _.u8, /**< Uint8 : The joystick button index */
  down: _.bool, /**< bool : true if the button is pressed */
  padding1: _.u8, /* Uint8 */
  padding2: _.u8, /* Uint8 */
});



/**
 * Joystick device event structure (event.jdevice.*)
 *
 * SDL will send JOYSTICK_ADDED events for devices that are already plugged in
 * during SDL_Init.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa SDL_GamepadDeviceEvent
 *
 * @from SDL_events.h:584 
 */
export const SDL_JoyDeviceEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_JOYSTICK_ADDED or SDL_EVENT_JOYSTICK_REMOVED or SDL_EVENT_JOYSTICK_UPDATE_COMPLETE */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
});



/**
 * Joystick battery level change event structure (event.jbattery.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:597 
 */
export const SDL_JoyBatteryEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_JOYSTICK_BATTERY_UPDATED */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  state: _.u32, /**< SDL_PowerState : The joystick battery state */
  percent: _.i32, /**< int : The joystick battery percent charge remaining */
});



/**
 * Gamepad axis motion event structure (event.gaxis.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:612 
 */
export const SDL_GamepadAxisEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_GAMEPAD_AXIS_MOTION */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  axis: _.u8, /**< Uint8 : The gamepad axis (SDL_GamepadAxis) */
  padding1: _.u8, /* Uint8 */
  padding2: _.u8, /* Uint8 */
  padding3: _.u8, /* Uint8 */
  value: _.i16, /**< Sint16 : The axis value (range: -32768 to 32767) */
  padding4: _.u16, /* Uint16 */
});



/**
 * Gamepad button event structure (event.gbutton.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:632 
 */
export const SDL_GamepadButtonEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_GAMEPAD_BUTTON_DOWN or SDL_EVENT_GAMEPAD_BUTTON_UP */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  button: _.u8, /**< Uint8 : The gamepad button (SDL_GamepadButton) */
  down: _.bool, /**< bool : true if the button is pressed */
  padding1: _.u8, /* Uint8 */
  padding2: _.u8, /* Uint8 */
});



/**
 * Gamepad device event structure (event.gdevice.*)
 *
 * Joysticks that are supported gamepads receive both an SDL_JoyDeviceEvent
 * and an SDL_GamepadDeviceEvent.
 *
 * SDL will send GAMEPAD_ADDED events for joysticks that are already plugged
 * in during SDL_Init() and are recognized as gamepads. It will also send
 * events for joysticks that get gamepad mappings at runtime.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @sa SDL_JoyDeviceEvent
 *
 * @from SDL_events.h:659 
 */
export const SDL_GamepadDeviceEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_GAMEPAD_ADDED, SDL_EVENT_GAMEPAD_REMOVED, or SDL_EVENT_GAMEPAD_REMAPPED, SDL_EVENT_GAMEPAD_UPDATE_COMPLETE or SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
});



/**
 * Gamepad touchpad event structure (event.gtouchpad.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:672 
 */
export const SDL_GamepadTouchpadEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN or SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION or SDL_EVENT_GAMEPAD_TOUCHPAD_UP */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  touchpad: _.i32, /**< Sint32 : The index of the touchpad */
  finger: _.i32, /**< Sint32 : The index of the finger on the touchpad */
  x: _.f32, /**< float : Normalized in the range 0...1 with 0 being on the left */
  y: _.f32, /**< float : Normalized in the range 0...1 with 0 being at the top */
  pressure: _.f32, /**< float : Normalized in the range 0...1 */
});



/**
 * Gamepad sensor event structure (event.gsensor.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:690 
 */
export const SDL_GamepadSensorEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_GAMEPAD_SENSOR_UPDATE */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_JoystickID : The joystick instance id */
  sensor: _.i32, /**< Sint32 : The type of the sensor, one of the values of SDL_SensorType */
  data: new _.ArrayType(_.f32, 3), /**< float[3] : Up to 3 values from the sensor, as defined in SDL_sensor.h */
  sensor_timestamp: _.u64, /**< Uint64 : The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock */
});



/**
 * Audio device event structure (event.adevice.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:706 
 */
export const SDL_AudioDeviceEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_AUDIO_DEVICE_ADDED, or SDL_EVENT_AUDIO_DEVICE_REMOVED, or SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_AudioDeviceID : SDL_AudioDeviceID for the device being added or removed or changing */
  recording: _.bool, /**< bool : false if a playback device, true if a recording device. */
  padding1: _.u8, /* Uint8 */
  padding2: _.u8, /* Uint8 */
  padding3: _.u8, /* Uint8 */
});



/**
 * Camera device event structure (event.cdevice.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:723 
 */
export const SDL_CameraDeviceEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_CAMERA_DEVICE_ADDED, SDL_EVENT_CAMERA_DEVICE_REMOVED, SDL_EVENT_CAMERA_DEVICE_APPROVED, SDL_EVENT_CAMERA_DEVICE_DENIED */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_CameraID : SDL_CameraID for the device being added or removed or changing */
});



/**
 * Renderer event structure (event.render.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:737 
 */
export const SDL_RenderEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_RENDER_TARGETS_RESET, SDL_EVENT_RENDER_DEVICE_RESET, SDL_EVENT_RENDER_DEVICE_LOST */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window containing the renderer in question. */
});



/**
 * Touch finger event structure (event.tfinger.*)
 *
 * Coordinates in this event are normalized. `x` and `y` are normalized to a
 * range between 0.0f and 1.0f, relative to the window, so (0,0) is the top
 * left and (1,1) is the bottom right. Delta coordinates `dx` and `dy` are
 * normalized in the ranges of -1.0f (traversed all the way from the bottom or
 * right to all the way up or left) to 1.0f (traversed all the way from the
 * top or left to all the way down or right).
 *
 * Note that while the coordinates are _normalized_, they are not _clamped_,
 * which means in some circumstances you can get a value outside of this
 * range. For example, a renderer using logical presentation might give a
 * negative value when the touch is in the letterboxing. Some platforms might
 * report a touch outside of the window, which will also be outside of the
 * range.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:765 
 */
export const SDL_TouchFingerEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_FINGER_DOWN, SDL_EVENT_FINGER_UP, SDL_EVENT_FINGER_MOTION, or SDL_EVENT_FINGER_CANCELED */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  touchID: _.u64, /**< SDL_TouchID : The touch device id */
  fingerID: _.u64, /* SDL_FingerID */
  x: _.f32, /**< float : Normalized in the range 0...1 */
  y: _.f32, /**< float : Normalized in the range 0...1 */
  dx: _.f32, /**< float : Normalized in the range -1...1 */
  dy: _.f32, /**< float : Normalized in the range -1...1 */
  pressure: _.f32, /**< float : Normalized in the range 0...1 */
  windowID: _.u32, /**< SDL_WindowID : The window underneath the finger, if any */
});



/**
 * Pressure-sensitive pen proximity event structure (event.pmotion.*)
 *
 * When a pen becomes visible to the system (it is close enough to a tablet,
 * etc), SDL will send an SDL_EVENT_PEN_PROXIMITY_IN event with the new pen's
 * ID. This ID is valid until the pen leaves proximity again (has been removed
 * from the tablet's area, the tablet has been unplugged, etc). If the same
 * pen reenters proximity again, it will be given a new ID.
 *
 * Note that "proximity" means "close enough for the tablet to know the tool
 * is there." The pen touching and lifting off from the tablet while not
 * leaving the area are handled by SDL_EVENT_PEN_DOWN and SDL_EVENT_PEN_UP.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:795 
 */
export const SDL_PenProximityEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_PEN_PROXIMITY_IN or SDL_EVENT_PEN_PROXIMITY_OUT */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with pen focus, if any */
  which: _.u32, /**< SDL_PenID : The pen instance id */
});



/**
 * Pressure-sensitive pen motion event structure (event.pmotion.*)
 *
 * Depending on the hardware, you may get motion events when the pen is not
 * touching a tablet, for tracking a pen even when it isn't drawing. You
 * should listen for SDL_EVENT_PEN_DOWN and SDL_EVENT_PEN_UP events, or check
 * `pen_state & SDL_PEN_INPUT_DOWN` to decide if a pen is "drawing" when
 * dealing with pen motion.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:815 
 */
export const SDL_PenMotionEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_PEN_MOTION */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with pen focus, if any */
  which: _.u32, /**< SDL_PenID : The pen instance id */
  pen_state: _.u32, /**< SDL_PenInputFlags : Complete pen input state at time of event */
  x: _.f32, /**< float : X coordinate, relative to window */
  y: _.f32, /**< float : Y coordinate, relative to window */
});



/**
 * Pressure-sensitive pen touched event structure (event.ptouch.*)
 *
 * These events come when a pen touches a surface (a tablet, etc), or lifts
 * off from one.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:835 
 */
export const SDL_PenTouchEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_PEN_DOWN or SDL_EVENT_PEN_UP */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with pen focus, if any */
  which: _.u32, /**< SDL_PenID : The pen instance id */
  pen_state: _.u32, /**< SDL_PenInputFlags : Complete pen input state at time of event */
  x: _.f32, /**< float : X coordinate, relative to window */
  y: _.f32, /**< float : Y coordinate, relative to window */
  eraser: _.bool, /**< bool : true if eraser end is used (not all pens support this). */
  down: _.bool, /**< bool : true if the pen is touching or false if the pen is lifted off */
});



/**
 * Pressure-sensitive pen button event structure (event.pbutton.*)
 *
 * This is for buttons on the pen itself that the user might click. The pen
 * itself pressing down to draw triggers a SDL_EVENT_PEN_DOWN event instead.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:857 
 */
export const SDL_PenButtonEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_PEN_BUTTON_DOWN or SDL_EVENT_PEN_BUTTON_UP */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with mouse focus, if any */
  which: _.u32, /**< SDL_PenID : The pen instance id */
  pen_state: _.u32, /**< SDL_PenInputFlags : Complete pen input state at time of event */
  x: _.f32, /**< float : X coordinate, relative to window */
  y: _.f32, /**< float : Y coordinate, relative to window */
  button: _.u8, /**< Uint8 : The pen button index (first button is 1). */
  down: _.bool, /**< bool : true if the button is pressed */
});



/**
 * Pressure-sensitive pen pressure / angle event structure (event.paxis.*)
 *
 * You might get some of these events even if the pen isn't touching the
 * tablet.
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:879 
 */
export const SDL_PenAxisEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_PEN_AXIS */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window with pen focus, if any */
  which: _.u32, /**< SDL_PenID : The pen instance id */
  pen_state: _.u32, /**< SDL_PenInputFlags : Complete pen input state at time of event */
  x: _.f32, /**< float : X coordinate, relative to window */
  y: _.f32, /**< float : Y coordinate, relative to window */
  axis: _.u32, /**< SDL_PenAxis : Axis that has changed */
  value: _.f32, /**< float : New value of axis */
});



/**
 * An event used to drop text or request a file open by the system
 * (event.drop.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:899 
 */
export const SDL_DropEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_DROP_BEGIN or SDL_EVENT_DROP_FILE or SDL_EVENT_DROP_TEXT or SDL_EVENT_DROP_COMPLETE or SDL_EVENT_DROP_POSITION */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The window that was dropped on, if any */
  x: _.f32, /**< float : X coordinate, relative to window (not on begin) */
  y: _.f32, /**< float : Y coordinate, relative to window (not on begin) */
  source: _.u64, /**< const char * : The source app that sent this drop event, or NULL if that isn't available */
  data: _.u64, /**< const char * : The text for SDL_EVENT_DROP_TEXT and the file name for SDL_EVENT_DROP_FILE, NULL for other events */
});



/**
 * An event triggered when the clipboard contents have changed
 * (event.clipboard.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:917 
 */
export const SDL_ClipboardEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_CLIPBOARD_UPDATE */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  owner: _.bool, /**< bool : are we owning the clipboard (internal update) */
  num_mime_types: _.i32, /**< Sint32 : number of mime types */
  mime_types: _.u64, /**< const char ** : current mime types */
});



/**
 * Sensor event structure (event.sensor.*)
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:932 
 */
export const SDL_SensorEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_SENSOR_UPDATE */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  which: _.u32, /**< SDL_SensorID : The instance ID of the sensor */
  data: new _.ArrayType(_.f32, 6), /**< float[6] : Up to 6 values from the sensor - additional values can be queried using SDL_GetSensorData() */
  sensor_timestamp: _.u64, /**< Uint64 : The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock */
});



/**
 * The "quit requested" event
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:947 
 */
export const SDL_QuitEvent = new _.Struct({
  type: _.u32, /**< SDL_EventType : SDL_EVENT_QUIT */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
});



/**
 * A user-defined event type (event.user.*)
 *
 * This event is unique; it is never created by SDL, but only by the
 * application. The event can be pushed onto the event queue using
 * SDL_PushEvent(). The contents of the structure members are completely up to
 * the programmer; the only requirement is that '''type''' is a value obtained
 * from SDL_RegisterEvents().
 *
 * @since This struct is available since SDL 3.2.0.
 *
 * @from SDL_events.h:965 
 */
export const SDL_UserEvent = new _.Struct({
  type: _.u32, /**< Uint32 : SDL_EVENT_USER through SDL_EVENT_LAST-1, Uint32 because these are not in the SDL_EventType enumeration */
  reserved: _.u32, /* Uint32 */
  timestamp: _.u64, /**< Uint64 : In nanoseconds, populated using SDL_GetTicksNS() */
  windowID: _.u32, /**< SDL_WindowID : The associated window if any */
  code: _.i32, /**< Sint32 : User defined event code */
  data1: _.u64, /**< void * : User defined data pointer */
  data2: _.u64, /**< void * : User defined data pointer */
});



