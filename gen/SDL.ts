import { libSdlPath } from './_utils.ts';

import * as SDL_assert_enums from "./enums/SDL_assert.ts";
import * as SDL_asyncio_enums from "./enums/SDL_asyncio.ts";
import * as SDL_audio_enums from "./enums/SDL_audio.ts";
import * as SDL_blendmode_enums from "./enums/SDL_blendmode.ts";
import * as SDL_camera_enums from "./enums/SDL_camera.ts";
import * as SDL_dialog_enums from "./enums/SDL_dialog.ts";
import * as SDL_events_enums from "./enums/SDL_events.ts";
import * as SDL_filesystem_enums from "./enums/SDL_filesystem.ts";
import * as SDL_gamepad_enums from "./enums/SDL_gamepad.ts";
import * as SDL_gpu_enums from "./enums/SDL_gpu.ts";
import * as SDL_hidapi_enums from "./enums/SDL_hidapi.ts";
import * as SDL_hints_enums from "./enums/SDL_hints.ts";
import * as SDL_init_enums from "./enums/SDL_init.ts";
import * as SDL_intrin_enums from "./enums/SDL_intrin.ts";
import * as SDL_iostream_enums from "./enums/SDL_iostream.ts";
import * as SDL_joystick_enums from "./enums/SDL_joystick.ts";
import * as SDL_keyboard_enums from "./enums/SDL_keyboard.ts";
import * as SDL_keycode_enums from "./enums/SDL_keycode.ts";
import * as SDL_log_enums from "./enums/SDL_log.ts";
import * as SDL_messagebox_enums from "./enums/SDL_messagebox.ts";
import * as SDL_mouse_enums from "./enums/SDL_mouse.ts";
import * as SDL_mutex_enums from "./enums/SDL_mutex.ts";
import * as SDL_pen_enums from "./enums/SDL_pen.ts";
import * as SDL_pixels_enums from "./enums/SDL_pixels.ts";
import * as SDL_power_enums from "./enums/SDL_power.ts";
import * as SDL_process_enums from "./enums/SDL_process.ts";
import * as SDL_properties_enums from "./enums/SDL_properties.ts";
import * as SDL_render_enums from "./enums/SDL_render.ts";
import * as SDL_scancode_enums from "./enums/SDL_scancode.ts";
import * as SDL_sensor_enums from "./enums/SDL_sensor.ts";
import * as SDL_stdinc_enums from "./enums/SDL_stdinc.ts";
import * as SDL_surface_enums from "./enums/SDL_surface.ts";
import * as SDL_system_enums from "./enums/SDL_system.ts";
import * as SDL_thread_enums from "./enums/SDL_thread.ts";
import * as SDL_time_enums from "./enums/SDL_time.ts";
import * as SDL_touch_enums from "./enums/SDL_touch.ts";
import * as SDL_tray_enums from "./enums/SDL_tray.ts";
import * as SDL_video_enums from "./enums/SDL_video.ts";

import { symbols } from "./funcs/SDL.ts";
export { symbols };

export const lib = Deno.dlopen(libSdlPath("SDL3"), symbols);

export const SDL = {
  lib,



/*--- SDL_assert ---*/

/**
 * Possible outcomes from a triggered assertion.
 *
 * When an enabled assertion triggers, it may call the assertion handler
 * (possibly one provided by the app via SDL_SetAssertionHandler), which will
 * return one of these values, possibly after asking the user.
 *
 * Then SDL will respond based on this outcome (loop around to retry the
 * condition, try to break in a debugger, kill the program, or ignore the
 * problem).
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_assert.h:270 SDL_ASSERTION_
 */
  ASSERTION: SDL_assert_enums.SDL_AssertState,



/**
 * Never call this directly.
 *
 * Use the SDL_assert macros instead.
 *
 * @param data assert data structure.
 * @param func function name.
 * @param file file name.
 * @param line line number.
 * @returns assert state.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_assert.h:314 SDL_AssertState SDL_ReportAssertion(SDL_AssertData *data,                                                            const char *func,                                                            const char *file, int line) SDL_ANALYZER_NORETURN;
 */
  reportAssertion: lib.symbols.SDL_ReportAssertion,

/**
 * Get a list of all assertion failures.
 *
 * This function gets all assertions triggered since the last call to
 * SDL_ResetAssertionReport(), or the start of the program.
 *
 * The proper way to examine this data looks something like this:
 *
 * ```c
 * const SDL_AssertData *item = SDL_GetAssertionReport();
 * while (item) {
 *    printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
 *           item->condition, item->function, item->filename,
 *           item->linenum, item->trigger_count,
 *           item->always_ignore ? "yes" : "no");
 *    item = item->next;
 * }
 * ```
 *
 * @returns a list of all failed assertions or NULL if the list is empty. This
 *          memory should not be modified or freed by the application. This
 *          pointer remains valid until the next call to SDL_Quit() or
 *          SDL_ResetAssertionReport().
 *
 * @threadsafety This function is not thread safe. Other threads calling
 *               SDL_ResetAssertionReport() simultaneously, may render the
 *               returned pointer invalid.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ResetAssertionReport
 *
 * @from SDL_assert.h:635 const SDL_AssertData * SDL_GetAssertionReport(void);
 */
  getAssertionReport: lib.symbols.SDL_GetAssertionReport,

/**
 * Clear the list of all assertion failures.
 *
 * This function will clear the list of all assertions triggered up to that
 * point. Immediately following this call, SDL_GetAssertionReport will return
 * no items. In addition, any previously-triggered assertions will be reset to
 * a trigger_count of zero, and their always_ignore state will be false.
 *
 * @threadsafety This function is not thread safe. Other threads triggering an
 *               assertion, or simultaneously calling this function may cause
 *               memory leaks or crashes.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAssertionReport
 *
 * @from SDL_assert.h:653 void SDL_ResetAssertionReport(void);
 */
  resetAssertionReport: lib.symbols.SDL_ResetAssertionReport,



/*--- SDL_asyncio ---*/

/**
 * Types of asynchronous I/O tasks.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_asyncio.h:130 SDL_ASYNCIO_TASK_
 */
  ASYNCIO_TASK: SDL_asyncio_enums.SDL_AsyncIOTaskType,

/**
 * Possible outcomes of an asynchronous I/O task.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_asyncio.h:142 SDL_ASYNCIO_
 */
  ASYNCIO: SDL_asyncio_enums.SDL_AsyncIOResult,



/**
 * Use this function to create a new SDL_AsyncIO object for reading from
 * and/or writing to a named file.
 *
 * The `mode` string understands the following values:
 *
 * - "r": Open a file for reading only. It must exist.
 * - "w": Open a file for writing only. It will create missing files or
 *   truncate existing ones.
 * - "r+": Open a file for update both reading and writing. The file must
 *   exist.
 * - "w+": Create an empty file for both reading and writing. If a file with
 *   the same name already exists its content is erased and the file is
 *   treated as a new empty file.
 *
 * There is no "b" mode, as there is only "binary" style I/O, and no "a" mode
 * for appending, since you specify the position when starting a task.
 *
 * This function supports Unicode filenames, but they must be encoded in UTF-8
 * format, regardless of the underlying operating system.
 *
 * This call is _not_ asynchronous; it will open the file before returning,
 * under the assumption that doing so is generally a fast operation. Future
 * reads and writes to the opened file will be async, however.
 *
 * @param file a UTF-8 string representing the filename to open.
 * @param mode an ASCII string representing the mode to be used for opening
 *             the file.
 * @returns a pointer to the SDL_AsyncIO structure that is created or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseAsyncIO
 * @sa SDL_ReadAsyncIO
 * @sa SDL_WriteAsyncIO
 *
 * @from SDL_asyncio.h:221 SDL_AsyncIO * SDL_AsyncIOFromFile(const char *file, const char *mode);
 */
  asyncIoFromFile: lib.symbols.SDL_AsyncIOFromFile,

/**
 * Use this function to get the size of the data stream in an SDL_AsyncIO.
 *
 * This call is _not_ asynchronous; it assumes that obtaining this info is a
 * non-blocking operation in most reasonable cases.
 *
 * @param asyncio the SDL_AsyncIO to get the size of the data stream from.
 * @returns the size of the data stream in the SDL_IOStream on success or a
 *          negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_asyncio.h:238 Sint64 SDL_GetAsyncIOSize(SDL_AsyncIO *asyncio);
 */
  getAsyncIoSize: lib.symbols.SDL_GetAsyncIOSize,

/**
 * Start an async read.
 *
 * This function reads up to `size` bytes from `offset` position in the data
 * source to the area pointed at by `ptr`. This function may read less bytes
 * than requested.
 *
 * This function returns as quickly as possible; it does not wait for the read
 * to complete. On a successful return, this work will continue in the
 * background. If the work begins, even failure is asynchronous: a failing
 * return value from this function only means the work couldn't start at all.
 *
 * `ptr` must remain available until the work is done, and may be accessed by
 * the system at any time until then. Do not allocate it on the stack, as this
 * might take longer than the life of the calling function to complete!
 *
 * An SDL_AsyncIOQueue must be specified. The newly-created task will be added
 * to it when it completes its work.
 *
 * @param asyncio a pointer to an SDL_AsyncIO structure.
 * @param ptr a pointer to a buffer to read data into.
 * @param offset the position to start reading in the data source.
 * @param size the number of bytes to read from the data source.
 * @param queue a queue to add the new SDL_AsyncIO to.
 * @param userdata an app-defined pointer that will be provided with the task
 *                 results.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WriteAsyncIO
 * @sa SDL_CreateAsyncIOQueue
 *
 * @from SDL_asyncio.h:276 bool SDL_ReadAsyncIO(SDL_AsyncIO *asyncio, void *ptr, Uint64 offset, Uint64 size, SDL_AsyncIOQueue *queue, void *userdata);
 */
  readAsyncIo: lib.symbols.SDL_ReadAsyncIO,

/**
 * Start an async write.
 *
 * This function writes `size` bytes from `offset` position in the data source
 * to the area pointed at by `ptr`.
 *
 * This function returns as quickly as possible; it does not wait for the
 * write to complete. On a successful return, this work will continue in the
 * background. If the work begins, even failure is asynchronous: a failing
 * return value from this function only means the work couldn't start at all.
 *
 * `ptr` must remain available until the work is done, and may be accessed by
 * the system at any time until then. Do not allocate it on the stack, as this
 * might take longer than the life of the calling function to complete!
 *
 * An SDL_AsyncIOQueue must be specified. The newly-created task will be added
 * to it when it completes its work.
 *
 * @param asyncio a pointer to an SDL_AsyncIO structure.
 * @param ptr a pointer to a buffer to write data from.
 * @param offset the position to start writing to the data source.
 * @param size the number of bytes to write to the data source.
 * @param queue a queue to add the new SDL_AsyncIO to.
 * @param userdata an app-defined pointer that will be provided with the task
 *                 results.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ReadAsyncIO
 * @sa SDL_CreateAsyncIOQueue
 *
 * @from SDL_asyncio.h:313 bool SDL_WriteAsyncIO(SDL_AsyncIO *asyncio, void *ptr, Uint64 offset, Uint64 size, SDL_AsyncIOQueue *queue, void *userdata);
 */
  writeAsyncIo: lib.symbols.SDL_WriteAsyncIO,

/**
 * Close and free any allocated resources for an async I/O object.
 *
 * Closing a file is _also_ an asynchronous task! If a write failure were to
 * happen during the closing process, for example, the task results will
 * report it as usual.
 *
 * Closing a file that has been written to does not guarantee the data has
 * made it to physical media; it may remain in the operating system's file
 * cache, for later writing to disk. This means that a successfully-closed
 * file can be lost if the system crashes or loses power in this small window.
 * To prevent this, call this function with the `flush` parameter set to true.
 * This will make the operation take longer, and perhaps increase system load
 * in general, but a successful result guarantees that the data has made it to
 * physical storage. Don't use this for temporary files, caches, and
 * unimportant data, and definitely use it for crucial irreplaceable files,
 * like game saves.
 *
 * This function guarantees that the close will happen after any other pending
 * tasks to `asyncio`, so it's safe to open a file, start several operations,
 * close the file immediately, then check for all results later. This function
 * will not block until the tasks have completed.
 *
 * Once this function returns true, `asyncio` is no longer valid, regardless
 * of any future outcomes. Any completed tasks might still contain this
 * pointer in their SDL_AsyncIOOutcome data, in case the app was using this
 * value to track information, but it should not be used again.
 *
 * If this function returns false, the close wasn't started at all, and it's
 * safe to attempt to close again later.
 *
 * An SDL_AsyncIOQueue must be specified. The newly-created task will be added
 * to it when it completes its work.
 *
 * @param asyncio a pointer to an SDL_AsyncIO structure to close.
 * @param flush true if data should sync to disk before the task completes.
 * @param queue a queue to add the new SDL_AsyncIO to.
 * @param userdata an app-defined pointer that will be provided with the task
 *                 results.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, but two
 *               threads should not attempt to close the same object.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_asyncio.h:362 bool SDL_CloseAsyncIO(SDL_AsyncIO *asyncio, bool flush, SDL_AsyncIOQueue *queue, void *userdata);
 */
  closeAsyncIo: lib.symbols.SDL_CloseAsyncIO,

/**
 * Create a task queue for tracking multiple I/O operations.
 *
 * Async I/O operations are assigned to a queue when started. The queue can be
 * checked for completed tasks thereafter.
 *
 * @returns a new task queue object or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyAsyncIOQueue
 * @sa SDL_GetAsyncIOResult
 * @sa SDL_WaitAsyncIOResult
 *
 * @from SDL_asyncio.h:381 SDL_AsyncIOQueue * SDL_CreateAsyncIOQueue(void);
 */
  createAsyncIoQueue: lib.symbols.SDL_CreateAsyncIOQueue,

/**
 * Destroy a previously-created async I/O task queue.
 *
 * If there are still tasks pending for this queue, this call will block until
 * those tasks are finished. All those tasks will be deallocated. Their
 * results will be lost to the app.
 *
 * Any pending reads from SDL_LoadFileAsync() that are still in this queue
 * will have their buffers deallocated by this function, to prevent a memory
 * leak.
 *
 * Once this function is called, the queue is no longer valid and should not
 * be used, including by other threads that might access it while destruction
 * is blocking on pending tasks.
 *
 * Do not destroy a queue that still has threads waiting on it through
 * SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to
 * unblock those threads, and take measures (such as SDL_WaitThread()) to make
 * sure they have finished their wait and won't wait on the queue again.
 *
 * @param queue the task queue to destroy.
 *
 * @threadsafety It is safe to call this function from any thread, so long as
 *               no other thread is waiting on the queue with
 *               SDL_WaitAsyncIOResult.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_asyncio.h:411 void SDL_DestroyAsyncIOQueue(SDL_AsyncIOQueue *queue);
 */
  destroyAsyncIoQueue: lib.symbols.SDL_DestroyAsyncIOQueue,

/**
 * Query an async I/O task queue for completed tasks.
 *
 * If a task assigned to this queue has finished, this will return true and
 * fill in `outcome` with the details of the task. If no task in the queue has
 * finished, this function will return false. This function does not block.
 *
 * If a task has completed, this function will free its resources and the task
 * pointer will no longer be valid. The task will be removed from the queue.
 *
 * It is safe for multiple threads to call this function on the same queue at
 * once; a completed task will only go to one of the threads.
 *
 * @param queue the async I/O task queue to query.
 * @param outcome details of a finished task will be written here. May not be
 *                NULL.
 * @returns true if a task has completed, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WaitAsyncIOResult
 *
 * @from SDL_asyncio.h:437 bool SDL_GetAsyncIOResult(SDL_AsyncIOQueue *queue, SDL_AsyncIOOutcome *outcome);
 */
  getAsyncIoResult: lib.symbols.SDL_GetAsyncIOResult,

/**
 * Block until an async I/O task queue has a completed task.
 *
 * This function puts the calling thread to sleep until there a task assigned
 * to the queue that has finished.
 *
 * If a task assigned to the queue has finished, this will return true and
 * fill in `outcome` with the details of the task. If no task in the queue has
 * finished, this function will return false.
 *
 * If a task has completed, this function will free its resources and the task
 * pointer will no longer be valid. The task will be removed from the queue.
 *
 * It is safe for multiple threads to call this function on the same queue at
 * once; a completed task will only go to one of the threads.
 *
 * Note that by the nature of various platforms, more than one waiting thread
 * may wake to handle a single task, but only one will obtain it, so
 * `timeoutMS` is a _maximum_ wait time, and this function may return false
 * sooner.
 *
 * This function may return false if there was a system error, the OS
 * inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was
 * called to wake up all waiting threads without a finished task.
 *
 * A timeout can be used to specify a maximum wait time, but rather than
 * polling, it is possible to have a timeout of -1 to wait forever, and use
 * SDL_SignalAsyncIOQueue() to wake up the waiting threads later.
 *
 * @param queue the async I/O task queue to wait on.
 * @param outcome details of a finished task will be written here. May not be
 *                NULL.
 * @param timeoutMS the maximum time to wait, in milliseconds, or -1 to wait
 *                  indefinitely.
 * @returns true if task has completed, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SignalAsyncIOQueue
 *
 * @from SDL_asyncio.h:481 bool SDL_WaitAsyncIOResult(SDL_AsyncIOQueue *queue, SDL_AsyncIOOutcome *outcome, Sint32 timeoutMS);
 */
  waitAsyncIoResult: lib.symbols.SDL_WaitAsyncIOResult,

/**
 * Wake up any threads that are blocking in SDL_WaitAsyncIOResult().
 *
 * This will unblock any threads that are sleeping in a call to
 * SDL_WaitAsyncIOResult for the specified queue, and cause them to return
 * from that function.
 *
 * This can be useful when destroying a queue to make sure nothing is touching
 * it indefinitely. In this case, once this call completes, the caller should
 * take measures to make sure any previously-blocked threads have returned
 * from their wait and will not touch the queue again (perhaps by setting a
 * flag to tell the threads to terminate and then using SDL_WaitThread() to
 * make sure they've done so).
 *
 * @param queue the async I/O task queue to signal.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WaitAsyncIOResult
 *
 * @from SDL_asyncio.h:505 void SDL_SignalAsyncIOQueue(SDL_AsyncIOQueue *queue);
 */
  signalAsyncIoQueue: lib.symbols.SDL_SignalAsyncIOQueue,

/**
 * Load all the data from a file path, asynchronously.
 *
 * This function returns as quickly as possible; it does not wait for the read
 * to complete. On a successful return, this work will continue in the
 * background. If the work begins, even failure is asynchronous: a failing
 * return value from this function only means the work couldn't start at all.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in SDL_AsyncIOOutcome's
 * bytes_transferred value.
 *
 * This function will allocate the buffer to contain the file. It must be
 * deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field
 * after completion.
 *
 * An SDL_AsyncIOQueue must be specified. The newly-created task will be added
 * to it when it completes its work.
 *
 * @param file the path to read all available data from.
 * @param queue a queue to add the new SDL_AsyncIO to.
 * @param userdata an app-defined pointer that will be provided with the task
 *                 results.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LoadFile_IO
 *
 * @from SDL_asyncio.h:537 bool SDL_LoadFileAsync(const char *file, SDL_AsyncIOQueue *queue, void *userdata);
 */
  loadFileAsync: lib.symbols.SDL_LoadFileAsync,



/*--- SDL_atomic ---*/

/**
 * Try to lock a spin lock by setting it to a non-zero value.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * @param lock a pointer to a lock variable.
 * @returns true if the lock succeeded, false if the lock is already held.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockSpinlock
 * @sa SDL_UnlockSpinlock
 *
 * @from SDL_atomic.h:99 bool SDL_TryLockSpinlock(SDL_SpinLock *lock);
 */
  tryLockSpinlock: lib.symbols.SDL_TryLockSpinlock,

/**
 * Lock a spin lock by setting it to a non-zero value.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * @param lock a pointer to a lock variable.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_TryLockSpinlock
 * @sa SDL_UnlockSpinlock
 *
 * @from SDL_atomic.h:116 void SDL_LockSpinlock(SDL_SpinLock *lock);
 */
  lockSpinlock: lib.symbols.SDL_LockSpinlock,

/**
 * Unlock a spin lock by setting it to 0.
 *
 * Always returns immediately.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * @param lock a pointer to a lock variable.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockSpinlock
 * @sa SDL_TryLockSpinlock
 *
 * @from SDL_atomic.h:135 void SDL_UnlockSpinlock(SDL_SpinLock *lock);
 */
  unlockSpinlock: lib.symbols.SDL_UnlockSpinlock,

/**
 * Insert a memory release barrier (function version).
 *
 * Please refer to SDL_MemoryBarrierRelease for details. This is a function
 * version, which might be useful if you need to use this functionality from a
 * scripting language, etc. Also, some of the macro versions call this
 * function behind the scenes, where more heavy lifting can happen inside of
 * SDL. Generally, though, an app written in C/C++/etc should use the macro
 * version, as it will be more efficient.
 *
 * @threadsafety Obviously this function is safe to use from any thread at any
 *               time, but if you find yourself needing this, you are probably
 *               dealing with some very sensitive code; be careful!
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_MemoryBarrierRelease
 *
 * @from SDL_atomic.h:191 void SDL_MemoryBarrierReleaseFunction(void);
 */
  memoryBarrierReleaseFunction: lib.symbols.SDL_MemoryBarrierReleaseFunction,

/**
 * Insert a memory acquire barrier (function version).
 *
 * Please refer to SDL_MemoryBarrierRelease for details. This is a function
 * version, which might be useful if you need to use this functionality from a
 * scripting language, etc. Also, some of the macro versions call this
 * function behind the scenes, where more heavy lifting can happen inside of
 * SDL. Generally, though, an app written in C/C++/etc should use the macro
 * version, as it will be more efficient.
 *
 * @threadsafety Obviously this function is safe to use from any thread at any
 *               time, but if you find yourself needing this, you are probably
 *               dealing with some very sensitive code; be careful!
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_MemoryBarrierAcquire
 *
 * @from SDL_atomic.h:211 void SDL_MemoryBarrierAcquireFunction(void);
 */
  memoryBarrierAcquireFunction: lib.symbols.SDL_MemoryBarrierAcquireFunction,

/**
 * Set an atomic variable to a new value if it is currently an old value.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to an SDL_AtomicInt variable to be modified.
 * @param oldval the old value.
 * @param newval the new value.
 * @returns true if the atomic variable was set, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAtomicInt
 * @sa SDL_SetAtomicInt
 *
 * @from SDL_atomic.h:414 bool SDL_CompareAndSwapAtomicInt(SDL_AtomicInt *a, int oldval, int newval);
 */
  compareAndSwapAtomicInt: lib.symbols.SDL_CompareAndSwapAtomicInt,

/**
 * Set an atomic variable to a value.
 *
 * This function also acts as a full memory barrier.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to an SDL_AtomicInt variable to be modified.
 * @param v the desired value.
 * @returns the previous value of the atomic variable.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAtomicInt
 *
 * @from SDL_atomic.h:434 int SDL_SetAtomicInt(SDL_AtomicInt *a, int v);
 */
  setAtomicInt: lib.symbols.SDL_SetAtomicInt,

/**
 * Get the value of an atomic variable.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to an SDL_AtomicInt variable.
 * @returns the current value of an atomic variable.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAtomicInt
 *
 * @from SDL_atomic.h:451 int SDL_GetAtomicInt(SDL_AtomicInt *a);
 */
  getAtomicInt: lib.symbols.SDL_GetAtomicInt,

/**
 * Add to an atomic variable.
 *
 * This function also acts as a full memory barrier.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to an SDL_AtomicInt variable to be modified.
 * @param v the desired value to add.
 * @returns the previous value of the atomic variable.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AtomicDecRef
 * @sa SDL_AtomicIncRef
 *
 * @from SDL_atomic.h:472 int SDL_AddAtomicInt(SDL_AtomicInt *a, int v);
 */
  addAtomicInt: lib.symbols.SDL_AddAtomicInt,

/**
 * Set an atomic variable to a new value if it is currently an old value.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to an SDL_AtomicU32 variable to be modified.
 * @param oldval the old value.
 * @param newval the new value.
 * @returns true if the atomic variable was set, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAtomicU32
 * @sa SDL_SetAtomicU32
 *
 * @from SDL_atomic.h:559 bool SDL_CompareAndSwapAtomicU32(SDL_AtomicU32 *a, Uint32 oldval, Uint32 newval);
 */
  compareAndSwapAtomicU32: lib.symbols.SDL_CompareAndSwapAtomicU32,

/**
 * Set an atomic variable to a value.
 *
 * This function also acts as a full memory barrier.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to an SDL_AtomicU32 variable to be modified.
 * @param v the desired value.
 * @returns the previous value of the atomic variable.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAtomicU32
 *
 * @from SDL_atomic.h:579 Uint32 SDL_SetAtomicU32(SDL_AtomicU32 *a, Uint32 v);
 */
  setAtomicU32: lib.symbols.SDL_SetAtomicU32,

/**
 * Get the value of an atomic variable.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to an SDL_AtomicU32 variable.
 * @returns the current value of an atomic variable.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAtomicU32
 *
 * @from SDL_atomic.h:596 Uint32 SDL_GetAtomicU32(SDL_AtomicU32 *a);
 */
  getAtomicU32: lib.symbols.SDL_GetAtomicU32,

/**
 * Set a pointer to a new value if it is currently an old value.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to a pointer.
 * @param oldval the old pointer value.
 * @param newval the new pointer value.
 * @returns true if the pointer was set, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CompareAndSwapAtomicInt
 * @sa SDL_GetAtomicPointer
 * @sa SDL_SetAtomicPointer
 *
 * @from SDL_atomic.h:617 bool SDL_CompareAndSwapAtomicPointer(void **a, void *oldval, void *newval);
 */
  compareAndSwapAtomicPointer: lib.symbols.SDL_CompareAndSwapAtomicPointer,

/**
 * Set a pointer to a value atomically.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to a pointer.
 * @param v the desired pointer value.
 * @returns the previous value of the pointer.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CompareAndSwapAtomicPointer
 * @sa SDL_GetAtomicPointer
 *
 * @from SDL_atomic.h:636 void * SDL_SetAtomicPointer(void **a, void *v);
 */
  setAtomicPointer: lib.symbols.SDL_SetAtomicPointer,

/**
 * Get the value of a pointer atomically.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * @param a a pointer to a pointer.
 * @returns the current value of a pointer.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CompareAndSwapAtomicPointer
 * @sa SDL_SetAtomicPointer
 *
 * @from SDL_atomic.h:654 void * SDL_GetAtomicPointer(void **a);
 */
  getAtomicPointer: lib.symbols.SDL_GetAtomicPointer,



/*--- SDL_audio ---*/

/**
 * Audio format.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_AUDIO_BITSIZE
 * @sa SDL_AUDIO_BYTESIZE
 * @sa SDL_AUDIO_ISINT
 * @sa SDL_AUDIO_ISFLOAT
 * @sa SDL_AUDIO_ISBIGENDIAN
 * @sa SDL_AUDIO_ISLITTLEENDIAN
 * @sa SDL_AUDIO_ISSIGNED
 * @sa SDL_AUDIO_ISUNSIGNED
 *
 * @from SDL_audio.h:220 SDL_AUDIO_
 */
  AUDIO: SDL_audio_enums.SDL_AudioFormat,



/**
 * Use this function to get the number of built-in audio drivers.
 *
 * This function returns a hardcoded number. This never returns a negative
 * value; if there are no drivers compiled into this build of SDL, this
 * function returns zero. The presence of a driver in this list does not mean
 * it will function, it just means SDL is capable of interacting with that
 * interface. For example, a build of SDL might have esound support, but if
 * there's no esound server available, SDL's esound driver would fail if used.
 *
 * By default, SDL tries all drivers, in its preferred order, until one is
 * found to be usable.
 *
 * @returns the number of built-in audio drivers.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioDriver
 *
 * @from SDL_audio.h:476 int SDL_GetNumAudioDrivers(void);
 */
  getNumAudioDrivers: lib.symbols.SDL_GetNumAudioDrivers,

/**
 * Use this function to get the name of a built in audio driver.
 *
 * The list of audio drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "alsa",
 * "coreaudio" or "wasapi". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @param index the index of the audio driver; the value ranges from 0 to
 *              SDL_GetNumAudioDrivers() - 1.
 * @returns the name of the audio driver at the requested index, or NULL if an
 *          invalid index was specified.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumAudioDrivers
 *
 * @from SDL_audio.h:500 const char * SDL_GetAudioDriver(int index);
 */
  getAudioDriver: lib.symbols.SDL_GetAudioDriver,

/**
 * Get the name of the current audio driver.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "alsa",
 * "coreaudio" or "wasapi". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @returns the name of the current audio driver or NULL if no driver has been
 *          initialized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:516 const char * SDL_GetCurrentAudioDriver(void);
 */
  getCurrentAudioDriver: lib.symbols.SDL_GetCurrentAudioDriver,

/**
 * Get a list of currently-connected audio playback devices.
 *
 * This returns of list of available devices that play sound, perhaps to
 * speakers or headphones ("playback" devices). If you want devices that
 * record audio, like a microphone ("recording" devices), use
 * SDL_GetAudioRecordingDevices() instead.
 *
 * This only returns a list of physical devices; it will not have any device
 * IDs returned by SDL_OpenAudioDevice().
 *
 * If this function returns NULL, to signify an error, `*count` will be set to
 * zero.
 *
 * @param count a pointer filled in with the number of devices returned, may
 *              be NULL.
 * @returns a 0 terminated array of device instance IDs or NULL on error; call
 *          SDL_GetError() for more information. This should be freed with
 *          SDL_free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenAudioDevice
 * @sa SDL_GetAudioRecordingDevices
 *
 * @from SDL_audio.h:545 SDL_AudioDeviceID * SDL_GetAudioPlaybackDevices(int *count);
 */
  getAudioPlaybackDevices: lib.symbols.SDL_GetAudioPlaybackDevices,

/**
 * Get a list of currently-connected audio recording devices.
 *
 * This returns of list of available devices that record audio, like a
 * microphone ("recording" devices). If you want devices that play sound,
 * perhaps to speakers or headphones ("playback" devices), use
 * SDL_GetAudioPlaybackDevices() instead.
 *
 * This only returns a list of physical devices; it will not have any device
 * IDs returned by SDL_OpenAudioDevice().
 *
 * If this function returns NULL, to signify an error, `*count` will be set to
 * zero.
 *
 * @param count a pointer filled in with the number of devices returned, may
 *              be NULL.
 * @returns a 0 terminated array of device instance IDs, or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenAudioDevice
 * @sa SDL_GetAudioPlaybackDevices
 *
 * @from SDL_audio.h:574 SDL_AudioDeviceID * SDL_GetAudioRecordingDevices(int *count);
 */
  getAudioRecordingDevices: lib.symbols.SDL_GetAudioRecordingDevices,

/**
 * Get the human-readable name of a specific audio device.
 *
 * @param devid the instance ID of the device to query.
 * @returns the name of the audio device, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioPlaybackDevices
 * @sa SDL_GetAudioRecordingDevices
 *
 * @from SDL_audio.h:590 const char * SDL_GetAudioDeviceName(SDL_AudioDeviceID devid);
 */
  getAudioDeviceName: lib.symbols.SDL_GetAudioDeviceName,

/**
 * Get the current audio format of a specific audio device.
 *
 * For an opened device, this will report the format the device is currently
 * using. If the device isn't yet opened, this will report the device's
 * preferred format (or a reasonable default if this can't be determined).
 *
 * You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or
 * SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a
 * reasonable recommendation before opening the system-recommended default
 * device.
 *
 * You can also use this to request the current device buffer size. This is
 * specified in sample frames and represents the amount of data SDL will feed
 * to the physical hardware in each chunk. This can be converted to
 * milliseconds of audio with the following equation:
 *
 * `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`
 *
 * Buffer size is only important if you need low-level control over the audio
 * playback timing. Most apps do not need this.
 *
 * @param devid the instance ID of the device to query.
 * @param spec on return, will be filled with device details.
 * @param sample_frames pointer to store device buffer size, in sample frames.
 *                      Can be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:625 bool SDL_GetAudioDeviceFormat(SDL_AudioDeviceID devid, SDL_AudioSpec *spec, int *sample_frames);
 */
  getAudioDeviceFormat: lib.symbols.SDL_GetAudioDeviceFormat,

/**
 * Get the current channel map of an audio device.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio devices usually have no remapping applied. This is represented by
 * returning NULL, and does not signify an error.
 *
 * @param devid the instance ID of the device to query.
 * @param count On output, set to number of channels in the map. Can be NULL.
 * @returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or NULL if default. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamInputChannelMap
 *
 * @from SDL_audio.h:648 int * SDL_GetAudioDeviceChannelMap(SDL_AudioDeviceID devid, int *count);
 */
  getAudioDeviceChannelMap: lib.symbols.SDL_GetAudioDeviceChannelMap,

/**
 * Open a specific audio device.
 *
 * You can open both playback and recording devices through this function.
 * Playback devices will take data from bound audio streams, mix it, and send
 * it to the hardware. Recording devices will feed any bound audio streams
 * with a copy of any incoming data.
 *
 * An opened audio device starts out with no audio streams bound. To start
 * audio playing, bind a stream and supply audio data to it. Unlike SDL2,
 * there is no audio callback; you only bind audio streams and make sure they
 * have data flowing into them (however, you can simulate SDL2's semantics
 * fairly closely by using SDL_OpenAudioDeviceStream instead of this
 * function).
 *
 * If you don't care about opening a specific device, pass a `devid` of either
 * `SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK` or
 * `SDL_AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick
 * the most reasonable default, and may also switch between physical devices
 * seamlessly later, if the most reasonable default changes during the
 * lifetime of this opened device (user changed the default in the OS's system
 * preferences, the default got unplugged so the system jumped to a new
 * default, the user plugged in headphones on a mobile device, etc). Unless
 * you have a good reason to choose a specific device, this is probably what
 * you want.
 *
 * You may request a specific format for the audio device, but there is no
 * promise the device will honor that request for several reasons. As such,
 * it's only meant to be a hint as to what data your app will provide. Audio
 * streams will accept data in whatever format you specify and manage
 * conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you
 * the preferred format for the device before opening and the actual format
 * the device is using after opening.
 *
 * It's legal to open the same device ID more than once; each successful open
 * will generate a new logical SDL_AudioDeviceID that is managed separately
 * from others on the same physical device. This allows libraries to open a
 * device separately from the main app and bind its own streams without
 * conflicting.
 *
 * It is also legal to open a device ID returned by a previous call to this
 * function; doing so just creates another logical device on the same physical
 * device. This may be useful for making logical groupings of audio streams.
 *
 * This function returns the opened device ID on success. This is a new,
 * unique SDL_AudioDeviceID that represents a logical device.
 *
 * Some backends might offer arbitrary devices (for example, a networked audio
 * protocol that can connect to an arbitrary server). For these, as a change
 * from SDL2, you should open a default device ID and use an SDL hint to
 * specify the target if you care, or otherwise let the backend figure out a
 * reasonable default. Most backends don't offer anything like this, and often
 * this would be an end user setting an environment variable for their custom
 * need, and not something an application should specifically manage.
 *
 * When done with an audio device, possibly at the end of the app's life, one
 * should call SDL_CloseAudioDevice() on the returned device id.
 *
 * @param devid the device instance id to open, or
 *              SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or
 *              SDL_AUDIO_DEVICE_DEFAULT_RECORDING for the most reasonable
 *              default device.
 * @param spec the requested device configuration. Can be NULL to use
 *             reasonable defaults.
 * @returns the device ID on success or 0 on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseAudioDevice
 * @sa SDL_GetAudioDeviceFormat
 *
 * @from SDL_audio.h:724 SDL_AudioDeviceID SDL_OpenAudioDevice(SDL_AudioDeviceID devid, const SDL_AudioSpec *spec);
 */
  openAudioDevice: lib.symbols.SDL_OpenAudioDevice,

/**
 * Determine if an audio device is physical (instead of logical).
 *
 * An SDL_AudioDeviceID that represents physical hardware is a physical
 * device; there is one for each piece of hardware that SDL can see. Logical
 * devices are created by calling SDL_OpenAudioDevice or
 * SDL_OpenAudioDeviceStream, and while each is associated with a physical
 * device, there can be any number of logical devices on one physical device.
 *
 * For the most part, logical and physical IDs are interchangeable--if you try
 * to open a logical device, SDL understands to assign that effort to the
 * underlying physical device, etc. However, it might be useful to know if an
 * arbitrary device ID is physical or logical. This function reports which.
 *
 * This function may return either true or false for invalid device IDs.
 *
 * @param devid the device ID to query.
 * @returns true if devid is a physical device, false if it is logical.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:749 bool SDL_IsAudioDevicePhysical(SDL_AudioDeviceID devid);
 */
  isAudioDevicePhysical: lib.symbols.SDL_IsAudioDevicePhysical,

/**
 * Determine if an audio device is a playback device (instead of recording).
 *
 * This function may return either true or false for invalid device IDs.
 *
 * @param devid the device ID to query.
 * @returns true if devid is a playback device, false if it is recording.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:763 bool SDL_IsAudioDevicePlayback(SDL_AudioDeviceID devid);
 */
  isAudioDevicePlayback: lib.symbols.SDL_IsAudioDevicePlayback,

/**
 * Use this function to pause audio playback on a specified device.
 *
 * This function pauses audio processing for a given device. Any bound audio
 * streams will not progress, and no audio will be generated. Pausing one
 * device does not prevent other unpaused devices from running.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow. Pausing a paused device is
 * a legal no-op.
 *
 * Pausing a device can be useful to halt all audio without unbinding all the
 * audio streams. This might be useful while a game is paused, or a level is
 * loading, etc.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through SDL_OpenAudioDevice() can be.
 *
 * @param devid a device opened by SDL_OpenAudioDevice().
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ResumeAudioDevice
 * @sa SDL_AudioDevicePaused
 *
 * @from SDL_audio.h:794 bool SDL_PauseAudioDevice(SDL_AudioDeviceID devid);
 */
  pauseAudioDevice: lib.symbols.SDL_PauseAudioDevice,

/**
 * Use this function to unpause audio playback on a specified device.
 *
 * This function unpauses audio processing for a given device that has
 * previously been paused with SDL_PauseAudioDevice(). Once unpaused, any
 * bound audio streams will begin to progress again, and audio can be
 * generated.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow. Unpausing an unpaused
 * device is a legal no-op.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through SDL_OpenAudioDevice() can be.
 *
 * @param devid a device opened by SDL_OpenAudioDevice().
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AudioDevicePaused
 * @sa SDL_PauseAudioDevice
 *
 * @from SDL_audio.h:822 bool SDL_ResumeAudioDevice(SDL_AudioDeviceID devid);
 */
  resumeAudioDevice: lib.symbols.SDL_ResumeAudioDevice,

/**
 * Use this function to query if an audio device is paused.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow.
 *
 * Physical devices can not be paused or unpaused, only logical devices
 * created through SDL_OpenAudioDevice() can be. Physical and invalid device
 * IDs will report themselves as unpaused here.
 *
 * @param devid a device opened by SDL_OpenAudioDevice().
 * @returns true if device is valid and paused, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PauseAudioDevice
 * @sa SDL_ResumeAudioDevice
 *
 * @from SDL_audio.h:844 bool SDL_AudioDevicePaused(SDL_AudioDeviceID devid);
 */
  audioDevicePaused: lib.symbols.SDL_AudioDevicePaused,

/**
 * Get the gain of an audio device.
 *
 * The gain of a device is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio devices default to a gain of 1.0f (no change in output).
 *
 * Physical devices may not have their gain changed, only logical devices, and
 * this function will always return -1.0f when used on physical devices.
 *
 * @param devid the audio device to query.
 * @returns the gain of the device or -1.0f on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioDeviceGain
 *
 * @from SDL_audio.h:867 float SDL_GetAudioDeviceGain(SDL_AudioDeviceID devid);
 */
  getAudioDeviceGain: lib.symbols.SDL_GetAudioDeviceGain,

/**
 * Change the gain of an audio device.
 *
 * The gain of a device is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio devices default to a gain of 1.0f (no change in output).
 *
 * Physical devices may not have their gain changed, only logical devices, and
 * this function will always return false when used on physical devices. While
 * it might seem attractive to adjust several logical devices at once in this
 * way, it would allow an app or library to interfere with another portion of
 * the program's otherwise-isolated devices.
 *
 * This is applied, along with any per-audiostream gain, during playback to
 * the hardware, and can be continuously changed to create various effects. On
 * recording devices, this will adjust the gain before passing the data into
 * an audiostream; that recording audiostream can then adjust its gain further
 * when outputting the data elsewhere, if it likes, but that second gain is
 * not applied until the data leaves the audiostream again.
 *
 * @param devid the audio device on which to change gain.
 * @param gain the gain. 1.0f is no change, 0.0f is silence.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioDeviceGain
 *
 * @from SDL_audio.h:902 bool SDL_SetAudioDeviceGain(SDL_AudioDeviceID devid, float gain);
 */
  setAudioDeviceGain: lib.symbols.SDL_SetAudioDeviceGain,

/**
 * Close a previously-opened audio device.
 *
 * The application should close open audio devices once they are no longer
 * needed.
 *
 * This function may block briefly while pending audio data is played by the
 * hardware, so that applications don't drop the last buffer of data they
 * supplied if terminating immediately afterwards.
 *
 * @param devid an audio device id previously returned by
 *              SDL_OpenAudioDevice().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenAudioDevice
 *
 * @from SDL_audio.h:923 void SDL_CloseAudioDevice(SDL_AudioDeviceID devid);
 */
  closeAudioDevice: lib.symbols.SDL_CloseAudioDevice,

/**
 * Bind a list of audio streams to an audio device.
 *
 * Audio data will flow through any bound streams. For a playback device, data
 * for all bound streams will be mixed together and fed to the device. For a
 * recording device, a copy of recorded data will be provided to each bound
 * stream.
 *
 * Audio streams can only be bound to an open device. This operation is
 * atomic--all streams bound in the same call will start processing at the
 * same time, so they can stay in sync. Also: either all streams will be bound
 * or none of them will be.
 *
 * It is an error to bind an already-bound stream; it must be explicitly
 * unbound first.
 *
 * Binding a stream to a device will set its output format for playback
 * devices, and its input format for recording devices, so they match the
 * device's settings. The caller is welcome to change the other end of the
 * stream's format at any time with SDL_SetAudioStreamFormat().
 *
 * @param devid an audio device to bind a stream to.
 * @param streams an array of audio streams to bind.
 * @param num_streams number streams listed in the `streams` array.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BindAudioStreams
 * @sa SDL_UnbindAudioStream
 * @sa SDL_GetAudioStreamDevice
 *
 * @from SDL_audio.h:960 bool SDL_BindAudioStreams(SDL_AudioDeviceID devid, SDL_AudioStream * const *streams, int num_streams);
 */
  bindAudioStreams: lib.symbols.SDL_BindAudioStreams,

/**
 * Bind a single audio stream to an audio device.
 *
 * This is a convenience function, equivalent to calling
 * `SDL_BindAudioStreams(devid, &stream, 1)`.
 *
 * @param devid an audio device to bind a stream to.
 * @param stream an audio stream to bind to a device.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BindAudioStreams
 * @sa SDL_UnbindAudioStream
 * @sa SDL_GetAudioStreamDevice
 *
 * @from SDL_audio.h:981 bool SDL_BindAudioStream(SDL_AudioDeviceID devid, SDL_AudioStream *stream);
 */
  bindAudioStream: lib.symbols.SDL_BindAudioStream,

/**
 * Unbind a list of audio streams from their audio devices.
 *
 * The streams being unbound do not all have to be on the same device. All
 * streams on the same device will be unbound atomically (data will stop
 * flowing through all unbound streams on the same device at the same time).
 *
 * Unbinding a stream that isn't bound to a device is a legal no-op.
 *
 * @param streams an array of audio streams to unbind. Can be NULL or contain
 *                NULL.
 * @param num_streams number streams listed in the `streams` array.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BindAudioStreams
 *
 * @from SDL_audio.h:1002 void SDL_UnbindAudioStreams(SDL_AudioStream * const *streams, int num_streams);
 */
  unbindAudioStreams: lib.symbols.SDL_UnbindAudioStreams,

/**
 * Unbind a single audio stream from its audio device.
 *
 * This is a convenience function, equivalent to calling
 * `SDL_UnbindAudioStreams(&stream, 1)`.
 *
 * @param stream an audio stream to unbind from a device. Can be NULL.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BindAudioStream
 *
 * @from SDL_audio.h:1018 void SDL_UnbindAudioStream(SDL_AudioStream *stream);
 */
  unbindAudioStream: lib.symbols.SDL_UnbindAudioStream,

/**
 * Query an audio stream for its currently-bound device.
 *
 * This reports the audio device that an audio stream is currently bound to.
 *
 * If not bound, or invalid, this returns zero, which is not a valid device
 * ID.
 *
 * @param stream the audio stream to query.
 * @returns the bound audio device, or 0 if not bound or invalid.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BindAudioStream
 * @sa SDL_BindAudioStreams
 *
 * @from SDL_audio.h:1038 SDL_AudioDeviceID SDL_GetAudioStreamDevice(SDL_AudioStream *stream);
 */
  getAudioStreamDevice: lib.symbols.SDL_GetAudioStreamDevice,

/**
 * Create a new audio stream.
 *
 * @param src_spec the format details of the input audio.
 * @param dst_spec the format details of the output audio.
 * @returns a new audio stream on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PutAudioStreamData
 * @sa SDL_GetAudioStreamData
 * @sa SDL_GetAudioStreamAvailable
 * @sa SDL_FlushAudioStream
 * @sa SDL_ClearAudioStream
 * @sa SDL_SetAudioStreamFormat
 * @sa SDL_DestroyAudioStream
 *
 * @from SDL_audio.h:1060 SDL_AudioStream * SDL_CreateAudioStream(const SDL_AudioSpec *src_spec, const SDL_AudioSpec *dst_spec);
 */
  createAudioStream: lib.symbols.SDL_CreateAudioStream,

/**
 * Get the properties associated with an audio stream.
 *
 * @param stream the SDL_AudioStream to query.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:1073 SDL_PropertiesID SDL_GetAudioStreamProperties(SDL_AudioStream *stream);
 */
  getAudioStreamProperties: lib.symbols.SDL_GetAudioStreamProperties,

/**
 * Query the current format of an audio stream.
 *
 * @param stream the SDL_AudioStream to query.
 * @param src_spec where to store the input audio format; ignored if NULL.
 * @param dst_spec where to store the output audio format; ignored if NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamFormat
 *
 * @from SDL_audio.h:1091 bool SDL_GetAudioStreamFormat(SDL_AudioStream *stream, SDL_AudioSpec *src_spec, SDL_AudioSpec *dst_spec);
 */
  getAudioStreamFormat: lib.symbols.SDL_GetAudioStreamFormat,

/**
 * Change the input and output formats of an audio stream.
 *
 * Future calls to and SDL_GetAudioStreamAvailable and SDL_GetAudioStreamData
 * will reflect the new format, and future calls to SDL_PutAudioStreamData
 * must provide data in the new input formats.
 *
 * Data that was previously queued in the stream will still be operated on in
 * the format that was current when it was added, which is to say you can put
 * the end of a sound file in one format to a stream, change formats for the
 * next sound file, and start putting that new data while the previous sound
 * file is still queued, and everything will still play back correctly.
 *
 * If a stream is bound to a device, then the format of the side of the stream
 * bound to a device cannot be changed (src_spec for recording devices,
 * dst_spec for playback devices). Attempts to make a change to this side will
 * be ignored, but this will not report an error. The other side's format can
 * be changed.
 *
 * @param stream the stream the format is being changed.
 * @param src_spec the new format of the audio input; if NULL, it is not
 *                 changed.
 * @param dst_spec the new format of the audio output; if NULL, it is not
 *                 changed.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioStreamFormat
 * @sa SDL_SetAudioStreamFrequencyRatio
 *
 * @from SDL_audio.h:1128 bool SDL_SetAudioStreamFormat(SDL_AudioStream *stream, const SDL_AudioSpec *src_spec, const SDL_AudioSpec *dst_spec);
 */
  setAudioStreamFormat: lib.symbols.SDL_SetAudioStreamFormat,

/**
 * Get the frequency ratio of an audio stream.
 *
 * @param stream the SDL_AudioStream to query.
 * @returns the frequency ratio of the stream or 0.0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamFrequencyRatio
 *
 * @from SDL_audio.h:1144 float SDL_GetAudioStreamFrequencyRatio(SDL_AudioStream *stream);
 */
  getAudioStreamFrequencyRatio: lib.symbols.SDL_GetAudioStreamFrequencyRatio,

/**
 * Change the frequency ratio of an audio stream.
 *
 * The frequency ratio is used to adjust the rate at which input data is
 * consumed. Changing this effectively modifies the speed and pitch of the
 * audio. A value greater than 1.0 will play the audio faster, and at a higher
 * pitch. A value less than 1.0 will play the audio slower, and at a lower
 * pitch.
 *
 * This is applied during SDL_GetAudioStreamData, and can be continuously
 * changed to create various effects.
 *
 * @param stream the stream the frequency ratio is being changed.
 * @param ratio the frequency ratio. 1.0 is normal speed. Must be between 0.01
 *              and 100.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioStreamFrequencyRatio
 * @sa SDL_SetAudioStreamFormat
 *
 * @from SDL_audio.h:1172 bool SDL_SetAudioStreamFrequencyRatio(SDL_AudioStream *stream, float ratio);
 */
  setAudioStreamFrequencyRatio: lib.symbols.SDL_SetAudioStreamFrequencyRatio,

/**
 * Get the gain of an audio stream.
 *
 * The gain of a stream is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio streams default to a gain of 1.0f (no change in output).
 *
 * @param stream the SDL_AudioStream to query.
 * @returns the gain of the stream or -1.0f on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamGain
 *
 * @from SDL_audio.h:1193 float SDL_GetAudioStreamGain(SDL_AudioStream *stream);
 */
  getAudioStreamGain: lib.symbols.SDL_GetAudioStreamGain,

/**
 * Change the gain of an audio stream.
 *
 * The gain of a stream is its volume; a larger gain means a louder output,
 * with a gain of zero being silence.
 *
 * Audio streams default to a gain of 1.0f (no change in output).
 *
 * This is applied during SDL_GetAudioStreamData, and can be continuously
 * changed to create various effects.
 *
 * @param stream the stream on which the gain is being changed.
 * @param gain the gain. 1.0f is no change, 0.0f is silence.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioStreamGain
 *
 * @from SDL_audio.h:1218 bool SDL_SetAudioStreamGain(SDL_AudioStream *stream, float gain);
 */
  setAudioStreamGain: lib.symbols.SDL_SetAudioStreamGain,

/**
 * Get the current input channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio streams default to no remapping applied. This is represented by
 * returning NULL, and does not signify an error.
 *
 * @param stream the SDL_AudioStream to query.
 * @param count On output, set to number of channels in the map. Can be NULL.
 * @returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or NULL if default. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamInputChannelMap
 *
 * @from SDL_audio.h:1242 int * SDL_GetAudioStreamInputChannelMap(SDL_AudioStream *stream, int *count);
 */
  getAudioStreamInputChannelMap: lib.symbols.SDL_GetAudioStreamInputChannelMap,

/**
 * Get the current output channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * Audio streams default to no remapping applied. This is represented by
 * returning NULL, and does not signify an error.
 *
 * @param stream the SDL_AudioStream to query.
 * @param count On output, set to number of channels in the map. Can be NULL.
 * @returns an array of the current channel mapping, with as many elements as
 *          the current output spec's channels, or NULL if default. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamInputChannelMap
 *
 * @from SDL_audio.h:1266 int * SDL_GetAudioStreamOutputChannelMap(SDL_AudioStream *stream, int *count);
 */
  getAudioStreamOutputChannelMap: lib.symbols.SDL_GetAudioStreamOutputChannelMap,

/**
 * Set the current input channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * The input channel map reorders data that is added to a stream via
 * SDL_PutAudioStreamData. Future calls to SDL_PutAudioStreamData must provide
 * data in the new channel order.
 *
 * Each item in the array represents an input channel, and its value is the
 * channel that it should be remapped to. To reverse a stereo signal's left
 * and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
 * multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
 * right channel to both channels of a stereo signal. An element in the
 * channel map set to -1 instead of a valid channel will mute that channel,
 * setting it to a silence value.
 *
 * You cannot change the number of channels through a channel map, just
 * reorder/mute them.
 *
 * Data that was previously queued in the stream will still be operated on in
 * the order that was current when it was added, which is to say you can put
 * the end of a sound file in one order to a stream, change orders for the
 * next sound file, and start putting that new data while the previous sound
 * file is still queued, and everything will still play back correctly.
 *
 * Audio streams default to no remapping applied. Passing a NULL channel map
 * is legal, and turns off remapping.
 *
 * SDL will copy the channel map; the caller does not have to save this array
 * after this call.
 *
 * If `count` is not equal to the current number of channels in the audio
 * stream's format, this will fail. This is a safety measure to make sure a
 * race condition hasn't changed the format while this call is setting the
 * channel map.
 *
 * Unlike attempting to change the stream's format, the input channel map on a
 * stream bound to a recording device is permitted to change at any time; any
 * data added to the stream from the device after this call will have the new
 * mapping, but previously-added data will still have the prior mapping.
 *
 * @param stream the SDL_AudioStream to change.
 * @param chmap the new channel map, NULL to reset to default.
 * @param count The number of channels in the map.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running. Don't change the
 *               stream's format to have a different number of channels from a
 *               a different thread at the same time, though!
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamInputChannelMap
 *
 * @from SDL_audio.h:1326 bool SDL_SetAudioStreamInputChannelMap(SDL_AudioStream *stream, const int *chmap, int count);
 */
  setAudioStreamInputChannelMap: lib.symbols.SDL_SetAudioStreamInputChannelMap,

/**
 * Set the current output channel map of an audio stream.
 *
 * Channel maps are optional; most things do not need them, instead passing
 * data in the [order that SDL expects](CategoryAudio#channel-layouts).
 *
 * The output channel map reorders data that leaving a stream via
 * SDL_GetAudioStreamData.
 *
 * Each item in the array represents an input channel, and its value is the
 * channel that it should be remapped to. To reverse a stereo signal's left
 * and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap
 * multiple channels to the same thing, so `{ 1, 1 }` would duplicate the
 * right channel to both channels of a stereo signal. An element in the
 * channel map set to -1 instead of a valid channel will mute that channel,
 * setting it to a silence value.
 *
 * You cannot change the number of channels through a channel map, just
 * reorder/mute them.
 *
 * The output channel map can be changed at any time, as output remapping is
 * applied during SDL_GetAudioStreamData.
 *
 * Audio streams default to no remapping applied. Passing a NULL channel map
 * is legal, and turns off remapping.
 *
 * SDL will copy the channel map; the caller does not have to save this array
 * after this call.
 *
 * If `count` is not equal to the current number of channels in the audio
 * stream's format, this will fail. This is a safety measure to make sure a
 * race condition hasn't changed the format while this call is setting the
 * channel map.
 *
 * Unlike attempting to change the stream's format, the output channel map on
 * a stream bound to a recording device is permitted to change at any time;
 * any data added to the stream after this call will have the new mapping, but
 * previously-added data will still have the prior mapping. When the channel
 * map doesn't match the hardware's channel layout, SDL will convert the data
 * before feeding it to the device for playback.
 *
 * @param stream the SDL_AudioStream to change.
 * @param chmap the new channel map, NULL to reset to default.
 * @param count The number of channels in the map.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, as it holds
 *               a stream-specific mutex while running. Don't change the
 *               stream's format to have a different number of channels from a
 *               a different thread at the same time, though!
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamInputChannelMap
 *
 * @from SDL_audio.h:1384 bool SDL_SetAudioStreamOutputChannelMap(SDL_AudioStream *stream, const int *chmap, int count);
 */
  setAudioStreamOutputChannelMap: lib.symbols.SDL_SetAudioStreamOutputChannelMap,

/**
 * Add data to the stream.
 *
 * This data must match the format/channels/samplerate specified in the latest
 * call to SDL_SetAudioStreamFormat, or the format specified when creating the
 * stream if it hasn't been changed.
 *
 * Note that this call simply copies the unconverted data for later. This is
 * different than SDL2, where data was converted during the Put call and the
 * Get call would just dequeue the previously-converted data.
 *
 * @param stream the stream the audio data is being added to.
 * @param buf a pointer to the audio data to add.
 * @param len the number of bytes to write to the stream.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, but if the
 *               stream has a callback set, the caller might need to manage
 *               extra locking.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ClearAudioStream
 * @sa SDL_FlushAudioStream
 * @sa SDL_GetAudioStreamData
 * @sa SDL_GetAudioStreamQueued
 *
 * @from SDL_audio.h:1414 bool SDL_PutAudioStreamData(SDL_AudioStream *stream, const void *buf, int len);
 */
  putAudioStreamData: lib.symbols.SDL_PutAudioStreamData,

/**
 * Get converted/resampled data from the stream.
 *
 * The input/output data format/channels/samplerate is specified when creating
 * the stream, and can be changed after creation by calling
 * SDL_SetAudioStreamFormat.
 *
 * Note that any conversion and resampling necessary is done during this call,
 * and SDL_PutAudioStreamData simply queues unconverted data for later. This
 * is different than SDL2, where that work was done while inputting new data
 * to the stream and requesting the output just copied the converted data.
 *
 * @param stream the stream the audio is being requested from.
 * @param buf a buffer to fill with audio data.
 * @param len the maximum number of bytes to fill.
 * @returns the number of bytes read from the stream or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread, but if the
 *               stream has a callback set, the caller might need to manage
 *               extra locking.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ClearAudioStream
 * @sa SDL_GetAudioStreamAvailable
 * @sa SDL_PutAudioStreamData
 *
 * @from SDL_audio.h:1444 int SDL_GetAudioStreamData(SDL_AudioStream *stream, void *buf, int len);
 */
  getAudioStreamData: lib.symbols.SDL_GetAudioStreamData,

/**
 * Get the number of converted/resampled bytes available.
 *
 * The stream may be buffering data behind the scenes until it has enough to
 * resample correctly, so this number might be lower than what you expect, or
 * even be zero. Add more data or flush the stream if you need the data now.
 *
 * If the stream has so much data that it would overflow an int, the return
 * value is clamped to a maximum value, but no queued data is lost; if there
 * are gigabytes of data queued, the app might need to read some of it with
 * SDL_GetAudioStreamData before this function's return value is no longer
 * clamped.
 *
 * @param stream the audio stream to query.
 * @returns the number of converted/resampled bytes available or -1 on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioStreamData
 * @sa SDL_PutAudioStreamData
 *
 * @from SDL_audio.h:1470 int SDL_GetAudioStreamAvailable(SDL_AudioStream *stream);
 */
  getAudioStreamAvailable: lib.symbols.SDL_GetAudioStreamAvailable,

/**
 * Get the number of bytes currently queued.
 *
 * This is the number of bytes put into a stream as input, not the number that
 * can be retrieved as output. Because of several details, it's not possible
 * to calculate one number directly from the other. If you need to know how
 * much usable data can be retrieved right now, you should use
 * SDL_GetAudioStreamAvailable() and not this function.
 *
 * Note that audio streams can change their input format at any time, even if
 * there is still data queued in a different format, so the returned byte
 * count will not necessarily match the number of _sample frames_ available.
 * Users of this API should be aware of format changes they make when feeding
 * a stream and plan accordingly.
 *
 * Queued data is not converted until it is consumed by
 * SDL_GetAudioStreamData, so this value should be representative of the exact
 * data that was put into the stream.
 *
 * If the stream has so much data that it would overflow an int, the return
 * value is clamped to a maximum value, but no queued data is lost; if there
 * are gigabytes of data queued, the app might need to read some of it with
 * SDL_GetAudioStreamData before this function's return value is no longer
 * clamped.
 *
 * @param stream the audio stream to query.
 * @returns the number of bytes queued or -1 on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PutAudioStreamData
 * @sa SDL_ClearAudioStream
 *
 * @from SDL_audio.h:1509 int SDL_GetAudioStreamQueued(SDL_AudioStream *stream);
 */
  getAudioStreamQueued: lib.symbols.SDL_GetAudioStreamQueued,

/**
 * Tell the stream that you're done sending data, and anything being buffered
 * should be converted/resampled and made available immediately.
 *
 * It is legal to add more data to a stream after flushing, but there may be
 * audio gaps in the output. Generally this is intended to signal the end of
 * input, so the complete output becomes available.
 *
 * @param stream the audio stream to flush.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PutAudioStreamData
 *
 * @from SDL_audio.h:1530 bool SDL_FlushAudioStream(SDL_AudioStream *stream);
 */
  flushAudioStream: lib.symbols.SDL_FlushAudioStream,

/**
 * Clear any pending data in the stream.
 *
 * This drops any queued data, so there will be nothing to read from the
 * stream until more is added.
 *
 * @param stream the audio stream to clear.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioStreamAvailable
 * @sa SDL_GetAudioStreamData
 * @sa SDL_GetAudioStreamQueued
 * @sa SDL_PutAudioStreamData
 *
 * @from SDL_audio.h:1551 bool SDL_ClearAudioStream(SDL_AudioStream *stream);
 */
  clearAudioStream: lib.symbols.SDL_ClearAudioStream,

/**
 * Use this function to pause audio playback on the audio device associated
 * with an audio stream.
 *
 * This function pauses audio processing for a given device. Any bound audio
 * streams will not progress, and no audio will be generated. Pausing one
 * device does not prevent other unpaused devices from running.
 *
 * Pausing a device can be useful to halt all audio without unbinding all the
 * audio streams. This might be useful while a game is paused, or a level is
 * loading, etc.
 *
 * @param stream the audio stream associated with the audio device to pause.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ResumeAudioStreamDevice
 *
 * @from SDL_audio.h:1575 bool SDL_PauseAudioStreamDevice(SDL_AudioStream *stream);
 */
  pauseAudioStreamDevice: lib.symbols.SDL_PauseAudioStreamDevice,

/**
 * Use this function to unpause audio playback on the audio device associated
 * with an audio stream.
 *
 * This function unpauses audio processing for a given device that has
 * previously been paused. Once unpaused, any bound audio streams will begin
 * to progress again, and audio can be generated.
 *
 * Remember, SDL_OpenAudioDeviceStream opens device in a paused state, so this
 * function call is required for audio playback to begin on such device.
 *
 * @param stream the audio stream associated with the audio device to resume.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PauseAudioStreamDevice
 *
 * @from SDL_audio.h:1598 bool SDL_ResumeAudioStreamDevice(SDL_AudioStream *stream);
 */
  resumeAudioStreamDevice: lib.symbols.SDL_ResumeAudioStreamDevice,

/**
 * Use this function to query if an audio device associated with a stream is
 * paused.
 *
 * Unlike in SDL2, audio devices start in an _unpaused_ state, since an app
 * has to bind a stream before any audio will flow.
 *
 * @param stream the audio stream associated with the audio device to query.
 * @returns true if device is valid and paused, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PauseAudioStreamDevice
 * @sa SDL_ResumeAudioStreamDevice
 *
 * @from SDL_audio.h:1617 bool SDL_AudioStreamDevicePaused(SDL_AudioStream *stream);
 */
  audioStreamDevicePaused: lib.symbols.SDL_AudioStreamDevicePaused,

/**
 * Lock an audio stream for serialized access.
 *
 * Each SDL_AudioStream has an internal mutex it uses to protect its data
 * structures from threading conflicts. This function allows an app to lock
 * that mutex, which could be useful if registering callbacks on this stream.
 *
 * One does not need to lock a stream to use in it most cases, as the stream
 * manages this lock internally. However, this lock is held during callbacks,
 * which may run from arbitrary threads at any time, so if an app needs to
 * protect shared data during those callbacks, locking the stream guarantees
 * that the callback is not running while the lock is held.
 *
 * As this is just a wrapper over SDL_LockMutex for an internal lock; it has
 * all the same attributes (recursive locks are allowed, etc).
 *
 * @param stream the audio stream to lock.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UnlockAudioStream
 *
 * @from SDL_audio.h:1646 bool SDL_LockAudioStream(SDL_AudioStream *stream);
 */
  lockAudioStream: lib.symbols.SDL_LockAudioStream,

/**
 * Unlock an audio stream for serialized access.
 *
 * This unlocks an audio stream after a call to SDL_LockAudioStream.
 *
 * @param stream the audio stream to unlock.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety You should only call this from the same thread that
 *               previously called SDL_LockAudioStream.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockAudioStream
 *
 * @from SDL_audio.h:1665 bool SDL_UnlockAudioStream(SDL_AudioStream *stream);
 */
  unlockAudioStream: lib.symbols.SDL_UnlockAudioStream,

/**
 * Set a callback that runs when data is requested from an audio stream.
 *
 * This callback is called _before_ data is obtained from the stream, giving
 * the callback the chance to add more on-demand.
 *
 * The callback can (optionally) call SDL_PutAudioStreamData() to add more
 * audio to the stream during this call; if needed, the request that triggered
 * this callback will obtain the new data immediately.
 *
 * The callback's `additional_amount` argument is roughly how many bytes of
 * _unconverted_ data (in the stream's input format) is needed by the caller,
 * although this may overestimate a little for safety. This takes into account
 * how much is already in the stream and only asks for any extra necessary to
 * resolve the request, which means the callback may be asked for zero bytes,
 * and a different amount on each call.
 *
 * The callback is not required to supply exact amounts; it is allowed to
 * supply too much or too little or none at all. The caller will get what's
 * available, up to the amount they requested, regardless of this callback's
 * outcome.
 *
 * Clearing or flushing an audio stream does not call this callback.
 *
 * This function obtains the stream's lock, which means any existing callback
 * (get or put) in progress will finish running before setting the new
 * callback.
 *
 * Setting a NULL function turns off the callback.
 *
 * @param stream the audio stream to set the new callback on.
 * @param callback the new callback function to call when data is requested
 *                 from the stream.
 * @param userdata an opaque pointer provided to the callback for its own
 *                 personal use.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information. This only fails if `stream` is NULL.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamPutCallback
 *
 * @from SDL_audio.h:1753 bool SDL_SetAudioStreamGetCallback(SDL_AudioStream *stream, SDL_AudioStreamCallback callback, void *userdata);
 */
  setAudioStreamGetCallback: lib.symbols.SDL_SetAudioStreamGetCallback,

/**
 * Set a callback that runs when data is added to an audio stream.
 *
 * This callback is called _after_ the data is added to the stream, giving the
 * callback the chance to obtain it immediately.
 *
 * The callback can (optionally) call SDL_GetAudioStreamData() to obtain audio
 * from the stream during this call.
 *
 * The callback's `additional_amount` argument is how many bytes of
 * _converted_ data (in the stream's output format) was provided by the
 * caller, although this may underestimate a little for safety. This value
 * might be less than what is currently available in the stream, if data was
 * already there, and might be less than the caller provided if the stream
 * needs to keep a buffer to aid in resampling. Which means the callback may
 * be provided with zero bytes, and a different amount on each call.
 *
 * The callback may call SDL_GetAudioStreamAvailable to see the total amount
 * currently available to read from the stream, instead of the total provided
 * by the current call.
 *
 * The callback is not required to obtain all data. It is allowed to read less
 * or none at all. Anything not read now simply remains in the stream for
 * later access.
 *
 * Clearing or flushing an audio stream does not call this callback.
 *
 * This function obtains the stream's lock, which means any existing callback
 * (get or put) in progress will finish running before setting the new
 * callback.
 *
 * Setting a NULL function turns off the callback.
 *
 * @param stream the audio stream to set the new callback on.
 * @param callback the new callback function to call when data is added to the
 *                 stream.
 * @param userdata an opaque pointer provided to the callback for its own
 *                 personal use.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information. This only fails if `stream` is NULL.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAudioStreamGetCallback
 *
 * @from SDL_audio.h:1802 bool SDL_SetAudioStreamPutCallback(SDL_AudioStream *stream, SDL_AudioStreamCallback callback, void *userdata);
 */
  setAudioStreamPutCallback: lib.symbols.SDL_SetAudioStreamPutCallback,

/**
 * Free an audio stream.
 *
 * This will release all allocated data, including any audio that is still
 * queued. You do not need to manually clear the stream first.
 *
 * If this stream was bound to an audio device, it is unbound during this
 * call. If this stream was created with SDL_OpenAudioDeviceStream, the audio
 * device that was opened alongside this stream's creation will be closed,
 * too.
 *
 * @param stream the audio stream to destroy.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateAudioStream
 *
 * @from SDL_audio.h:1824 void SDL_DestroyAudioStream(SDL_AudioStream *stream);
 */
  destroyAudioStream: lib.symbols.SDL_DestroyAudioStream,

/**
 * Convenience function for straightforward audio init for the common case.
 *
 * If all your app intends to do is provide a single source of PCM audio, this
 * function allows you to do all your audio setup in a single call.
 *
 * This is also intended to be a clean means to migrate apps from SDL2.
 *
 * This function will open an audio device, create a stream and bind it.
 * Unlike other methods of setup, the audio device will be closed when this
 * stream is destroyed, so the app can treat the returned SDL_AudioStream as
 * the only object needed to manage audio playback.
 *
 * Also unlike other functions, the audio device begins paused. This is to map
 * more closely to SDL2-style behavior, since there is no extra step here to
 * bind a stream to begin audio flowing. The audio device should be resumed
 * with `SDL_ResumeAudioStreamDevice(stream);`
 *
 * This function works with both playback and recording devices.
 *
 * The `spec` parameter represents the app's side of the audio stream. That
 * is, for recording audio, this will be the output format, and for playing
 * audio, this will be the input format. If spec is NULL, the system will
 * choose the format, and the app can use SDL_GetAudioStreamFormat() to obtain
 * this information later.
 *
 * If you don't care about opening a specific audio device, you can (and
 * probably _should_), use SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and
 * SDL_AUDIO_DEVICE_DEFAULT_RECORDING for recording.
 *
 * One can optionally provide a callback function; if NULL, the app is
 * expected to queue audio data for playback (or unqueue audio data if
 * capturing). Otherwise, the callback will begin to fire once the device is
 * unpaused.
 *
 * Destroying the returned stream with SDL_DestroyAudioStream will also close
 * the audio device associated with this stream.
 *
 * @param devid an audio device to open, or SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK
 *              or SDL_AUDIO_DEVICE_DEFAULT_RECORDING.
 * @param spec the audio stream's data format. Can be NULL.
 * @param callback a callback where the app will provide new data for
 *                 playback, or receive new data for recording. Can be NULL,
 *                 in which case the app will need to call
 *                 SDL_PutAudioStreamData or SDL_GetAudioStreamData as
 *                 necessary.
 * @param userdata app-controlled pointer passed to callback. Can be NULL.
 *                 Ignored if callback is NULL.
 * @returns an audio stream on success, ready to use, or NULL on failure; call
 *          SDL_GetError() for more information. When done with this stream,
 *          call SDL_DestroyAudioStream to free resources and close the
 *          device.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAudioStreamDevice
 * @sa SDL_ResumeAudioStreamDevice
 *
 * @from SDL_audio.h:1887 SDL_AudioStream * SDL_OpenAudioDeviceStream(SDL_AudioDeviceID devid, const SDL_AudioSpec *spec, SDL_AudioStreamCallback callback, void *userdata);
 */
  openAudioDeviceStream: lib.symbols.SDL_OpenAudioDeviceStream,

/**
 * Set a callback that fires when data is about to be fed to an audio device.
 *
 * This is useful for accessing the final mix, perhaps for writing a
 * visualizer or applying a final effect to the audio data before playback.
 *
 * The buffer is the final mix of all bound audio streams on an opened device;
 * this callback will fire regularly for any device that is both opened and
 * unpaused. If there is no new data to mix, either because no streams are
 * bound to the device or all the streams are empty, this callback will still
 * fire with the entire buffer set to silence.
 *
 * This callback is allowed to make changes to the data; the contents of the
 * buffer after this call is what is ultimately passed along to the hardware.
 *
 * The callback is always provided the data in float format (values from -1.0f
 * to 1.0f), but the number of channels or sample rate may be different than
 * the format the app requested when opening the device; SDL might have had to
 * manage a conversion behind the scenes, or the playback might have jumped to
 * new physical hardware when a system default changed, etc. These details may
 * change between calls. Accordingly, the size of the buffer might change
 * between calls as well.
 *
 * This callback can run at any time, and from any thread; if you need to
 * serialize access to your app's data, you should provide and use a mutex or
 * other synchronization device.
 *
 * All of this to say: there are specific needs this callback can fulfill, but
 * it is not the simplest interface. Apps should generally provide audio in
 * their preferred format through an SDL_AudioStream and let SDL handle the
 * difference.
 *
 * This function is extremely time-sensitive; the callback should do the least
 * amount of work possible and return as quickly as it can. The longer the
 * callback runs, the higher the risk of audio dropouts or other problems.
 *
 * This function will block until the audio device is in between iterations,
 * so any existing callback that might be running will finish before this
 * function sets the new callback and returns.
 *
 * Setting a NULL callback function disables any previously-set callback.
 *
 * @param devid the ID of an opened audio device.
 * @param callback a callback function to be called. Can be NULL.
 * @param userdata app-controlled pointer passed to callback. Can be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:1978 bool SDL_SetAudioPostmixCallback(SDL_AudioDeviceID devid, SDL_AudioPostmixCallback callback, void *userdata);
 */
  setAudioPostmixCallback: lib.symbols.SDL_SetAudioPostmixCallback,

/**
 * Load the audio data of a WAVE file into memory.
 *
 * Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to
 * be valid pointers. The entire data portion of the file is then loaded into
 * memory and decoded if necessary.
 *
 * Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and
 * 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and
 * A-law and mu-law (8 bits). Other formats are currently unsupported and
 * cause an error.
 *
 * If this function succeeds, the return value is zero and the pointer to the
 * audio data allocated by the function is written to `audio_buf` and its
 * length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,
 * `channels`, and `format` are set to the values of the audio data in the
 * buffer.
 *
 * It's necessary to use SDL_free() to free the audio data returned in
 * `audio_buf` when it is no longer used.
 *
 * Because of the underspecification of the .WAV format, there are many
 * problematic files in the wild that cause issues with strict decoders. To
 * provide compatibility with these files, this decoder is lenient in regards
 * to the truncation of the file, the fact chunk, and the size of the RIFF
 * chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,
 * `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to
 * tune the behavior of the loading process.
 *
 * Any file that is invalid (due to truncation, corruption, or wrong values in
 * the headers), too big, or unsupported causes an error. Additionally, any
 * critical I/O error from the data source will terminate the loading process
 * with an error. The function returns NULL on error and in all cases (with
 * the exception of `src` being NULL), an appropriate error message will be
 * set.
 *
 * It is required that the data source supports seeking.
 *
 * Example:
 *
 * ```c
 * SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), true, &spec, &buf, &len);
 * ```
 *
 * Note that the SDL_LoadWAV function does this same thing for you, but in a
 * less messy way:
 *
 * ```c
 * SDL_LoadWAV("sample.wav", &spec, &buf, &len);
 * ```
 *
 * @param src the data source for the WAVE data.
 * @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * @param spec a pointer to an SDL_AudioSpec that will be set to the WAVE
 *             data's format details on successful return.
 * @param audio_buf a pointer filled with the audio data, allocated by the
 *                  function.
 * @param audio_len a pointer filled with the length of the audio data buffer
 *                  in bytes.
 * @returns true on success. `audio_buf` will be filled with a pointer to an
 *          allocated buffer containing the audio data, and `audio_len` is
 *          filled with the length of that audio buffer in bytes.
 *
 *          This function returns false if the .WAV file cannot be opened,
 *          uses an unknown data format, or is corrupt; call SDL_GetError()
 *          for more information.
 *
 *          When the application is done with the data returned in
 *          `audio_buf`, it should call SDL_free() to dispose of it.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_free
 * @sa SDL_LoadWAV
 *
 * @from SDL_audio.h:2059 bool SDL_LoadWAV_IO(SDL_IOStream *src, bool closeio, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
 */
  loadWavIo: lib.symbols.SDL_LoadWAV_IO,

/**
 * Loads a WAV from a file path.
 *
 * This is a convenience function that is effectively the same as:
 *
 * ```c
 * SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);
 * ```
 *
 * @param path the file path of the WAV file to open.
 * @param spec a pointer to an SDL_AudioSpec that will be set to the WAVE
 *             data's format details on successful return.
 * @param audio_buf a pointer filled with the audio data, allocated by the
 *                  function.
 * @param audio_len a pointer filled with the length of the audio data buffer
 *                  in bytes.
 * @returns true on success. `audio_buf` will be filled with a pointer to an
 *          allocated buffer containing the audio data, and `audio_len` is
 *          filled with the length of that audio buffer in bytes.
 *
 *          This function returns false if the .WAV file cannot be opened,
 *          uses an unknown data format, or is corrupt; call SDL_GetError()
 *          for more information.
 *
 *          When the application is done with the data returned in
 *          `audio_buf`, it should call SDL_free() to dispose of it.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_free
 * @sa SDL_LoadWAV_IO
 *
 * @from SDL_audio.h:2095 bool SDL_LoadWAV(const char *path, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
 */
  loadWav: lib.symbols.SDL_LoadWAV,

/**
 * Mix audio data in a specified format.
 *
 * This takes an audio buffer `src` of `len` bytes of `format` data and mixes
 * it into `dst`, performing addition, volume adjustment, and overflow
 * clipping. The buffer pointed to by `dst` must also be `len` bytes of
 * `format` data.
 *
 * This is provided for convenience -- you can mix your own audio data.
 *
 * Do not use this function for mixing together more than two streams of
 * sample data. The output from repeated application of this function may be
 * distorted by clipping, because there is no accumulator with greater range
 * than the input (not to mention this being an inefficient way of doing it).
 *
 * It is a common misconception that this function is required to write audio
 * data to an output stream in an audio callback. While you can do that,
 * SDL_MixAudio() is really only needed when you're mixing a single audio
 * stream with a volume adjustment.
 *
 * @param dst the destination for the mixed audio.
 * @param src the source audio buffer to be mixed.
 * @param format the SDL_AudioFormat structure representing the desired audio
 *               format.
 * @param len the length of the audio buffer in bytes.
 * @param volume ranges from 0.0 - 1.0, and should be set to 1.0 for full
 *               audio volume.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:2131 bool SDL_MixAudio(Uint8 *dst, const Uint8 *src, SDL_AudioFormat format, Uint32 len, float volume);
 */
  mixAudio: lib.symbols.SDL_MixAudio,

/**
 * Convert some audio data of one format to another format.
 *
 * Please note that this function is for convenience, but should not be used
 * to resample audio in blocks, as it will introduce audio artifacts on the
 * boundaries. You should only use this function if you are converting audio
 * data in its entirety in one call. If you want to convert audio in smaller
 * chunks, use an SDL_AudioStream, which is designed for this situation.
 *
 * Internally, this function creates and destroys an SDL_AudioStream on each
 * use, so it's also less efficient than using one directly, if you need to
 * convert multiple times.
 *
 * @param src_spec the format details of the input audio.
 * @param src_data the audio data to be converted.
 * @param src_len the len of src_data.
 * @param dst_spec the format details of the output audio.
 * @param dst_data will be filled with a pointer to converted audio data,
 *                 which should be freed with SDL_free(). On error, it will be
 *                 NULL.
 * @param dst_len will be filled with the len of dst_data.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:2161 bool SDL_ConvertAudioSamples(const SDL_AudioSpec *src_spec, const Uint8 *src_data, int src_len, const SDL_AudioSpec *dst_spec, Uint8 **dst_data, int *dst_len);
 */
  convertAudioSamples: lib.symbols.SDL_ConvertAudioSamples,

/**
 * Get the human readable name of an audio format.
 *
 * @param format the audio format to query.
 * @returns the human readable name of the specified audio format or
 *          "SDL_AUDIO_UNKNOWN" if the format isn't recognized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:2174 const char * SDL_GetAudioFormatName(SDL_AudioFormat format);
 */
  getAudioFormatName: lib.symbols.SDL_GetAudioFormatName,

/**
 * Get the appropriate memset value for silencing an audio format.
 *
 * The value returned by this function can be used as the second argument to
 * memset (or SDL_memset) to set an audio buffer in a specific format to
 * silence.
 *
 * @param format the audio data format to query.
 * @returns a byte value that can be passed to memset.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_audio.h:2190 int SDL_GetSilenceValueForFormat(SDL_AudioFormat format);
 */
  getSilenceValueForFormat: lib.symbols.SDL_GetSilenceValueForFormat,



/*--- SDL_blendmode ---*/

/**
 * @from SDL_blendmode:53 SDL_BLENDMODE_
 */
  BLENDMODE: SDL_blendmode_enums.BLENDMODE,

/**
 * The blend operation used when combining source and destination pixel
 * components.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_blendmode.h:68 SDL_BLENDOPERATION_
 */
  BLENDOPERATION: SDL_blendmode_enums.SDL_BlendOperation,

/**
 * The normalized factor used to multiply pixel components.
 *
 * The blend factors are multiplied with the pixels from a drawing operation
 * (src) and the pixels from the render target (dst) before the blend
 * operation. The comma-separated factors listed above are always applied in
 * the component order red, green, blue, and alpha.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_blendmode.h:87 SDL_BLENDFACTOR_
 */
  BLENDFACTOR: SDL_blendmode_enums.SDL_BlendFactor,



/**
 * Compose a custom blend mode for renderers.
 *
 * The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
 * the SDL_BlendMode returned by this function if the renderer supports it.
 *
 * A blend mode controls how the pixels from a drawing operation (source) get
 * combined with the pixels from the render target (destination). First, the
 * components of the source and destination pixels get multiplied with their
 * blend factors. Then, the blend operation takes the two products and
 * calculates the result that will get stored in the render target.
 *
 * Expressed in pseudocode, it would look like this:
 *
 * ```c
 * dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
 * dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
 * ```
 *
 * Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
 * dst)` can return one of the following:
 *
 * - `src + dst`
 * - `src - dst`
 * - `dst - src`
 * - `min(src, dst)`
 * - `max(src, dst)`
 *
 * The red, green, and blue components are always multiplied with the first,
 * second, and third components of the SDL_BlendFactor, respectively. The
 * fourth component is not used.
 *
 * The alpha component is always multiplied with the fourth component of the
 * SDL_BlendFactor. The other components are not used in the alpha
 * calculation.
 *
 * Support for these blend modes varies for each renderer. To check if a
 * specific SDL_BlendMode is supported, create a renderer and pass it to
 * either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
 * return with an error if the blend mode is not supported.
 *
 * This list describes the support of custom blend modes for each renderer.
 * All renderers support the four blend modes listed in the SDL_BlendMode
 * enumeration.
 *
 * - **direct3d**: Supports all operations with all factors. However, some
 *   factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
 *   `SDL_BLENDOPERATION_MAXIMUM`.
 * - **direct3d11**: Same as Direct3D 9.
 * - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
 *   factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.
 * - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
 *   `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
 *   operations with all factors.
 * - **psp**: No custom blend mode support.
 * - **software**: No custom blend mode support.
 *
 * Some renderers do not provide an alpha component for the default render
 * target. The `SDL_BLENDFACTOR_DST_ALPHA` and
 * `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
 * case.
 *
 * @param srcColorFactor the SDL_BlendFactor applied to the red, green, and
 *                       blue components of the source pixels.
 * @param dstColorFactor the SDL_BlendFactor applied to the red, green, and
 *                       blue components of the destination pixels.
 * @param colorOperation the SDL_BlendOperation used to combine the red,
 *                       green, and blue components of the source and
 *                       destination pixels.
 * @param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
 *                       the source pixels.
 * @param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
 *                       the destination pixels.
 * @param alphaOperation the SDL_BlendOperation used to combine the alpha
 *                       component of the source and destination pixels.
 * @returns an SDL_BlendMode that represents the chosen factors and
 *          operations.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderDrawBlendMode
 * @sa SDL_GetRenderDrawBlendMode
 * @sa SDL_SetTextureBlendMode
 * @sa SDL_GetTextureBlendMode
 *
 * @from SDL_blendmode.h:188 SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor,                                                                 SDL_BlendFactor dstColorFactor,                                                                 SDL_BlendOperation colorOperation,                                                                 SDL_BlendFactor srcAlphaFactor,                                                                 SDL_BlendFactor dstAlphaFactor,                                                                 SDL_BlendOperation alphaOperation);
 */
  composeCustomBlendMode: lib.symbols.SDL_ComposeCustomBlendMode,



/*--- SDL_camera ---*/

/**
 * The position of camera in relation to system device.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_GetCameraPosition
 *
 * @from SDL_camera.h:131 SDL_CAMERA_POSITION_
 */
  CAMERA_POSITION: SDL_camera_enums.SDL_CameraPosition,



/**
 * Use this function to get the number of built-in camera drivers.
 *
 * This function returns a hardcoded number. This never returns a negative
 * value; if there are no drivers compiled into this build of SDL, this
 * function returns zero. The presence of a driver in this list does not mean
 * it will function, it just means SDL is capable of interacting with that
 * interface. For example, a build of SDL might have v4l2 support, but if
 * there's no kernel support available, SDL's v4l2 driver would fail if used.
 *
 * By default, SDL tries all drivers, in its preferred order, until one is
 * found to be usable.
 *
 * @returns the number of built-in camera drivers.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCameraDriver
 *
 * @from SDL_camera.h:160 int SDL_GetNumCameraDrivers(void);
 */
  getNumCameraDrivers: lib.symbols.SDL_GetNumCameraDrivers,

/**
 * Use this function to get the name of a built in camera driver.
 *
 * The list of camera drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "v4l2",
 * "coremedia" or "android". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @param index the index of the camera driver; the value ranges from 0 to
 *              SDL_GetNumCameraDrivers() - 1.
 * @returns the name of the camera driver at the requested index, or NULL if
 *          an invalid index was specified.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumCameraDrivers
 *
 * @from SDL_camera.h:184 const char * SDL_GetCameraDriver(int index);
 */
  getCameraDriver: lib.symbols.SDL_GetCameraDriver,

/**
 * Get the name of the current camera driver.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "v4l2",
 * "coremedia" or "android". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @returns the name of the current camera driver or NULL if no driver has
 *          been initialized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_camera.h:200 const char * SDL_GetCurrentCameraDriver(void);
 */
  getCurrentCameraDriver: lib.symbols.SDL_GetCurrentCameraDriver,

/**
 * Get a list of currently connected camera devices.
 *
 * @param count a pointer filled in with the number of cameras returned, may
 *              be NULL.
 * @returns a 0 terminated array of camera instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenCamera
 *
 * @from SDL_camera.h:217 SDL_CameraID * SDL_GetCameras(int *count);
 */
  getCameras: lib.symbols.SDL_GetCameras,

/**
 * Get the list of native formats/sizes a camera supports.
 *
 * This returns a list of all formats and frame sizes that a specific camera
 * can offer. This is useful if your app can accept a variety of image formats
 * and sizes and so want to find the optimal spec that doesn't require
 * conversion.
 *
 * This function isn't strictly required; if you call SDL_OpenCamera with a
 * NULL spec, SDL will choose a native format for you, and if you instead
 * specify a desired format, it will transparently convert to the requested
 * format on your behalf.
 *
 * If `count` is not NULL, it will be filled with the number of elements in
 * the returned array.
 *
 * Note that it's legal for a camera to supply an empty list. This is what
 * will happen on Emscripten builds, since that platform won't tell _anything_
 * about available cameras until you've opened one, and won't even tell if
 * there _is_ a camera until the user has given you permission to check
 * through a scary warning popup.
 *
 * @param instance_id the camera device instance ID.
 * @param count a pointer filled in with the number of elements in the list,
 *              may be NULL.
 * @returns a NULL terminated array of pointers to SDL_CameraSpec or NULL on
 *          failure; call SDL_GetError() for more information. This is a
 *          single allocation that should be freed with SDL_free() when it is
 *          no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCameras
 * @sa SDL_OpenCamera
 *
 * @from SDL_camera.h:256 SDL_CameraSpec ** SDL_GetCameraSupportedFormats(SDL_CameraID instance_id, int *count);
 */
  getCameraSupportedFormats: lib.symbols.SDL_GetCameraSupportedFormats,

/**
 * Get the human-readable device name for a camera.
 *
 * @param instance_id the camera device instance ID.
 * @returns a human-readable device name or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCameras
 *
 * @from SDL_camera.h:271 const char * SDL_GetCameraName(SDL_CameraID instance_id);
 */
  getCameraName: lib.symbols.SDL_GetCameraName,

/**
 * Get the position of the camera in relation to the system.
 *
 * Most platforms will report UNKNOWN, but mobile devices, like phones, can
 * often make a distinction between cameras on the front of the device (that
 * points towards the user, for taking "selfies") and cameras on the back (for
 * filming in the direction the user is facing).
 *
 * @param instance_id the camera device instance ID.
 * @returns the position of the camera on the system hardware.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCameras
 *
 * @from SDL_camera.h:290 SDL_CameraPosition SDL_GetCameraPosition(SDL_CameraID instance_id);
 */
  getCameraPosition: lib.symbols.SDL_GetCameraPosition,

/**
 * Open a video recording device (a "camera").
 *
 * You can open the device with any reasonable spec, and if the hardware can't
 * directly support it, it will convert data seamlessly to the requested
 * format. This might incur overhead, including scaling of image data.
 *
 * If you would rather accept whatever format the device offers, you can pass
 * a NULL spec here and it will choose one for you (and you can use
 * SDL_Surface's conversion/scaling functions directly if necessary).
 *
 * You can call SDL_GetCameraFormat() to get the actual data format if passing
 * a NULL spec here. You can see the exact specs a device can support without
 * conversion with SDL_GetCameraSupportedFormats().
 *
 * SDL will not attempt to emulate framerate; it will try to set the hardware
 * to the rate closest to the requested speed, but it won't attempt to limit
 * or duplicate frames artificially; call SDL_GetCameraFormat() to see the
 * actual framerate of the opened the device, and check your timestamps if
 * this is crucial to your app!
 *
 * Note that the camera is not usable until the user approves its use! On some
 * platforms, the operating system will prompt the user to permit access to
 * the camera, and they can choose Yes or No at that point. Until they do, the
 * camera will not be usable. The app should either wait for an
 * SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,
 * or poll SDL_GetCameraPermissionState() occasionally until it returns
 * non-zero. On platforms that don't require explicit user approval (and
 * perhaps in places where the user previously permitted access), the approval
 * event might come immediately, but it might come seconds, minutes, or hours
 * later!
 *
 * @param instance_id the camera device instance ID.
 * @param spec the desired format for data the device will provide. Can be
 *             NULL.
 * @returns an SDL_Camera object or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCameras
 * @sa SDL_GetCameraFormat
 *
 * @from SDL_camera.h:337 SDL_Camera * SDL_OpenCamera(SDL_CameraID instance_id, const SDL_CameraSpec *spec);
 */
  openCamera: lib.symbols.SDL_OpenCamera,

/**
 * Query if camera access has been approved by the user.
 *
 * Cameras will not function between when the device is opened by the app and
 * when the user permits access to the hardware. On some platforms, this
 * presents as a popup dialog where the user has to explicitly approve access;
 * on others the approval might be implicit and not alert the user at all.
 *
 * This function can be used to check the status of that approval. It will
 * return 0 if still waiting for user response, 1 if the camera is approved
 * for use, and -1 if the user denied access.
 *
 * Instead of polling with this function, you can wait for a
 * SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event
 * in the standard SDL event loop, which is guaranteed to be sent once when
 * permission to use the camera is decided.
 *
 * If a camera is declined, there's nothing to be done but call
 * SDL_CloseCamera() to dispose of it.
 *
 * @param camera the opened camera device to query.
 * @returns -1 if user denied access to the camera, 1 if user approved access,
 *          0 if no decision has been made yet.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenCamera
 * @sa SDL_CloseCamera
 *
 * @from SDL_camera.h:370 int SDL_GetCameraPermissionState(SDL_Camera *camera);
 */
  getCameraPermissionState: lib.symbols.SDL_GetCameraPermissionState,

/**
 * Get the instance ID of an opened camera.
 *
 * @param camera an SDL_Camera to query.
 * @returns the instance ID of the specified camera on success or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenCamera
 *
 * @from SDL_camera.h:385 SDL_CameraID SDL_GetCameraID(SDL_Camera *camera);
 */
  getCameraId: lib.symbols.SDL_GetCameraID,

/**
 * Get the properties associated with an opened camera.
 *
 * @param camera the SDL_Camera obtained from SDL_OpenCamera().
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_camera.h:398 SDL_PropertiesID SDL_GetCameraProperties(SDL_Camera *camera);
 */
  getCameraProperties: lib.symbols.SDL_GetCameraProperties,

/**
 * Get the spec that a camera is using when generating images.
 *
 * Note that this might not be the native format of the hardware, as SDL might
 * be converting to this format behind the scenes.
 *
 * If the system is waiting for the user to approve access to the camera, as
 * some platforms require, this will return false, but this isn't necessarily
 * a fatal error; you should either wait for an
 * SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,
 * or poll SDL_GetCameraPermissionState() occasionally until it returns
 * non-zero.
 *
 * @param camera opened camera device.
 * @param spec the SDL_CameraSpec to be initialized by this function.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenCamera
 *
 * @from SDL_camera.h:424 bool SDL_GetCameraFormat(SDL_Camera *camera, SDL_CameraSpec *spec);
 */
  getCameraFormat: lib.symbols.SDL_GetCameraFormat,

/**
 * Acquire a frame.
 *
 * The frame is a memory pointer to the image data, whose size and format are
 * given by the spec requested when opening the device.
 *
 * This is a non blocking API. If there is a frame available, a non-NULL
 * surface is returned, and timestampNS will be filled with a non-zero value.
 *
 * Note that an error case can also return NULL, but a NULL by itself is
 * normal and just signifies that a new frame is not yet available. Note that
 * even if a camera device fails outright (a USB camera is unplugged while in
 * use, etc), SDL will send an event separately to notify the app, but
 * continue to provide blank frames at ongoing intervals until
 * SDL_CloseCamera() is called, so real failure here is almost always an out
 * of memory condition.
 *
 * After use, the frame should be released with SDL_ReleaseCameraFrame(). If
 * you don't do this, the system may stop providing more video!
 *
 * Do not call SDL_DestroySurface() on the returned surface! It must be given
 * back to the camera subsystem with SDL_ReleaseCameraFrame!
 *
 * If the system is waiting for the user to approve access to the camera, as
 * some platforms require, this will return NULL (no frames available); you
 * should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or
 * SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll
 * SDL_GetCameraPermissionState() occasionally until it returns non-zero.
 *
 * @param camera opened camera device.
 * @param timestampNS a pointer filled in with the frame's timestamp, or 0 on
 *                    error. Can be NULL.
 * @returns a new frame of video on success, NULL if none is currently
 *          available.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ReleaseCameraFrame
 *
 * @from SDL_camera.h:467 SDL_Surface * SDL_AcquireCameraFrame(SDL_Camera *camera, Uint64 *timestampNS);
 */
  acquireCameraFrame: lib.symbols.SDL_AcquireCameraFrame,

/**
 * Release a frame of video acquired from a camera.
 *
 * Let the back-end re-use the internal buffer for camera.
 *
 * This function _must_ be called only on surface objects returned by
 * SDL_AcquireCameraFrame(). This function should be called as quickly as
 * possible after acquisition, as SDL keeps a small FIFO queue of surfaces for
 * video frames; if surfaces aren't released in a timely manner, SDL may drop
 * upcoming video frames from the camera.
 *
 * If the app needs to keep the surface for a significant time, they should
 * make a copy of it and release the original.
 *
 * The app should not use the surface again after calling this function;
 * assume the surface is freed and the pointer is invalid.
 *
 * @param camera opened camera device.
 * @param frame the video frame surface to release.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AcquireCameraFrame
 *
 * @from SDL_camera.h:495 void SDL_ReleaseCameraFrame(SDL_Camera *camera, SDL_Surface *frame);
 */
  releaseCameraFrame: lib.symbols.SDL_ReleaseCameraFrame,

/**
 * Use this function to shut down camera processing and close the camera
 * device.
 *
 * @param camera opened camera device.
 *
 * @threadsafety It is safe to call this function from any thread, but no
 *               thread may reference `device` once this function is called.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenCamera
 *
 * @from SDL_camera.h:510 void SDL_CloseCamera(SDL_Camera *camera);
 */
  closeCamera: lib.symbols.SDL_CloseCamera,



/*--- SDL_clipboard ---*/

/**
 * Put UTF-8 text into the clipboard.
 *
 * @param text the text to store in the clipboard.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetClipboardText
 * @sa SDL_HasClipboardText
 *
 * @from SDL_clipboard.h:103 bool SDL_SetClipboardText(const char *text);
 */
  setClipboardText: lib.symbols.SDL_SetClipboardText,

/**
 * Get UTF-8 text from the clipboard.
 *
 * This functions returns an empty string if there was not enough memory left
 * for a copy of the clipboard's content.
 *
 * @returns the clipboard text on success or an empty string on failure; call
 *          SDL_GetError() for more information. This should be freed with
 *          SDL_free() when it is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasClipboardText
 * @sa SDL_SetClipboardText
 *
 * @from SDL_clipboard.h:122 char * SDL_GetClipboardText(void);
 */
  getClipboardText: lib.symbols.SDL_GetClipboardText,

/**
 * Query whether the clipboard exists and contains a non-empty text string.
 *
 * @returns true if the clipboard has text, or false if it does not.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetClipboardText
 * @sa SDL_SetClipboardText
 *
 * @from SDL_clipboard.h:136 bool SDL_HasClipboardText(void);
 */
  hasClipboardText: lib.symbols.SDL_HasClipboardText,

/**
 * Put UTF-8 text into the primary selection.
 *
 * @param text the text to store in the primary selection.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPrimarySelectionText
 * @sa SDL_HasPrimarySelectionText
 *
 * @from SDL_clipboard.h:152 bool SDL_SetPrimarySelectionText(const char *text);
 */
  setPrimarySelectionText: lib.symbols.SDL_SetPrimarySelectionText,

/**
 * Get UTF-8 text from the primary selection.
 *
 * This functions returns an empty string if there was not enough memory left
 * for a copy of the primary selection's content.
 *
 * @returns the primary selection text on success or an empty string on
 *          failure; call SDL_GetError() for more information. This should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasPrimarySelectionText
 * @sa SDL_SetPrimarySelectionText
 *
 * @from SDL_clipboard.h:171 char * SDL_GetPrimarySelectionText(void);
 */
  getPrimarySelectionText: lib.symbols.SDL_GetPrimarySelectionText,

/**
 * Query whether the primary selection exists and contains a non-empty text
 * string.
 *
 * @returns true if the primary selection has text, or false if it does not.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPrimarySelectionText
 * @sa SDL_SetPrimarySelectionText
 *
 * @from SDL_clipboard.h:186 bool SDL_HasPrimarySelectionText(void);
 */
  hasPrimarySelectionText: lib.symbols.SDL_HasPrimarySelectionText,

/**
 * Offer clipboard data to the OS.
 *
 * Tell the operating system that the application is offering clipboard data
 * for each of the provided mime-types. Once another application requests the
 * data the callback function will be called, allowing it to generate and
 * respond with the data for the requested mime-type.
 *
 * The size of text data does not include any terminator, and the text does
 * not need to be null terminated (e.g. you can directly copy a portion of a
 * document).
 *
 * @param callback a function pointer to the function that provides the
 *                 clipboard data.
 * @param cleanup a function pointer to the function that cleans up the
 *                clipboard data.
 * @param userdata an opaque pointer that will be forwarded to the callbacks.
 * @param mime_types a list of mime-types that are being offered.
 * @param num_mime_types the number of mime-types in the mime_types list.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ClearClipboardData
 * @sa SDL_GetClipboardData
 * @sa SDL_HasClipboardData
 *
 * @from SDL_clipboard.h:254 bool SDL_SetClipboardData(SDL_ClipboardDataCallback callback, SDL_ClipboardCleanupCallback cleanup, void *userdata, const char **mime_types, size_t num_mime_types);
 */
  setClipboardData: lib.symbols.SDL_SetClipboardData,

/**
 * Clear the clipboard data.
 *
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetClipboardData
 *
 * @from SDL_clipboard.h:268 bool SDL_ClearClipboardData(void);
 */
  clearClipboardData: lib.symbols.SDL_ClearClipboardData,

/**
 * Get the data from clipboard for a given mime type.
 *
 * The size of text data does not include the terminator, but the text is
 * guaranteed to be null terminated.
 *
 * @param mime_type the mime type to read from the clipboard.
 * @param size a pointer filled in with the length of the returned data.
 * @returns the retrieved data buffer or NULL on failure; call SDL_GetError()
 *          for more information. This should be freed with SDL_free() when it
 *          is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasClipboardData
 * @sa SDL_SetClipboardData
 *
 * @from SDL_clipboard.h:289 void * SDL_GetClipboardData(const char *mime_type, size_t *size);
 */
  getClipboardData: lib.symbols.SDL_GetClipboardData,

/**
 * Query whether there is data in the clipboard for the provided mime type.
 *
 * @param mime_type the mime type to check for data for.
 * @returns true if there exists data in clipboard for the provided mime type,
 *          false if it does not.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetClipboardData
 * @sa SDL_GetClipboardData
 *
 * @from SDL_clipboard.h:305 bool SDL_HasClipboardData(const char *mime_type);
 */
  hasClipboardData: lib.symbols.SDL_HasClipboardData,

/**
 * Retrieve the list of mime types available in the clipboard.
 *
 * @param num_mime_types a pointer filled with the number of mime types, may
 *                       be NULL.
 * @returns a null terminated array of strings with mime types, or NULL on
 *          failure; call SDL_GetError() for more information. This should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetClipboardData
 *
 * @from SDL_clipboard.h:322 char ** SDL_GetClipboardMimeTypes(size_t *num_mime_types);
 */
  getClipboardMimeTypes: lib.symbols.SDL_GetClipboardMimeTypes,



/*--- SDL_cpuinfo ---*/

/**
 * Get the number of logical CPU cores available.
 *
 * @returns the total number of logical CPU cores. On CPUs that include
 *          technologies such as hyperthreading, the number of logical cores
 *          may be more than the number of physical cores.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_cpuinfo.h:72 int SDL_GetNumLogicalCPUCores(void);
 */
  getNumLogicalCpuCores: lib.symbols.SDL_GetNumLogicalCPUCores,

/**
 * Determine the L1 cache line size of the CPU.
 *
 * This is useful for determining multi-threaded structure padding or SIMD
 * prefetch sizes.
 *
 * @returns the L1 cache line size of the CPU, in bytes.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_cpuinfo.h:86 int SDL_GetCPUCacheLineSize(void);
 */
  getCpuCacheLineSize: lib.symbols.SDL_GetCPUCacheLineSize,

/**
 * Determine whether the CPU has AltiVec features.
 *
 * This always returns false on CPUs that aren't using PowerPC instruction
 * sets.
 *
 * @returns true if the CPU has AltiVec features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_cpuinfo.h:100 bool SDL_HasAltiVec(void);
 */
  hasAltiVec: lib.symbols.SDL_HasAltiVec,

/**
 * Determine whether the CPU has MMX features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has MMX features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_cpuinfo.h:113 bool SDL_HasMMX(void);
 */
  hasMmx: lib.symbols.SDL_HasMMX,

/**
 * Determine whether the CPU has SSE features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has SSE features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasSSE2
 * @sa SDL_HasSSE3
 * @sa SDL_HasSSE41
 * @sa SDL_HasSSE42
 *
 * @from SDL_cpuinfo.h:131 bool SDL_HasSSE(void);
 */
  hasSse: lib.symbols.SDL_HasSSE,

/**
 * Determine whether the CPU has SSE2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has SSE2 features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasSSE
 * @sa SDL_HasSSE3
 * @sa SDL_HasSSE41
 * @sa SDL_HasSSE42
 *
 * @from SDL_cpuinfo.h:149 bool SDL_HasSSE2(void);
 */
  hasSse2: lib.symbols.SDL_HasSSE2,

/**
 * Determine whether the CPU has SSE3 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has SSE3 features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasSSE
 * @sa SDL_HasSSE2
 * @sa SDL_HasSSE41
 * @sa SDL_HasSSE42
 *
 * @from SDL_cpuinfo.h:167 bool SDL_HasSSE3(void);
 */
  hasSse3: lib.symbols.SDL_HasSSE3,

/**
 * Determine whether the CPU has SSE4.1 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has SSE4.1 features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasSSE
 * @sa SDL_HasSSE2
 * @sa SDL_HasSSE3
 * @sa SDL_HasSSE42
 *
 * @from SDL_cpuinfo.h:185 bool SDL_HasSSE41(void);
 */
  hasSse41: lib.symbols.SDL_HasSSE41,

/**
 * Determine whether the CPU has SSE4.2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has SSE4.2 features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasSSE
 * @sa SDL_HasSSE2
 * @sa SDL_HasSSE3
 * @sa SDL_HasSSE41
 *
 * @from SDL_cpuinfo.h:203 bool SDL_HasSSE42(void);
 */
  hasSse42: lib.symbols.SDL_HasSSE42,

/**
 * Determine whether the CPU has AVX features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has AVX features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasAVX2
 * @sa SDL_HasAVX512F
 *
 * @from SDL_cpuinfo.h:219 bool SDL_HasAVX(void);
 */
  hasAvx: lib.symbols.SDL_HasAVX,

/**
 * Determine whether the CPU has AVX2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has AVX2 features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasAVX
 * @sa SDL_HasAVX512F
 *
 * @from SDL_cpuinfo.h:235 bool SDL_HasAVX2(void);
 */
  hasAvx2: lib.symbols.SDL_HasAVX2,

/**
 * Determine whether the CPU has AVX-512F (foundation) features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * @returns true if the CPU has AVX-512F features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasAVX
 * @sa SDL_HasAVX2
 *
 * @from SDL_cpuinfo.h:251 bool SDL_HasAVX512F(void);
 */
  hasAvx512F: lib.symbols.SDL_HasAVX512F,

/**
 * Determine whether the CPU has ARM SIMD (ARMv6) features.
 *
 * This is different from ARM NEON, which is a different instruction set.
 *
 * This always returns false on CPUs that aren't using ARM instruction sets.
 *
 * @returns true if the CPU has ARM SIMD features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasNEON
 *
 * @from SDL_cpuinfo.h:268 bool SDL_HasARMSIMD(void);
 */
  hasArmsimd: lib.symbols.SDL_HasARMSIMD,

/**
 * Determine whether the CPU has NEON (ARM SIMD) features.
 *
 * This always returns false on CPUs that aren't using ARM instruction sets.
 *
 * @returns true if the CPU has ARM NEON features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_cpuinfo.h:281 bool SDL_HasNEON(void);
 */
  hasNeon: lib.symbols.SDL_HasNEON,

/**
 * Determine whether the CPU has LSX (LOONGARCH SIMD) features.
 *
 * This always returns false on CPUs that aren't using LOONGARCH instruction
 * sets.
 *
 * @returns true if the CPU has LOONGARCH LSX features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_cpuinfo.h:295 bool SDL_HasLSX(void);
 */
  hasLsx: lib.symbols.SDL_HasLSX,

/**
 * Determine whether the CPU has LASX (LOONGARCH SIMD) features.
 *
 * This always returns false on CPUs that aren't using LOONGARCH instruction
 * sets.
 *
 * @returns true if the CPU has LOONGARCH LASX features or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_cpuinfo.h:309 bool SDL_HasLASX(void);
 */
  hasLasx: lib.symbols.SDL_HasLASX,

/**
 * Get the amount of RAM configured in the system.
 *
 * @returns the amount of RAM configured in the system in MiB.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_cpuinfo.h:320 int SDL_GetSystemRAM(void);
 */
  getSystemRam: lib.symbols.SDL_GetSystemRAM,

/**
 * Report the alignment this system needs for SIMD allocations.
 *
 * This will return the minimum number of bytes to which a pointer must be
 * aligned to be compatible with SIMD instructions on the current machine. For
 * example, if the machine supports SSE only, it will return 16, but if it
 * supports AVX-512F, it'll return 64 (etc). This only reports values for
 * instruction sets SDL knows about, so if your SDL build doesn't have
 * SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and
 * not 64 for the AVX-512 instructions that exist but SDL doesn't know about.
 * Plan accordingly.
 *
 * @returns the alignment in bytes needed for available, known SIMD
 *          instructions.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_aligned_alloc
 * @sa SDL_aligned_free
 *
 * @from SDL_cpuinfo.h:344 size_t SDL_GetSIMDAlignment(void);
 */
  getSimdAlignment: lib.symbols.SDL_GetSIMDAlignment,



/*--- SDL_dialog ---*/

/**
 * @from SDL_dialog:325 SDL_PROP_FILE_DIALOG_
 */
  PROP_FILE_DIALOG: SDL_dialog_enums.PROP_FILE_DIALOG,

/**
 * Various types of file dialogs.
 *
 * This is used by SDL_ShowFileDialogWithProperties() to decide what kind of
 * dialog to present to the user.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_ShowFileDialogWithProperties
 *
 * @from SDL_dialog.h:269 SDL_FILEDIALOG_
 */
  FILEDIALOG: SDL_dialog_enums.SDL_FileDialogType,



/**
 * Displays a dialog that lets the user select a file on their filesystem.
 *
 * This is an asynchronous function; it will return immediately, and the
 * result will be passed to the callback.
 *
 * The callback will be invoked with a null-terminated list of files the user
 * chose. The list will be empty if the user canceled the dialog, and it will
 * be NULL if an error occurred.
 *
 * Note that the callback may be called from a different thread than the one
 * the function was invoked on.
 *
 * Depending on the platform, the user may be allowed to input paths that
 * don't yet exist.
 *
 * On Linux, dialogs may require XDG Portals, which requires DBus, which
 * requires an event-handling loop. Apps that do not use SDL to handle events
 * should add a call to SDL_PumpEvents in their main loop.
 *
 * @param callback a function pointer to be invoked when the user selects a
 *                 file and accepts, or cancels the dialog, or an error
 *                 occurs.
 * @param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 * @param window the window that the dialog should be modal for, may be NULL.
 *               Not all platforms support this option.
 * @param filters a list of filters, may be NULL. Not all platforms support
 *                this option, and platforms that do support it may allow the
 *                user to ignore the filters. If non-NULL, it must remain
 *                valid at least until the callback is invoked.
 * @param nfilters the number of filters. Ignored if filters is NULL.
 * @param default_location the default folder or file to start the dialog at,
 *                         may be NULL. Not all platforms support this option.
 * @param allow_many if non-zero, the user will be allowed to select multiple
 *                   entries. Not all platforms support this option.
 *
 * @threadsafety This function should be called only from the main thread. The
 *               callback may be invoked from the same thread or from a
 *               different one, depending on the OS's constraints.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DialogFileCallback
 * @sa SDL_DialogFileFilter
 * @sa SDL_ShowSaveFileDialog
 * @sa SDL_ShowOpenFolderDialog
 * @sa SDL_ShowFileDialogWithProperties
 *
 * @from SDL_dialog.h:163 void SDL_ShowOpenFileDialog(SDL_DialogFileCallback callback, void *userdata, SDL_Window *window, const SDL_DialogFileFilter *filters, int nfilters, const char *default_location, bool allow_many);
 */
  showOpenFileDialog: lib.symbols.SDL_ShowOpenFileDialog,

/**
 * Displays a dialog that lets the user choose a new or existing file on their
 * filesystem.
 *
 * This is an asynchronous function; it will return immediately, and the
 * result will be passed to the callback.
 *
 * The callback will be invoked with a null-terminated list of files the user
 * chose. The list will be empty if the user canceled the dialog, and it will
 * be NULL if an error occurred.
 *
 * Note that the callback may be called from a different thread than the one
 * the function was invoked on.
 *
 * The chosen file may or may not already exist.
 *
 * On Linux, dialogs may require XDG Portals, which requires DBus, which
 * requires an event-handling loop. Apps that do not use SDL to handle events
 * should add a call to SDL_PumpEvents in their main loop.
 *
 * @param callback a function pointer to be invoked when the user selects a
 *                 file and accepts, or cancels the dialog, or an error
 *                 occurs.
 * @param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 * @param window the window that the dialog should be modal for, may be NULL.
 *               Not all platforms support this option.
 * @param filters a list of filters, may be NULL. Not all platforms support
 *                this option, and platforms that do support it may allow the
 *                user to ignore the filters. If non-NULL, it must remain
 *                valid at least until the callback is invoked.
 * @param nfilters the number of filters. Ignored if filters is NULL.
 * @param default_location the default folder or file to start the dialog at,
 *                         may be NULL. Not all platforms support this option.
 *
 * @threadsafety This function should be called only from the main thread. The
 *               callback may be invoked from the same thread or from a
 *               different one, depending on the OS's constraints.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DialogFileCallback
 * @sa SDL_DialogFileFilter
 * @sa SDL_ShowOpenFileDialog
 * @sa SDL_ShowOpenFolderDialog
 * @sa SDL_ShowFileDialogWithProperties
 *
 * @from SDL_dialog.h:212 void SDL_ShowSaveFileDialog(SDL_DialogFileCallback callback, void *userdata, SDL_Window *window, const SDL_DialogFileFilter *filters, int nfilters, const char *default_location);
 */
  showSaveFileDialog: lib.symbols.SDL_ShowSaveFileDialog,

/**
 * Displays a dialog that lets the user select a folder on their filesystem.
 *
 * This is an asynchronous function; it will return immediately, and the
 * result will be passed to the callback.
 *
 * The callback will be invoked with a null-terminated list of files the user
 * chose. The list will be empty if the user canceled the dialog, and it will
 * be NULL if an error occurred.
 *
 * Note that the callback may be called from a different thread than the one
 * the function was invoked on.
 *
 * Depending on the platform, the user may be allowed to input paths that
 * don't yet exist.
 *
 * On Linux, dialogs may require XDG Portals, which requires DBus, which
 * requires an event-handling loop. Apps that do not use SDL to handle events
 * should add a call to SDL_PumpEvents in their main loop.
 *
 * @param callback a function pointer to be invoked when the user selects a
 *                 file and accepts, or cancels the dialog, or an error
 *                 occurs.
 * @param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 * @param window the window that the dialog should be modal for, may be NULL.
 *               Not all platforms support this option.
 * @param default_location the default folder or file to start the dialog at,
 *                         may be NULL. Not all platforms support this option.
 * @param allow_many if non-zero, the user will be allowed to select multiple
 *                   entries. Not all platforms support this option.
 *
 * @threadsafety This function should be called only from the main thread. The
 *               callback may be invoked from the same thread or from a
 *               different one, depending on the OS's constraints.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DialogFileCallback
 * @sa SDL_ShowOpenFileDialog
 * @sa SDL_ShowSaveFileDialog
 * @sa SDL_ShowFileDialogWithProperties
 *
 * @from SDL_dialog.h:257 void SDL_ShowOpenFolderDialog(SDL_DialogFileCallback callback, void *userdata, SDL_Window *window, const char *default_location, bool allow_many);
 */
  showOpenFolderDialog: lib.symbols.SDL_ShowOpenFolderDialog,

/**
 * Create and launch a file dialog with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of
 *   SDL_DialogFileFilter structs, which will be used as filters for
 *   file-based selections. Ignored if the dialog is an "Open Folder" dialog.
 *   If non-NULL, the array of filters must remain valid at least until the
 *   callback is invoked.
 * - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the
 *   array of filters, if it exists.
 * - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should
 *   be modal for.
 * - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to
 *   start the dialog at.
 * - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select
 *   more than one entry.
 * - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.
 * - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button
 *   should have.
 * - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button
 *   should have.
 *
 * Note that each platform may or may not support any of the properties.
 *
 * @param type the type of file dialog.
 * @param callback a function pointer to be invoked when the user selects a
 *                 file and accepts, or cancels the dialog, or an error
 *                 occurs.
 * @param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 * @param props the properties to use.
 *
 * @threadsafety This function should be called only from the main thread. The
 *               callback may be invoked from the same thread or from a
 *               different one, depending on the OS's constraints.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_FileDialogType
 * @sa SDL_DialogFileCallback
 * @sa SDL_DialogFileFilter
 * @sa SDL_ShowOpenFileDialog
 * @sa SDL_ShowSaveFileDialog
 * @sa SDL_ShowOpenFolderDialog
 *
 * @from SDL_dialog.h:323 void SDL_ShowFileDialogWithProperties(SDL_FileDialogType type, SDL_DialogFileCallback callback, void *userdata, SDL_PropertiesID props);
 */
  showFileDialogWithProperties: lib.symbols.SDL_ShowFileDialogWithProperties,



/*--- SDL_error ---*/

/**
 * Set an error indicating that memory allocation failed.
 *
 * This function does not do any memory allocation.
 *
 * @returns false.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_error.h:120 bool SDL_OutOfMemory(void);
 */
  outOfMemory: lib.symbols.SDL_OutOfMemory,

/**
 * Retrieve a message about the last error that occurred on the current
 * thread.
 *
 * It is possible for multiple errors to occur before calling SDL_GetError().
 * Only the last error is returned.
 *
 * The message is only applicable when an SDL function has signaled an error.
 * You must check the return values of SDL function calls to determine when to
 * appropriately call SDL_GetError(). You should *not* use the results of
 * SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
 * an error string even when reporting success.
 *
 * SDL will *not* clear the error string for successful API calls. You *must*
 * check return values for failure cases before you can assume the error
 * string applies.
 *
 * Error strings are set per-thread, so an error set in a different thread
 * will not interfere with the current thread's operation.
 *
 * The returned value is a thread-local string which will remain valid until
 * the current thread's error string is changed. The caller should make a copy
 * if the value is needed after the next SDL API call.
 *
 * @returns a message with information about the specific error that occurred,
 *          or an empty string if there hasn't been an error message set since
 *          the last call to SDL_ClearError().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ClearError
 * @sa SDL_SetError
 *
 * @from SDL_error.h:157 const char * SDL_GetError(void);
 */
  getError: lib.symbols.SDL_GetError,

/**
 * Clear any previous error message for this thread.
 *
 * @returns true.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetError
 * @sa SDL_SetError
 *
 * @from SDL_error.h:171 bool SDL_ClearError(void);
 */
  clearError: lib.symbols.SDL_ClearError,



/*--- SDL_events ---*/

/**
 * The types of events that can be delivered.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_events.h:83 SDL_EVENT_
 */
  EVENT: SDL_events_enums.SDL_EventType,

/**
 * The type of action to request from SDL_PeepEvents().
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_events.h:1077 SDL_
 */
  SDL_EventAction: SDL_events_enums.SDL_EventAction,



/**
 * Pump the event loop, gathering events from the input devices.
 *
 * This function updates the event queue and internal input device state.
 *
 * SDL_PumpEvents() gathers all the pending input information from devices and
 * places it in the event queue. Without calls to SDL_PumpEvents() no events
 * would ever be placed on the queue. Often the need for calls to
 * SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and
 * SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not
 * polling or waiting for events (e.g. you are filtering them), then you must
 * call SDL_PumpEvents() to force an event queue update.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PollEvent
 * @sa SDL_WaitEvent
 *
 * @from SDL_events.h:1068 void SDL_PumpEvents(void);
 */
  pumpEvents: lib.symbols.SDL_PumpEvents,

/**
 * Check the event queue for messages and optionally return them.
 *
 * `action` may be any of the following:
 *
 * - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the
 *   event queue.
 * - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,
 *   within the specified minimum and maximum type, will be returned to the
 *   caller and will _not_ be removed from the queue. If you pass NULL for
 *   `events`, then `numevents` is ignored and the total number of matching
 *   events will be returned.
 * - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,
 *   within the specified minimum and maximum type, will be returned to the
 *   caller and will be removed from the queue.
 *
 * You may have to call SDL_PumpEvents() before calling this function.
 * Otherwise, the events may not be ready to be filtered when you call
 * SDL_PeepEvents().
 *
 * @param events destination buffer for the retrieved events, may be NULL to
 *               leave the events in the queue and return the number of events
 *               that would have been stored.
 * @param numevents if action is SDL_ADDEVENT, the number of events to add
 *                  back to the event queue; if action is SDL_PEEKEVENT or
 *                  SDL_GETEVENT, the maximum number of events to retrieve.
 * @param action action to take; see [Remarks](#remarks) for details.
 * @param minType minimum value of the event type to be considered;
 *                SDL_EVENT_FIRST is a safe choice.
 * @param maxType maximum value of the event type to be considered;
 *                SDL_EVENT_LAST is a safe choice.
 * @returns the number of events actually stored or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PollEvent
 * @sa SDL_PumpEvents
 * @sa SDL_PushEvent
 *
 * @from SDL_events.h:1126 int SDL_PeepEvents(SDL_Event *events, int numevents, SDL_EventAction action, Uint32 minType, Uint32 maxType);
 */
  peepEvents: lib.symbols.SDL_PeepEvents,

/**
 * Check for the existence of a certain event type in the event queue.
 *
 * If you need to check for a range of event types, use SDL_HasEvents()
 * instead.
 *
 * @param type the type of event to be queried; see SDL_EventType for details.
 * @returns true if events matching `type` are present, or false if events
 *          matching `type` are not present.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasEvents
 *
 * @from SDL_events.h:1145 bool SDL_HasEvent(Uint32 type);
 */
  hasEvent: lib.symbols.SDL_HasEvent,

/**
 * Check for the existence of certain event types in the event queue.
 *
 * If you need to check for a single event type, use SDL_HasEvent() instead.
 *
 * @param minType the low end of event type to be queried, inclusive; see
 *                SDL_EventType for details.
 * @param maxType the high end of event type to be queried, inclusive; see
 *                SDL_EventType for details.
 * @returns true if events with type >= `minType` and <= `maxType` are
 *          present, or false if not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasEvents
 *
 * @from SDL_events.h:1166 bool SDL_HasEvents(Uint32 minType, Uint32 maxType);
 */
  hasEvents: lib.symbols.SDL_HasEvents,

/**
 * Clear events of a specific type from the event queue.
 *
 * This will unconditionally remove any events from the queue that match
 * `type`. If you need to remove a range of event types, use SDL_FlushEvents()
 * instead.
 *
 * It's also normal to just ignore events you don't care about in your event
 * loop without calling this function.
 *
 * This function only affects currently queued events. If you want to make
 * sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 * on the main thread immediately before the flush call.
 *
 * If you have user events with custom data that needs to be freed, you should
 * use SDL_PeepEvents() to remove and clean up those events before calling
 * this function.
 *
 * @param type the type of event to be cleared; see SDL_EventType for details.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_FlushEvents
 *
 * @from SDL_events.h:1194 void SDL_FlushEvent(Uint32 type);
 */
  flushEvent: lib.symbols.SDL_FlushEvent,

/**
 * Clear events of a range of types from the event queue.
 *
 * This will unconditionally remove any events from the queue that are in the
 * range of `minType` to `maxType`, inclusive. If you need to remove a single
 * event type, use SDL_FlushEvent() instead.
 *
 * It's also normal to just ignore events you don't care about in your event
 * loop without calling this function.
 *
 * This function only affects currently queued events. If you want to make
 * sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 * on the main thread immediately before the flush call.
 *
 * @param minType the low end of event type to be cleared, inclusive; see
 *                SDL_EventType for details.
 * @param maxType the high end of event type to be cleared, inclusive; see
 *                SDL_EventType for details.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_FlushEvent
 *
 * @from SDL_events.h:1221 void SDL_FlushEvents(Uint32 minType, Uint32 maxType);
 */
  flushEvents: lib.symbols.SDL_FlushEvents,

/**
 * Poll for currently pending events.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`. The 1 returned refers to
 * this event, immediately stored in the SDL Event structure -- not an event
 * to follow.
 *
 * If `event` is NULL, it simply returns 1 if there is an event in the queue,
 * but will not remove it from the queue.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that set the video mode.
 *
 * SDL_PollEvent() is the favored way of receiving system events since it can
 * be done from the main loop and does not suspend the main loop while waiting
 * on an event to be posted.
 *
 * The common practice is to fully process the event queue once every frame,
 * usually as a first step before updating the game's state:
 *
 * ```c
 * while (game_is_still_running) {
 *     SDL_Event event;
 *     while (SDL_PollEvent(&event)) {  // poll until all events are handled!
 *         // decide what to do with this event.
 *     }
 *
 *     // update game state, draw the current frame
 * }
 * ```
 *
 * @param event the SDL_Event structure to be filled with the next event from
 *              the queue, or NULL.
 * @returns true if this got an event or false if there are none available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PushEvent
 * @sa SDL_WaitEvent
 * @sa SDL_WaitEventTimeout
 *
 * @from SDL_events.h:1267 bool SDL_PollEvent(SDL_Event *event);
 */
  pollEvent: lib.symbols.SDL_PollEvent,

/**
 * Wait indefinitely for the next available event.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * @param event the SDL_Event structure to be filled in with the next event
 *              from the queue, or NULL.
 * @returns true on success or false if there was an error while waiting for
 *          events; call SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PollEvent
 * @sa SDL_PushEvent
 * @sa SDL_WaitEventTimeout
 *
 * @from SDL_events.h:1291 bool SDL_WaitEvent(SDL_Event *event);
 */
  waitEvent: lib.symbols.SDL_WaitEvent,

/**
 * Wait until the specified timeout (in milliseconds) for the next available
 * event.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * The timeout is not guaranteed, the actual wait time could be longer due to
 * system scheduling.
 *
 * @param event the SDL_Event structure to be filled in with the next event
 *              from the queue, or NULL.
 * @param timeoutMS the maximum number of milliseconds to wait for the next
 *                  available event.
 * @returns true if this got an event or false if the timeout elapsed without
 *          any events available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PollEvent
 * @sa SDL_PushEvent
 * @sa SDL_WaitEvent
 *
 * @from SDL_events.h:1321 bool SDL_WaitEventTimeout(SDL_Event *event, Sint32 timeoutMS);
 */
  waitEventTimeout: lib.symbols.SDL_WaitEventTimeout,

/**
 * Add an event to the event queue.
 *
 * The event queue can actually be used as a two way communication channel.
 * Not only can events be read from the queue, but the user can also push
 * their own events onto it. `event` is a pointer to the event structure you
 * wish to push onto the queue. The event is copied into the queue, and the
 * caller may dispose of the memory pointed to after SDL_PushEvent() returns.
 *
 * Note: Pushing device input events onto the queue doesn't modify the state
 * of the device within SDL.
 *
 * Note: Events pushed onto the queue with SDL_PushEvent() get passed through
 * the event filter but events added with SDL_PeepEvents() do not.
 *
 * For pushing application-specific events, please use SDL_RegisterEvents() to
 * get an event type that does not conflict with other code that also wants
 * its own custom event types.
 *
 * @param event the SDL_Event to be added to the queue.
 * @returns true on success, false if the event was filtered or on failure;
 *          call SDL_GetError() for more information. A common reason for
 *          error is the event queue being full.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PeepEvents
 * @sa SDL_PollEvent
 * @sa SDL_RegisterEvents
 *
 * @from SDL_events.h:1355 bool SDL_PushEvent(SDL_Event *event);
 */
  pushEvent: lib.symbols.SDL_PushEvent,

/**
 * Set up a filter to process all events before they are added to the internal
 * event queue.
 *
 * If you just want to see events without modifying them or preventing them
 * from being queued, you should use SDL_AddEventWatch() instead.
 *
 * If the filter function returns true when called, then the event will be
 * added to the internal queue. If it returns false, then the event will be
 * dropped from the queue, but the internal state will still be updated. This
 * allows selective filtering of dynamically arriving events.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * On platforms that support it, if the quit event is generated by an
 * interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
 * application at the next event poll.
 *
 * Note: Disabled events never make it to the event filter function; see
 * SDL_SetEventEnabled().
 *
 * Note: Events pushed onto the queue with SDL_PushEvent() get passed through
 * the event filter, but events pushed onto the queue with SDL_PeepEvents() do
 * not.
 *
 * @param filter an SDL_EventFilter function to call when an event happens.
 * @param userdata a pointer that is passed to `filter`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddEventWatch
 * @sa SDL_SetEventEnabled
 * @sa SDL_GetEventFilter
 * @sa SDL_PeepEvents
 * @sa SDL_PushEvent
 *
 * @from SDL_events.h:1417 void SDL_SetEventFilter(SDL_EventFilter filter, void *userdata);
 */
  setEventFilter: lib.symbols.SDL_SetEventFilter,

/**
 * Query the current event filter.
 *
 * This function can be used to "chain" filters, by saving the existing filter
 * before replacing it with a function that will call that saved filter.
 *
 * @param filter the current callback function will be stored here.
 * @param userdata the pointer that is passed to the current event filter will
 *                 be stored here.
 * @returns true on success or false if there is no event filter set.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetEventFilter
 *
 * @from SDL_events.h:1436 bool SDL_GetEventFilter(SDL_EventFilter *filter, void **userdata);
 */
  getEventFilter: lib.symbols.SDL_GetEventFilter,

/**
 * Add a callback to be triggered when an event is added to the event queue.
 *
 * `filter` will be called when an event happens, and its return value is
 * ignored.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * If the quit event is generated by a signal (e.g. SIGINT), it will bypass
 * the internal queue and be delivered to the watch callback immediately, and
 * arrive at the next event poll.
 *
 * Note: the callback is called for events posted by the user through
 * SDL_PushEvent(), but not for disabled events, nor for events by a filter
 * callback set with SDL_SetEventFilter(), nor for events posted by the user
 * through SDL_PeepEvents().
 *
 * @param filter an SDL_EventFilter function to call when an event happens.
 * @param userdata a pointer that is passed to `filter`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RemoveEventWatch
 * @sa SDL_SetEventFilter
 *
 * @from SDL_events.h:1468 bool SDL_AddEventWatch(SDL_EventFilter filter, void *userdata);
 */
  addEventWatch: lib.symbols.SDL_AddEventWatch,

/**
 * Remove an event watch callback added with SDL_AddEventWatch().
 *
 * This function takes the same input as SDL_AddEventWatch() to identify and
 * delete the corresponding callback.
 *
 * @param filter the function originally passed to SDL_AddEventWatch().
 * @param userdata the pointer originally passed to SDL_AddEventWatch().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddEventWatch
 *
 * @from SDL_events.h:1485 void SDL_RemoveEventWatch(SDL_EventFilter filter, void *userdata);
 */
  removeEventWatch: lib.symbols.SDL_RemoveEventWatch,

/**
 * Run a specific filter function on the current event queue, removing any
 * events for which the filter returns false.
 *
 * See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),
 * this function does not change the filter permanently, it only uses the
 * supplied filter until this function returns.
 *
 * @param filter the SDL_EventFilter function to call when an event happens.
 * @param userdata a pointer that is passed to `filter`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetEventFilter
 * @sa SDL_SetEventFilter
 *
 * @from SDL_events.h:1505 void SDL_FilterEvents(SDL_EventFilter filter, void *userdata);
 */
  filterEvents: lib.symbols.SDL_FilterEvents,

/**
 * Set the state of processing events by type.
 *
 * @param type the type of event; see SDL_EventType for details.
 * @param enabled whether to process the event or not.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_EventEnabled
 *
 * @from SDL_events.h:1519 void SDL_SetEventEnabled(Uint32 type, bool enabled);
 */
  setEventEnabled: lib.symbols.SDL_SetEventEnabled,

/**
 * Query the state of processing events by type.
 *
 * @param type the type of event; see SDL_EventType for details.
 * @returns true if the event is being processed, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetEventEnabled
 *
 * @from SDL_events.h:1533 bool SDL_EventEnabled(Uint32 type);
 */
  eventEnabled: lib.symbols.SDL_EventEnabled,

/**
 * Allocate a set of user-defined events, and return the beginning event
 * number for that set of events.
 *
 * @param numevents the number of events to be allocated.
 * @returns the beginning event number, or 0 if numevents is invalid or if
 *          there are not enough user-defined events left.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PushEvent
 *
 * @from SDL_events.h:1549 Uint32 SDL_RegisterEvents(int numevents);
 */
  registerEvents: lib.symbols.SDL_RegisterEvents,

/**
 * Get window associated with an event.
 *
 * @param event an event containing a `windowID`.
 * @returns the associated window on success or NULL if there is none.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PollEvent
 * @sa SDL_WaitEvent
 * @sa SDL_WaitEventTimeout
 *
 * @from SDL_events.h:1565 SDL_Window * SDL_GetWindowFromEvent(const SDL_Event *event);
 */
  getWindowFromEvent: lib.symbols.SDL_GetWindowFromEvent,



/*--- SDL_filesystem ---*/

/**
 * The type of the OS-provided default folder for a specific purpose.
 *
 * Note that the Trash folder isn't included here, because trashing files
 * usually involves extra OS-specific functionality to remember the file's
 * original location.
 *
 * The folders supported per platform are:
 *
 * |             | Windows | macOS/iOS | tvOS | Unix (XDG) | Haiku | Emscripten |
 * | ----------- | ------- | --------- | ---- | ---------- | ----- | ---------- |
 * | HOME        | X       | X         |      | X          | X     | X          |
 * | DESKTOP     | X       | X         |      | X          | X     |            |
 * | DOCUMENTS   | X       | X         |      | X          |       |            |
 * | DOWNLOADS   | Vista+  | X         |      | X          |       |            |
 * | MUSIC       | X       | X         |      | X          |       |            |
 * | PICTURES    | X       | X         |      | X          |       |            |
 * | PUBLICSHARE |         | X         |      | X          |       |            |
 * | SAVEDGAMES  | Vista+  |           |      |            |       |            |
 * | SCREENSHOTS | Vista+  |           |      |            |       |            |
 * | TEMPLATES   | X       | X         |      | X          |       |            |
 * | VIDEOS      | X       | X*        |      | X          |       |            |
 *
 * Note that on macOS/iOS, the Videos folder is called "Movies".
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_GetUserFolder
 *
 * @from SDL_filesystem.h:181 SDL_FOLDER_
 */
  FOLDER: SDL_filesystem_enums.SDL_Folder,

/**
 * Types of filesystem entries.
 *
 * Note that there may be other sorts of items on a filesystem: devices,
 * symlinks, named pipes, etc. They are currently reported as
 * SDL_PATHTYPE_OTHER.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_PathInfo
 *
 * @from SDL_filesystem.h:236 SDL_PATHTYPE_
 */
  PATHTYPE: SDL_filesystem_enums.SDL_PathType,

/**
 * Possible results from an enumeration callback.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_EnumerateDirectoryCallback
 *
 * @from SDL_filesystem.h:296 SDL_ENUM_
 */
  ENUM: SDL_filesystem_enums.SDL_EnumerationResult,



/**
 * Get the directory where the application was run from.
 *
 * SDL caches the result of this call internally, but the first call to this
 * function is not necessarily fast, so plan accordingly.
 *
 * **macOS and iOS Specific Functionality**: If the application is in a ".app"
 * bundle, this function returns the Resource directory (e.g.
 * MyApp.app/Contents/Resources/). This behaviour can be overridden by adding
 * a property to the Info.plist file. Adding a string key with the name
 * SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the
 * behaviour.
 *
 * Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an
 * application in /Applications/SDLApp/MyApp.app):
 *
 * - `resource`: bundle resource directory (the default). For example:
 *   `/Applications/SDLApp/MyApp.app/Contents/Resources`
 * - `bundle`: the Bundle directory. For example:
 *   `/Applications/SDLApp/MyApp.app/`
 * - `parent`: the containing directory of the bundle. For example:
 *   `/Applications/SDLApp/`
 *
 * **Nintendo 3DS Specific Functionality**: This function returns "romfs"
 * directory of the application as it is uncommon to store resources outside
 * the executable. As such it is not a writable directory.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * @returns an absolute path in UTF-8 encoding to the application data
 *          directory. NULL will be returned on error or when the platform
 *          doesn't implement this functionality, call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPrefPath
 *
 * @from SDL_filesystem.h:95 const char * SDL_GetBasePath(void);
 */
  getBasePath: lib.symbols.SDL_GetBasePath,

/**
 * Get the user-and-app-specific path where files can be written.
 *
 * Get the "pref dir". This is meant to be where users can write personal
 * files (preferences and save games, etc) that are specific to your
 * application. This directory is unique per user, per application.
 *
 * This function will decide the appropriate location in the native
 * filesystem, create the directory if necessary, and return a string of the
 * absolute path to the directory in UTF-8 encoding.
 *
 * On Windows, the string might look like:
 *
 * `C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\`
 *
 * On Linux, the string might look like:
 *
 * `/home/bob/.local/share/My Program Name/`
 *
 * On macOS, the string might look like:
 *
 * `/Users/bob/Library/Application Support/My Program Name/`
 *
 * You should assume the path returned by this function is the only safe place
 * to write files (and that SDL_GetBasePath(), while it might be writable, or
 * even the parent of the returned path, isn't where you should be writing
 * things).
 *
 * Both the org and app strings may become part of a directory name, so please
 * follow these rules:
 *
 * - Try to use the same org string (_including case-sensitivity_) for all
 *   your applications that use this function.
 * - Always use a unique app string for each one, and make sure it never
 *   changes for an app once you've decided on it.
 * - Unicode characters are legal, as long as they are UTF-8 encoded, but...
 * - ...only use letters, numbers, and spaces. Avoid punctuation like "Game
 *   Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * @param org the name of your organization.
 * @param app the name of your application.
 * @returns a UTF-8 string of the user directory in platform-dependent
 *          notation. NULL if there's a problem (creating directory failed,
 *          etc.). This should be freed with SDL_free() when it is no longer
 *          needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetBasePath
 *
 * @from SDL_filesystem.h:150 char * SDL_GetPrefPath(const char *org, const char *app);
 */
  getPrefPath: lib.symbols.SDL_GetPrefPath,

/**
 * Finds the most suitable user folder for a specific purpose.
 *
 * Many OSes provide certain standard folders for certain purposes, such as
 * storing pictures, music or videos for a certain user. This function gives
 * the path for many of those special locations.
 *
 * This function is specifically for _user_ folders, which are meant for the
 * user to access and manage. For application-specific folders, meant to hold
 * data for the application to manage, see SDL_GetBasePath() and
 * SDL_GetPrefPath().
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * If NULL is returned, the error may be obtained with SDL_GetError().
 *
 * @param folder the type of folder to find.
 * @returns either a null-terminated C string containing the full path to the
 *          folder, or NULL if an error happened.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:220 const char * SDL_GetUserFolder(SDL_Folder folder);
 */
  getUserFolder: lib.symbols.SDL_GetUserFolder,

/**
 * Create a directory, and any missing parent directories.
 *
 * This reports success if `path` already exists as a directory.
 *
 * If parent directories are missing, it will also create them. Note that if
 * this fails, it will not remove any parent directories it already made.
 *
 * @param path the path of the directory to create.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:287 bool SDL_CreateDirectory(const char *path);
 */
  createDirectory: lib.symbols.SDL_CreateDirectory,

/**
 * Enumerate a directory through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either SDL_ENUM_SUCCESS or
 * SDL_ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns SDL_ENUM_FAILURE. A successful return means a callback
 * returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * @param path the path of the directory to enumerate.
 * @param callback a function that is called for each entry in the directory.
 * @param userdata a pointer that is passed to `callback`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:350 bool SDL_EnumerateDirectory(const char *path, SDL_EnumerateDirectoryCallback callback, void *userdata);
 */
  enumerateDirectory: lib.symbols.SDL_EnumerateDirectory,

/**
 * Remove a file or an empty directory.
 *
 * Directories that are not empty will fail; this function will not recursely
 * delete directory trees.
 *
 * @param path the path to remove from the filesystem.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:364 bool SDL_RemovePath(const char *path);
 */
  removePath: lib.symbols.SDL_RemovePath,

/**
 * Rename a file or directory.
 *
 * If the file at `newpath` already exists, it will replaced.
 *
 * Note that this will not copy files across filesystems/drives/volumes, as
 * that is a much more complicated (and possibly time-consuming) operation.
 *
 * Which is to say, if this function fails, SDL_CopyFile() to a temporary file
 * in the same directory as `newpath`, then SDL_RenamePath() from the
 * temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work
 * for files. Renaming a non-empty directory across filesystems is
 * dramatically more complex, however.
 *
 * @param oldpath the old path.
 * @param newpath the new path.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:387 bool SDL_RenamePath(const char *oldpath, const char *newpath);
 */
  renamePath: lib.symbols.SDL_RenamePath,

/**
 * Copy a file.
 *
 * If the file at `newpath` already exists, it will be overwritten with the
 * contents of the file at `oldpath`.
 *
 * This function will block until the copy is complete, which might be a
 * significant time for large files on slow disks. On some platforms, the copy
 * can be handed off to the OS itself, but on others SDL might just open both
 * paths, and read from one and write to the other.
 *
 * Note that this is not an atomic operation! If something tries to read from
 * `newpath` while the copy is in progress, it will see an incomplete copy of
 * the data, and if the calling thread terminates (or the power goes out)
 * during the copy, `newpath`'s previous contents will be gone, replaced with
 * an incomplete copy of the data. To avoid this risk, it is recommended that
 * the app copy to a temporary file in the same directory as `newpath`, and if
 * the copy is successful, use SDL_RenamePath() to replace `newpath` with the
 * temporary file. This will ensure that reads of `newpath` will either see a
 * complete copy of the data, or it will see the pre-copy state of `newpath`.
 *
 * This function attempts to synchronize the newly-copied data to disk before
 * returning, if the platform allows it, so that the renaming trick will not
 * have a problem in a system crash or power failure, where the file could be
 * renamed but the contents never made it from the system file cache to the
 * physical disk.
 *
 * If the copy fails for any reason, the state of `newpath` is undefined. It
 * might be half a copy, it might be the untouched data of what was already
 * there, or it might be a zero-byte file, etc.
 *
 * @param oldpath the old path.
 * @param newpath the new path.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:427 bool SDL_CopyFile(const char *oldpath, const char *newpath);
 */
  copyFile: lib.symbols.SDL_CopyFile,

/**
 * Get information about a filesystem path.
 *
 * @param path the path to query.
 * @param info a pointer filled in with information about the path, or NULL to
 *             check for the existence of a file.
 * @returns true on success or false if the file doesn't exist, or another
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:440 bool SDL_GetPathInfo(const char *path, SDL_PathInfo *info);
 */
  getPathInfo: lib.symbols.SDL_GetPathInfo,

/**
 * Enumerate a directory tree, filtered by pattern, and return a list.
 *
 * Files are filtered out if they don't match the string in `pattern`, which
 * may contain wildcard characters '\*' (match everything) and '?' (match one
 * character). If pattern is NULL, no filtering is done and all results are
 * returned. Subdirectories are permitted, and are specified with a path
 * separator of '/'. Wildcard characters '\*' and '?' never match a path
 * separator.
 *
 * `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching
 * case-insensitive.
 *
 * The returned array is always NULL-terminated, for your iterating
 * convenience, but if `count` is non-NULL, on return it will contain the
 * number of items in the array, not counting the NULL terminator.
 *
 * @param path the path of the directory to enumerate.
 * @param pattern the pattern that files in the directory must match. Can be
 *                NULL.
 * @param flags `SDL_GLOB_*` bitflags that affect this search.
 * @param count on return, will be set to the number of items in the returned
 *              array. Can be NULL.
 * @returns an array of strings on success or NULL on failure; call
 *          SDL_GetError() for more information. This is a single allocation
 *          that should be freed with SDL_free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:473 char ** SDL_GlobDirectory(const char *path, const char *pattern, SDL_GlobFlags flags, int *count);
 */
  globDirectory: lib.symbols.SDL_GlobDirectory,

/**
 * Get what the system believes is the "current working directory."
 *
 * For systems without a concept of a current working directory, this will
 * still attempt to provide something reasonable.
 *
 * SDL does not provide a means to _change_ the current working directory; for
 * platforms without this concept, this would cause surprises with file access
 * outside of SDL.
 *
 * The returned path is guaranteed to end with a path separator ('\\' on
 * Windows, '/' on most other platforms).
 *
 * @returns a UTF-8 string of the current working directory in
 *          platform-dependent notation. NULL if there's a problem. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_filesystem.h:494 char * SDL_GetCurrentDirectory(void);
 */
  getCurrentDirectory: lib.symbols.SDL_GetCurrentDirectory,



/*--- SDL_gamepad ---*/

/**
 * Standard gamepad types.
 *
 * This type does not necessarily map to first-party controllers from
 * Microsoft/Sony/Nintendo; in many cases, third-party controllers can report
 * as these, either because they were designed for a specific console, or they
 * simply most closely match that console's controllers (does it have A/B/X/Y
 * buttons or X/O/Square/Triangle? Does it have a touchpad? etc).
 *
 * @from SDL_gamepad.h:107 SDL_GAMEPAD_TYPE_
 */
  GAMEPAD_TYPE: SDL_gamepad_enums.SDL_GamepadType,

/**
 * The list of buttons available on a gamepad
 *
 * For controllers that use a diamond pattern for the face buttons, the
 * south/east/west/north buttons below correspond to the locations in the
 * diamond pattern. For Xbox controllers, this would be A/B/X/Y, for Nintendo
 * Switch controllers, this would be B/A/Y/X, for PlayStation controllers this
 * would be Cross/Circle/Square/Triangle.
 *
 * For controllers that don't use a diamond pattern for the face buttons, the
 * south/east/west/north buttons indicate the buttons labeled A, B, C, D, or
 * 1, 2, 3, 4, or for controllers that aren't labeled, they are the primary,
 * secondary, etc. buttons.
 *
 * The activate action is often the south button and the cancel action is
 * often the east button, but in some regions this is reversed, so your game
 * should allow remapping actions based on user preferences.
 *
 * You can query the labels for the face buttons using
 * SDL_GetGamepadButtonLabel()
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:146 SDL_GAMEPAD_BUTTON_
 */
  GAMEPAD_BUTTON: SDL_gamepad_enums.SDL_GamepadButton,

/**
 * The set of gamepad button labels
 *
 * This isn't a complete set, just the face buttons to make it easy to show
 * button prompts.
 *
 * For a complete set, you should look at the button and gamepad type and have
 * a set of symbols that work well with your art style.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:189 SDL_GAMEPAD_BUTTON_LABEL_
 */
  GAMEPAD_BUTTON_LABEL: SDL_gamepad_enums.SDL_GamepadButtonLabel,

/**
 * The list of axes available on a gamepad
 *
 * Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to
 * SDL_JOYSTICK_AXIS_MAX, and are centered within ~8000 of zero, though
 * advanced UI will allow users to set or autodetect the dead zone, which
 * varies between gamepads.
 *
 * Trigger axis values range from 0 (released) to SDL_JOYSTICK_AXIS_MAX (fully
 * pressed) when reported by SDL_GetGamepadAxis(). Note that this is not the
 * same range that will be reported by the lower-level SDL_GetJoystickAxis().
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:216 SDL_GAMEPAD_AXIS_
 */
  GAMEPAD_AXIS: SDL_gamepad_enums.SDL_GamepadAxis,

/**
 * Types of gamepad control bindings.
 *
 * A gamepad is a collection of bindings that map arbitrary joystick buttons,
 * axes and hat switches to specific positions on a generic console-style
 * gamepad. This enum is used as part of SDL_GamepadBinding to specify those
 * mappings.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:238 SDL_GAMEPAD_BINDTYPE_
 */
  GAMEPAD_BINDTYPE: SDL_gamepad_enums.SDL_GamepadBindingType,



/**
 * Add support for gamepads that SDL is unaware of or change the binding of an
 * existing gamepad.
 *
 * The mapping string has the format "GUID,name,mapping", where GUID is the
 * string value from SDL_GUIDToString(), name is the human readable string for
 * the device and mappings are gamepad mappings to joystick ones. Under
 * Windows there is a reserved GUID of "xinput" that covers all XInput
 * devices. The mapping format for joystick is:
 *
 * - `bX`: a joystick button, index X
 * - `hX.Y`: hat X with value Y
 * - `aX`: axis X of the joystick
 *
 * Buttons can be used as a gamepad axes and vice versa.
 *
 * If a device with this GUID is already plugged in, SDL will generate an
 * SDL_EVENT_GAMEPAD_ADDED event.
 *
 * This string shows an example of a valid mapping for a gamepad:
 *
 * ```c
 * "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"
 * ```
 *
 * @param mapping the mapping string.
 * @returns 1 if a new mapping is added, 0 if an existing mapping is updated,
 *          -1 on failure; call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddGamepadMappingsFromFile
 * @sa SDL_AddGamepadMappingsFromIO
 * @sa SDL_GetGamepadMapping
 * @sa SDL_GetGamepadMappingForGUID
 * @sa SDL_HINT_GAMECONTROLLERCONFIG
 * @sa SDL_HINT_GAMECONTROLLERCONFIG_FILE
 * @sa SDL_EVENT_GAMEPAD_ADDED
 *
 * @from SDL_gamepad.h:340 int SDL_AddGamepadMapping(const char *mapping);
 */
  addGamepadMapping: lib.symbols.SDL_AddGamepadMapping,

/**
 * Load a set of gamepad mappings from an SDL_IOStream.
 *
 * You can call this function several times, if needed, to load different
 * database files.
 *
 * If a new mapping is loaded for an already known gamepad GUID, the later
 * version will overwrite the one currently loaded.
 *
 * Any new mappings for already plugged in controllers will generate
 * SDL_EVENT_GAMEPAD_ADDED events.
 *
 * Mappings not belonging to the current platform or with no platform field
 * specified will be ignored (i.e. mappings for Linux will be ignored in
 * Windows, etc).
 *
 * This function will load the text database entirely in memory before
 * processing it, so take this into consideration if you are in a memory
 * constrained environment.
 *
 * @param src the data stream for the mappings to be added.
 * @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * @returns the number of mappings added or -1 on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddGamepadMapping
 * @sa SDL_AddGamepadMappingsFromFile
 * @sa SDL_GetGamepadMapping
 * @sa SDL_GetGamepadMappingForGUID
 * @sa SDL_HINT_GAMECONTROLLERCONFIG
 * @sa SDL_HINT_GAMECONTROLLERCONFIG_FILE
 * @sa SDL_EVENT_GAMEPAD_ADDED
 *
 * @from SDL_gamepad.h:380 int SDL_AddGamepadMappingsFromIO(SDL_IOStream *src, bool closeio);
 */
  addGamepadMappingsFromIo: lib.symbols.SDL_AddGamepadMappingsFromIO,

/**
 * Load a set of gamepad mappings from a file.
 *
 * You can call this function several times, if needed, to load different
 * database files.
 *
 * If a new mapping is loaded for an already known gamepad GUID, the later
 * version will overwrite the one currently loaded.
 *
 * Any new mappings for already plugged in controllers will generate
 * SDL_EVENT_GAMEPAD_ADDED events.
 *
 * Mappings not belonging to the current platform or with no platform field
 * specified will be ignored (i.e. mappings for Linux will be ignored in
 * Windows, etc).
 *
 * @param file the mappings file to load.
 * @returns the number of mappings added or -1 on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddGamepadMapping
 * @sa SDL_AddGamepadMappingsFromIO
 * @sa SDL_GetGamepadMapping
 * @sa SDL_GetGamepadMappingForGUID
 * @sa SDL_HINT_GAMECONTROLLERCONFIG
 * @sa SDL_HINT_GAMECONTROLLERCONFIG_FILE
 * @sa SDL_EVENT_GAMEPAD_ADDED
 *
 * @from SDL_gamepad.h:414 int SDL_AddGamepadMappingsFromFile(const char *file);
 */
  addGamepadMappingsFromFile: lib.symbols.SDL_AddGamepadMappingsFromFile,

/**
 * Reinitialize the SDL mapping database to its initial state.
 *
 * This will generate gamepad events as needed if device mappings change.
 *
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:426 bool SDL_ReloadGamepadMappings(void);
 */
  reloadGamepadMappings: lib.symbols.SDL_ReloadGamepadMappings,

/**
 * Get the current gamepad mappings.
 *
 * @param count a pointer filled in with the number of mappings returned, can
 *              be NULL.
 * @returns an array of the mapping strings, NULL-terminated, or NULL on
 *          failure; call SDL_GetError() for more information. This is a
 *          single allocation that should be freed with SDL_free() when it is
 *          no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:440 char ** SDL_GetGamepadMappings(int *count);
 */
  getGamepadMappings: lib.symbols.SDL_GetGamepadMappings,

/**
 * Get the gamepad mapping string for a given GUID.
 *
 * @param guid a structure containing the GUID for which a mapping is desired.
 * @returns a mapping string or NULL on failure; call SDL_GetError() for more
 *          information. This should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickGUIDForID
 * @sa SDL_GetJoystickGUID
 *
 * @from SDL_gamepad.h:455 char * SDL_GetGamepadMappingForGUID(SDL_GUID guid);
 */
  getGamepadMappingForGuid: lib.symbols.SDL_GetGamepadMappingForGUID,

/**
 * Get the current mapping of a gamepad.
 *
 * Details about mappings are discussed with SDL_AddGamepadMapping().
 *
 * @param gamepad the gamepad you want to get the current mapping for.
 * @returns a string that has the gamepad's mapping or NULL if no mapping is
 *          available; call SDL_GetError() for more information. This should
 *          be freed with SDL_free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddGamepadMapping
 * @sa SDL_GetGamepadMappingForID
 * @sa SDL_GetGamepadMappingForGUID
 * @sa SDL_SetGamepadMapping
 *
 * @from SDL_gamepad.h:474 char * SDL_GetGamepadMapping(SDL_Gamepad *gamepad);
 */
  getGamepadMapping: lib.symbols.SDL_GetGamepadMapping,

/**
 * Set the current mapping of a joystick or gamepad.
 *
 * Details about mappings are discussed with SDL_AddGamepadMapping().
 *
 * @param instance_id the joystick instance ID.
 * @param mapping the mapping to use for this device, or NULL to clear the
 *                mapping.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddGamepadMapping
 * @sa SDL_GetGamepadMapping
 *
 * @from SDL_gamepad.h:492 bool SDL_SetGamepadMapping(SDL_JoystickID instance_id, const char *mapping);
 */
  setGamepadMapping: lib.symbols.SDL_SetGamepadMapping,

/**
 * Return whether a gamepad is currently connected.
 *
 * @returns true if a gamepad is connected, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepads
 *
 * @from SDL_gamepad.h:503 bool SDL_HasGamepad(void);
 */
  hasGamepad: lib.symbols.SDL_HasGamepad,

/**
 * Get a list of currently connected gamepads.
 *
 * @param count a pointer filled in with the number of gamepads returned, may
 *              be NULL.
 * @returns a 0 terminated array of joystick instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasGamepad
 * @sa SDL_OpenGamepad
 *
 * @from SDL_gamepad.h:519 SDL_JoystickID * SDL_GetGamepads(int *count);
 */
  getGamepads: lib.symbols.SDL_GetGamepads,

/**
 * Check if the given joystick is supported by the gamepad interface.
 *
 * @param instance_id the joystick instance ID.
 * @returns true if the given joystick is supported by the gamepad interface,
 *          false if it isn't or it's an invalid index.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoysticks
 * @sa SDL_OpenGamepad
 *
 * @from SDL_gamepad.h:533 bool SDL_IsGamepad(SDL_JoystickID instance_id);
 */
  isGamepad: lib.symbols.SDL_IsGamepad,

/**
 * Get the implementation dependent name of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the name of the selected gamepad. If no name can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadName
 * @sa SDL_GetGamepads
 *
 * @from SDL_gamepad.h:549 const char * SDL_GetGamepadNameForID(SDL_JoystickID instance_id);
 */
  getGamepadNameForId: lib.symbols.SDL_GetGamepadNameForID,

/**
 * Get the implementation dependent path of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the path of the selected gamepad. If no path can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadPath
 * @sa SDL_GetGamepads
 *
 * @from SDL_gamepad.h:565 const char * SDL_GetGamepadPathForID(SDL_JoystickID instance_id);
 */
  getGamepadPathForId: lib.symbols.SDL_GetGamepadPathForID,

/**
 * Get the player index of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the player index of a gamepad, or -1 if it's not available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadPlayerIndex
 * @sa SDL_GetGamepads
 *
 * @from SDL_gamepad.h:580 int SDL_GetGamepadPlayerIndexForID(SDL_JoystickID instance_id);
 */
  getGamepadPlayerIndexForId: lib.symbols.SDL_GetGamepadPlayerIndexForID,

/**
 * Get the implementation-dependent GUID of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the GUID of the selected gamepad. If called on an invalid index,
 *          this function returns a zero GUID.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GUIDToString
 * @sa SDL_GetGamepads
 *
 * @from SDL_gamepad.h:596 SDL_GUID SDL_GetGamepadGUIDForID(SDL_JoystickID instance_id);
 */
  getGamepadGuidForId: lib.symbols.SDL_GetGamepadGUIDForID,

/**
 * Get the USB vendor ID of a gamepad, if available.
 *
 * This can be called before any gamepads are opened. If the vendor ID isn't
 * available this function returns 0.
 *
 * @param instance_id the joystick instance ID.
 * @returns the USB vendor ID of the selected gamepad. If called on an invalid
 *          index, this function returns zero.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadVendor
 * @sa SDL_GetGamepads
 *
 * @from SDL_gamepad.h:613 Uint16 SDL_GetGamepadVendorForID(SDL_JoystickID instance_id);
 */
  getGamepadVendorForId: lib.symbols.SDL_GetGamepadVendorForID,

/**
 * Get the USB product ID of a gamepad, if available.
 *
 * This can be called before any gamepads are opened. If the product ID isn't
 * available this function returns 0.
 *
 * @param instance_id the joystick instance ID.
 * @returns the USB product ID of the selected gamepad. If called on an
 *          invalid index, this function returns zero.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadProduct
 * @sa SDL_GetGamepads
 *
 * @from SDL_gamepad.h:630 Uint16 SDL_GetGamepadProductForID(SDL_JoystickID instance_id);
 */
  getGamepadProductForId: lib.symbols.SDL_GetGamepadProductForID,

/**
 * Get the product version of a gamepad, if available.
 *
 * This can be called before any gamepads are opened. If the product version
 * isn't available this function returns 0.
 *
 * @param instance_id the joystick instance ID.
 * @returns the product version of the selected gamepad. If called on an
 *          invalid index, this function returns zero.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadProductVersion
 * @sa SDL_GetGamepads
 *
 * @from SDL_gamepad.h:647 Uint16 SDL_GetGamepadProductVersionForID(SDL_JoystickID instance_id);
 */
  getGamepadProductVersionForId: lib.symbols.SDL_GetGamepadProductVersionForID,

/**
 * Get the type of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the gamepad type.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadType
 * @sa SDL_GetGamepads
 * @sa SDL_GetRealGamepadTypeForID
 *
 * @from SDL_gamepad.h:663 SDL_GamepadType SDL_GetGamepadTypeForID(SDL_JoystickID instance_id);
 */
  getGamepadTypeForId: lib.symbols.SDL_GetGamepadTypeForID,

/**
 * Get the type of a gamepad, ignoring any mapping override.
 *
 * This can be called before any gamepads are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the gamepad type.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadTypeForID
 * @sa SDL_GetGamepads
 * @sa SDL_GetRealGamepadType
 *
 * @from SDL_gamepad.h:679 SDL_GamepadType SDL_GetRealGamepadTypeForID(SDL_JoystickID instance_id);
 */
  getRealGamepadTypeForId: lib.symbols.SDL_GetRealGamepadTypeForID,

/**
 * Get the mapping of a gamepad.
 *
 * This can be called before any gamepads are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the mapping string. Returns NULL if no mapping is available. This
 *          should be freed with SDL_free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepads
 * @sa SDL_GetGamepadMapping
 *
 * @from SDL_gamepad.h:695 char * SDL_GetGamepadMappingForID(SDL_JoystickID instance_id);
 */
  getGamepadMappingForId: lib.symbols.SDL_GetGamepadMappingForID,

/**
 * Open a gamepad for use.
 *
 * @param instance_id the joystick instance ID.
 * @returns a gamepad identifier or NULL if an error occurred; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseGamepad
 * @sa SDL_IsGamepad
 *
 * @from SDL_gamepad.h:709 SDL_Gamepad * SDL_OpenGamepad(SDL_JoystickID instance_id);
 */
  openGamepad: lib.symbols.SDL_OpenGamepad,

/**
 * Get the SDL_Gamepad associated with a joystick instance ID, if it has been
 * opened.
 *
 * @param instance_id the joystick instance ID of the gamepad.
 * @returns an SDL_Gamepad on success or NULL on failure or if it hasn't been
 *          opened yet; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:721 SDL_Gamepad * SDL_GetGamepadFromID(SDL_JoystickID instance_id);
 */
  getGamepadFromId: lib.symbols.SDL_GetGamepadFromID,

/**
 * Get the SDL_Gamepad associated with a player index.
 *
 * @param player_index the player index, which different from the instance ID.
 * @returns the SDL_Gamepad associated with a player index.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadPlayerIndex
 * @sa SDL_SetGamepadPlayerIndex
 *
 * @from SDL_gamepad.h:734 SDL_Gamepad * SDL_GetGamepadFromPlayerIndex(int player_index);
 */
  getGamepadFromPlayerIndex: lib.symbols.SDL_GetGamepadFromPlayerIndex,

/**
 * Get the properties associated with an opened gamepad.
 *
 * These properties are shared with the underlying joystick object.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED
 *   that has adjustable brightness
 * - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED
 *   that has adjustable color
 * - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a
 *   player LED
 * - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has
 *   left/right rumble
 * - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has
 *   simple trigger rumble
 *
 * @param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:761 SDL_PropertiesID SDL_GetGamepadProperties(SDL_Gamepad *gamepad);
 */
  getGamepadProperties: lib.symbols.SDL_GetGamepadProperties,

/**
 * Get the instance ID of an opened gamepad.
 *
 * @param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * @returns the instance ID of the specified gamepad on success or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:779 SDL_JoystickID SDL_GetGamepadID(SDL_Gamepad *gamepad);
 */
  getGamepadId: lib.symbols.SDL_GetGamepadID,

/**
 * Get the implementation-dependent name for an opened gamepad.
 *
 * @param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * @returns the implementation dependent name for the gamepad, or NULL if
 *          there is no name or the identifier passed is invalid.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadNameForID
 *
 * @from SDL_gamepad.h:793 const char * SDL_GetGamepadName(SDL_Gamepad *gamepad);
 */
  getGamepadName: lib.symbols.SDL_GetGamepadName,

/**
 * Get the implementation-dependent path for an opened gamepad.
 *
 * @param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * @returns the implementation dependent path for the gamepad, or NULL if
 *          there is no path or the identifier passed is invalid.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadPathForID
 *
 * @from SDL_gamepad.h:807 const char * SDL_GetGamepadPath(SDL_Gamepad *gamepad);
 */
  getGamepadPath: lib.symbols.SDL_GetGamepadPath,

/**
 * Get the type of an opened gamepad.
 *
 * @param gamepad the gamepad object to query.
 * @returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not
 *          available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadTypeForID
 *
 * @from SDL_gamepad.h:820 SDL_GamepadType SDL_GetGamepadType(SDL_Gamepad *gamepad);
 */
  getGamepadType: lib.symbols.SDL_GetGamepadType,

/**
 * Get the type of an opened gamepad, ignoring any mapping override.
 *
 * @param gamepad the gamepad object to query.
 * @returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not
 *          available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRealGamepadTypeForID
 *
 * @from SDL_gamepad.h:833 SDL_GamepadType SDL_GetRealGamepadType(SDL_Gamepad *gamepad);
 */
  getRealGamepadType: lib.symbols.SDL_GetRealGamepadType,

/**
 * Get the player index of an opened gamepad.
 *
 * For XInput gamepads this returns the XInput user index.
 *
 * @param gamepad the gamepad object to query.
 * @returns the player index for gamepad, or -1 if it's not available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetGamepadPlayerIndex
 *
 * @from SDL_gamepad.h:847 int SDL_GetGamepadPlayerIndex(SDL_Gamepad *gamepad);
 */
  getGamepadPlayerIndex: lib.symbols.SDL_GetGamepadPlayerIndex,

/**
 * Set the player index of an opened gamepad.
 *
 * @param gamepad the gamepad object to adjust.
 * @param player_index player index to assign to this gamepad, or -1 to clear
 *                     the player index and turn off player LEDs.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadPlayerIndex
 *
 * @from SDL_gamepad.h:862 bool SDL_SetGamepadPlayerIndex(SDL_Gamepad *gamepad, int player_index);
 */
  setGamepadPlayerIndex: lib.symbols.SDL_SetGamepadPlayerIndex,

/**
 * Get the USB vendor ID of an opened gamepad, if available.
 *
 * If the vendor ID isn't available this function returns 0.
 *
 * @param gamepad the gamepad object to query.
 * @returns the USB vendor ID, or zero if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadVendorForID
 *
 * @from SDL_gamepad.h:876 Uint16 SDL_GetGamepadVendor(SDL_Gamepad *gamepad);
 */
  getGamepadVendor: lib.symbols.SDL_GetGamepadVendor,

/**
 * Get the USB product ID of an opened gamepad, if available.
 *
 * If the product ID isn't available this function returns 0.
 *
 * @param gamepad the gamepad object to query.
 * @returns the USB product ID, or zero if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadProductForID
 *
 * @from SDL_gamepad.h:890 Uint16 SDL_GetGamepadProduct(SDL_Gamepad *gamepad);
 */
  getGamepadProduct: lib.symbols.SDL_GetGamepadProduct,

/**
 * Get the product version of an opened gamepad, if available.
 *
 * If the product version isn't available this function returns 0.
 *
 * @param gamepad the gamepad object to query.
 * @returns the USB product version, or zero if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadProductVersionForID
 *
 * @from SDL_gamepad.h:904 Uint16 SDL_GetGamepadProductVersion(SDL_Gamepad *gamepad);
 */
  getGamepadProductVersion: lib.symbols.SDL_GetGamepadProductVersion,

/**
 * Get the firmware version of an opened gamepad, if available.
 *
 * If the firmware version isn't available this function returns 0.
 *
 * @param gamepad the gamepad object to query.
 * @returns the gamepad firmware version, or zero if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:916 Uint16 SDL_GetGamepadFirmwareVersion(SDL_Gamepad *gamepad);
 */
  getGamepadFirmwareVersion: lib.symbols.SDL_GetGamepadFirmwareVersion,

/**
 * Get the serial number of an opened gamepad, if available.
 *
 * Returns the serial number of the gamepad, or NULL if it is not available.
 *
 * @param gamepad the gamepad object to query.
 * @returns the serial number, or NULL if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:928 const char * SDL_GetGamepadSerial(SDL_Gamepad *gamepad);
 */
  getGamepadSerial: lib.symbols.SDL_GetGamepadSerial,

/**
 * Get the Steam Input handle of an opened gamepad, if available.
 *
 * Returns an InputHandle_t for the gamepad that can be used with Steam Input
 * API: https://partner.steamgames.com/doc/api/ISteamInput
 *
 * @param gamepad the gamepad object to query.
 * @returns the gamepad handle, or 0 if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:941 Uint64 SDL_GetGamepadSteamHandle(SDL_Gamepad *gamepad);
 */
  getGamepadSteamHandle: lib.symbols.SDL_GetGamepadSteamHandle,

/**
 * Get the connection state of a gamepad.
 *
 * @param gamepad the gamepad object to query.
 * @returns the connection state on success or
 *          `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:953 SDL_JoystickConnectionState SDL_GetGamepadConnectionState(SDL_Gamepad *gamepad);
 */
  getGamepadConnectionState: lib.symbols.SDL_GetGamepadConnectionState,

/**
 * Get the battery state of a gamepad.
 *
 * You should never take a battery status as absolute truth. Batteries
 * (especially failing batteries) are delicate hardware, and the values
 * reported here are best estimates based on what that hardware reports. It's
 * not uncommon for older batteries to lose stored power much faster than it
 * reports, or completely drain when reporting it has 20 percent left, etc.
 *
 * @param gamepad the gamepad object to query.
 * @param percent a pointer filled in with the percentage of battery life
 *                left, between 0 and 100, or NULL to ignore. This will be
 *                filled in with -1 we can't determine a value or there is no
 *                battery.
 * @returns the current battery state.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:973 SDL_PowerState SDL_GetGamepadPowerInfo(SDL_Gamepad *gamepad, int *percent);
 */
  getGamepadPowerInfo: lib.symbols.SDL_GetGamepadPowerInfo,

/**
 * Check if a gamepad has been opened and is currently connected.
 *
 * @param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 * @returns true if the gamepad has been opened and is currently connected, or
 *          false if not.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:985 bool SDL_GamepadConnected(SDL_Gamepad *gamepad);
 */
  gamepadConnected: lib.symbols.SDL_GamepadConnected,

/**
 * Get the underlying joystick from a gamepad.
 *
 * This function will give you a SDL_Joystick object, which allows you to use
 * the SDL_Joystick functions with a SDL_Gamepad object. This would be useful
 * for getting a joystick's position at any given time, even if it hasn't
 * moved (moving it would produce an event, which would have the axis' value).
 *
 * The pointer returned is owned by the SDL_Gamepad. You should not call
 * SDL_CloseJoystick() on it, for example, since doing so will likely cause
 * SDL to crash.
 *
 * @param gamepad the gamepad object that you want to get a joystick from.
 * @returns an SDL_Joystick object, or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:1005 SDL_Joystick * SDL_GetGamepadJoystick(SDL_Gamepad *gamepad);
 */
  getGamepadJoystick: lib.symbols.SDL_GetGamepadJoystick,

/**
 * Set the state of gamepad event processing.
 *
 * If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself
 * and check the state of the gamepad when you want gamepad information.
 *
 * @param enabled whether to process gamepad events or not.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GamepadEventsEnabled
 * @sa SDL_UpdateGamepads
 *
 * @from SDL_gamepad.h:1020 void SDL_SetGamepadEventsEnabled(bool enabled);
 */
  setGamepadEventsEnabled: lib.symbols.SDL_SetGamepadEventsEnabled,

/**
 * Query the state of gamepad event processing.
 *
 * If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself
 * and check the state of the gamepad when you want gamepad information.
 *
 * @returns true if gamepad events are being processed, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetGamepadEventsEnabled
 *
 * @from SDL_gamepad.h:1034 bool SDL_GamepadEventsEnabled(void);
 */
  gamepadEventsEnabled: lib.symbols.SDL_GamepadEventsEnabled,

/**
 * Get the SDL joystick layer bindings for a gamepad.
 *
 * @param gamepad a gamepad.
 * @param count a pointer filled in with the number of bindings returned.
 * @returns a NULL terminated array of pointers to bindings or NULL on
 *          failure; call SDL_GetError() for more information. This is a
 *          single allocation that should be freed with SDL_free() when it is
 *          no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:1048 SDL_GamepadBinding ** SDL_GetGamepadBindings(SDL_Gamepad *gamepad, int *count);
 */
  getGamepadBindings: lib.symbols.SDL_GetGamepadBindings,

/**
 * Manually pump gamepad updates if not using the loop.
 *
 * This function is called automatically by the event loop if events are
 * enabled. Under such circumstances, it will not be necessary to call this
 * function.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:1059 void SDL_UpdateGamepads(void);
 */
  updateGamepads: lib.symbols.SDL_UpdateGamepads,

/**
 * Convert a string into SDL_GamepadType enum.
 *
 * This function is called internally to translate SDL_Gamepad mapping strings
 * for the underlying joystick device into the consistent SDL_Gamepad mapping.
 * You do not normally need to call this function unless you are parsing
 * SDL_Gamepad mappings in your own code.
 *
 * @param str string representing a SDL_GamepadType type.
 * @returns the SDL_GamepadType enum corresponding to the input string, or
 *          `SDL_GAMEPAD_TYPE_UNKNOWN` if no match was found.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadStringForType
 *
 * @from SDL_gamepad.h:1077 SDL_GamepadType SDL_GetGamepadTypeFromString(const char *str);
 */
  getGamepadTypeFromString: lib.symbols.SDL_GetGamepadTypeFromString,

/**
 * Convert from an SDL_GamepadType enum to a string.
 *
 * @param type an enum value for a given SDL_GamepadType.
 * @returns a string for the given type, or NULL if an invalid type is
 *          specified. The string returned is of the format used by
 *          SDL_Gamepad mapping strings.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadTypeFromString
 *
 * @from SDL_gamepad.h:1091 const char * SDL_GetGamepadStringForType(SDL_GamepadType type);
 */
  getGamepadStringForType: lib.symbols.SDL_GetGamepadStringForType,

/**
 * Convert a string into SDL_GamepadAxis enum.
 *
 * This function is called internally to translate SDL_Gamepad mapping strings
 * for the underlying joystick device into the consistent SDL_Gamepad mapping.
 * You do not normally need to call this function unless you are parsing
 * SDL_Gamepad mappings in your own code.
 *
 * Note specially that "righttrigger" and "lefttrigger" map to
 * `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,
 * respectively.
 *
 * @param str string representing a SDL_Gamepad axis.
 * @returns the SDL_GamepadAxis enum corresponding to the input string, or
 *          `SDL_GAMEPAD_AXIS_INVALID` if no match was found.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadStringForAxis
 *
 * @from SDL_gamepad.h:1113 SDL_GamepadAxis SDL_GetGamepadAxisFromString(const char *str);
 */
  getGamepadAxisFromString: lib.symbols.SDL_GetGamepadAxisFromString,

/**
 * Convert from an SDL_GamepadAxis enum to a string.
 *
 * @param axis an enum value for a given SDL_GamepadAxis.
 * @returns a string for the given axis, or NULL if an invalid axis is
 *          specified. The string returned is of the format used by
 *          SDL_Gamepad mapping strings.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadAxisFromString
 *
 * @from SDL_gamepad.h:1127 const char * SDL_GetGamepadStringForAxis(SDL_GamepadAxis axis);
 */
  getGamepadStringForAxis: lib.symbols.SDL_GetGamepadStringForAxis,

/**
 * Query whether a gamepad has a given axis.
 *
 * This merely reports whether the gamepad's mapping defined this axis, as
 * that is all the information SDL has about the physical device.
 *
 * @param gamepad a gamepad.
 * @param axis an axis enum value (an SDL_GamepadAxis value).
 * @returns true if the gamepad has this axis, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GamepadHasButton
 * @sa SDL_GetGamepadAxis
 *
 * @from SDL_gamepad.h:1144 bool SDL_GamepadHasAxis(SDL_Gamepad *gamepad, SDL_GamepadAxis axis);
 */
  gamepadHasAxis: lib.symbols.SDL_GamepadHasAxis,

/**
 * Get the current state of an axis control on a gamepad.
 *
 * The axis indices start at index 0.
 *
 * For thumbsticks, the state is a value ranging from -32768 (up/left) to
 * 32767 (down/right).
 *
 * Triggers range from 0 when released to 32767 when fully pressed, and never
 * return a negative value. Note that this differs from the value reported by
 * the lower-level SDL_GetJoystickAxis(), which normally uses the full range.
 *
 * @param gamepad a gamepad.
 * @param axis an axis index (one of the SDL_GamepadAxis values).
 * @returns axis state (including 0) on success or 0 (also) on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GamepadHasAxis
 * @sa SDL_GetGamepadButton
 *
 * @from SDL_gamepad.h:1168 Sint16 SDL_GetGamepadAxis(SDL_Gamepad *gamepad, SDL_GamepadAxis axis);
 */
  getGamepadAxis: lib.symbols.SDL_GetGamepadAxis,

/**
 * Convert a string into an SDL_GamepadButton enum.
 *
 * This function is called internally to translate SDL_Gamepad mapping strings
 * for the underlying joystick device into the consistent SDL_Gamepad mapping.
 * You do not normally need to call this function unless you are parsing
 * SDL_Gamepad mappings in your own code.
 *
 * @param str string representing a SDL_Gamepad axis.
 * @returns the SDL_GamepadButton enum corresponding to the input string, or
 *          `SDL_GAMEPAD_BUTTON_INVALID` if no match was found.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadStringForButton
 *
 * @from SDL_gamepad.h:1186 SDL_GamepadButton SDL_GetGamepadButtonFromString(const char *str);
 */
  getGamepadButtonFromString: lib.symbols.SDL_GetGamepadButtonFromString,

/**
 * Convert from an SDL_GamepadButton enum to a string.
 *
 * @param button an enum value for a given SDL_GamepadButton.
 * @returns a string for the given button, or NULL if an invalid button is
 *          specified. The string returned is of the format used by
 *          SDL_Gamepad mapping strings.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadButtonFromString
 *
 * @from SDL_gamepad.h:1200 const char * SDL_GetGamepadStringForButton(SDL_GamepadButton button);
 */
  getGamepadStringForButton: lib.symbols.SDL_GetGamepadStringForButton,

/**
 * Query whether a gamepad has a given button.
 *
 * This merely reports whether the gamepad's mapping defined this button, as
 * that is all the information SDL has about the physical device.
 *
 * @param gamepad a gamepad.
 * @param button a button enum value (an SDL_GamepadButton value).
 * @returns true if the gamepad has this button, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GamepadHasAxis
 *
 * @from SDL_gamepad.h:1216 bool SDL_GamepadHasButton(SDL_Gamepad *gamepad, SDL_GamepadButton button);
 */
  gamepadHasButton: lib.symbols.SDL_GamepadHasButton,

/**
 * Get the current state of a button on a gamepad.
 *
 * @param gamepad a gamepad.
 * @param button a button index (one of the SDL_GamepadButton values).
 * @returns true if the button is pressed, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GamepadHasButton
 * @sa SDL_GetGamepadAxis
 *
 * @from SDL_gamepad.h:1230 bool SDL_GetGamepadButton(SDL_Gamepad *gamepad, SDL_GamepadButton button);
 */
  getGamepadButton: lib.symbols.SDL_GetGamepadButton,

/**
 * Get the label of a button on a gamepad.
 *
 * @param type the type of gamepad to check.
 * @param button a button index (one of the SDL_GamepadButton values).
 * @returns the SDL_GamepadButtonLabel enum corresponding to the button label.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadButtonLabel
 *
 * @from SDL_gamepad.h:1243 SDL_GamepadButtonLabel SDL_GetGamepadButtonLabelForType(SDL_GamepadType type, SDL_GamepadButton button);
 */
  getGamepadButtonLabelForType: lib.symbols.SDL_GetGamepadButtonLabelForType,

/**
 * Get the label of a button on a gamepad.
 *
 * @param gamepad a gamepad.
 * @param button a button index (one of the SDL_GamepadButton values).
 * @returns the SDL_GamepadButtonLabel enum corresponding to the button label.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadButtonLabelForType
 *
 * @from SDL_gamepad.h:1256 SDL_GamepadButtonLabel SDL_GetGamepadButtonLabel(SDL_Gamepad *gamepad, SDL_GamepadButton button);
 */
  getGamepadButtonLabel: lib.symbols.SDL_GetGamepadButtonLabel,

/**
 * Get the number of touchpads on a gamepad.
 *
 * @param gamepad a gamepad.
 * @returns number of touchpads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumGamepadTouchpadFingers
 *
 * @from SDL_gamepad.h:1268 int SDL_GetNumGamepadTouchpads(SDL_Gamepad *gamepad);
 */
  getNumGamepadTouchpads: lib.symbols.SDL_GetNumGamepadTouchpads,

/**
 * Get the number of supported simultaneous fingers on a touchpad on a game
 * gamepad.
 *
 * @param gamepad a gamepad.
 * @param touchpad a touchpad.
 * @returns number of supported simultaneous fingers.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadTouchpadFinger
 * @sa SDL_GetNumGamepadTouchpads
 *
 * @from SDL_gamepad.h:1283 int SDL_GetNumGamepadTouchpadFingers(SDL_Gamepad *gamepad, int touchpad);
 */
  getNumGamepadTouchpadFingers: lib.symbols.SDL_GetNumGamepadTouchpadFingers,

/**
 * Get the current state of a finger on a touchpad on a gamepad.
 *
 * @param gamepad a gamepad.
 * @param touchpad a touchpad.
 * @param finger a finger.
 * @param down a pointer filled with true if the finger is down, false
 *             otherwise, may be NULL.
 * @param x a pointer filled with the x position, normalized 0 to 1, with the
 *          origin in the upper left, may be NULL.
 * @param y a pointer filled with the y position, normalized 0 to 1, with the
 *          origin in the upper left, may be NULL.
 * @param pressure a pointer filled with pressure value, may be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumGamepadTouchpadFingers
 *
 * @from SDL_gamepad.h:1305 bool SDL_GetGamepadTouchpadFinger(SDL_Gamepad *gamepad, int touchpad, int finger, bool *down, float *x, float *y, float *pressure);
 */
  getGamepadTouchpadFinger: lib.symbols.SDL_GetGamepadTouchpadFinger,

/**
 * Return whether a gamepad has a particular sensor.
 *
 * @param gamepad the gamepad to query.
 * @param type the type of sensor to query.
 * @returns true if the sensor exists, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadSensorData
 * @sa SDL_GetGamepadSensorDataRate
 * @sa SDL_SetGamepadSensorEnabled
 *
 * @from SDL_gamepad.h:1320 bool SDL_GamepadHasSensor(SDL_Gamepad *gamepad, SDL_SensorType type);
 */
  gamepadHasSensor: lib.symbols.SDL_GamepadHasSensor,

/**
 * Set whether data reporting for a gamepad sensor is enabled.
 *
 * @param gamepad the gamepad to update.
 * @param type the type of sensor to enable/disable.
 * @param enabled whether data reporting should be enabled.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GamepadHasSensor
 * @sa SDL_GamepadSensorEnabled
 *
 * @from SDL_gamepad.h:1336 bool SDL_SetGamepadSensorEnabled(SDL_Gamepad *gamepad, SDL_SensorType type, bool enabled);
 */
  setGamepadSensorEnabled: lib.symbols.SDL_SetGamepadSensorEnabled,

/**
 * Query whether sensor data reporting is enabled for a gamepad.
 *
 * @param gamepad the gamepad to query.
 * @param type the type of sensor to query.
 * @returns true if the sensor is enabled, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetGamepadSensorEnabled
 *
 * @from SDL_gamepad.h:1349 bool SDL_GamepadSensorEnabled(SDL_Gamepad *gamepad, SDL_SensorType type);
 */
  gamepadSensorEnabled: lib.symbols.SDL_GamepadSensorEnabled,

/**
 * Get the data rate (number of events per second) of a gamepad sensor.
 *
 * @param gamepad the gamepad to query.
 * @param type the type of sensor to query.
 * @returns the data rate, or 0.0f if the data rate is not available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:1360 float SDL_GetGamepadSensorDataRate(SDL_Gamepad *gamepad, SDL_SensorType type);
 */
  getGamepadSensorDataRate: lib.symbols.SDL_GetGamepadSensorDataRate,

/**
 * Get the current state of a gamepad sensor.
 *
 * The number of values and interpretation of the data is sensor dependent.
 * See SDL_sensor.h for the details for each type of sensor.
 *
 * @param gamepad the gamepad to query.
 * @param type the type of sensor to query.
 * @param data a pointer filled with the current sensor state.
 * @param num_values the number of values to write to data.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:1377 bool SDL_GetGamepadSensorData(SDL_Gamepad *gamepad, SDL_SensorType type, float *data, int num_values);
 */
  getGamepadSensorData: lib.symbols.SDL_GetGamepadSensorData,

/**
 * Start a rumble effect on a gamepad.
 *
 * Each call to this function cancels any previous rumble effect, and calling
 * it with 0 intensity stops any rumbling.
 *
 * This function requires you to process SDL events or call
 * SDL_UpdateJoysticks() to update rumble state.
 *
 * @param gamepad the gamepad to vibrate.
 * @param low_frequency_rumble the intensity of the low frequency (left)
 *                             rumble motor, from 0 to 0xFFFF.
 * @param high_frequency_rumble the intensity of the high frequency (right)
 *                              rumble motor, from 0 to 0xFFFF.
 * @param duration_ms the duration of the rumble effect, in milliseconds.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:1399 bool SDL_RumbleGamepad(SDL_Gamepad *gamepad, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
 */
  rumbleGamepad: lib.symbols.SDL_RumbleGamepad,

/**
 * Start a rumble effect in the gamepad's triggers.
 *
 * Each call to this function cancels any previous trigger rumble effect, and
 * calling it with 0 intensity stops any rumbling.
 *
 * Note that this is rumbling of the _triggers_ and not the gamepad as a
 * whole. This is currently only supported on Xbox One gamepads. If you want
 * the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.
 *
 * This function requires you to process SDL events or call
 * SDL_UpdateJoysticks() to update rumble state.
 *
 * @param gamepad the gamepad to vibrate.
 * @param left_rumble the intensity of the left trigger rumble motor, from 0
 *                    to 0xFFFF.
 * @param right_rumble the intensity of the right trigger rumble motor, from 0
 *                     to 0xFFFF.
 * @param duration_ms the duration of the rumble effect, in milliseconds.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RumbleGamepad
 *
 * @from SDL_gamepad.h:1427 bool SDL_RumbleGamepadTriggers(SDL_Gamepad *gamepad, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
 */
  rumbleGamepadTriggers: lib.symbols.SDL_RumbleGamepadTriggers,

/**
 * Update a gamepad's LED color.
 *
 * An example of a joystick LED is the light on the back of a PlayStation 4's
 * DualShock 4 controller.
 *
 * For gamepads with a single color LED, the maximum of the RGB values will be
 * used as the LED brightness.
 *
 * @param gamepad the gamepad to update.
 * @param red the intensity of the red LED.
 * @param green the intensity of the green LED.
 * @param blue the intensity of the blue LED.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:1447 bool SDL_SetGamepadLED(SDL_Gamepad *gamepad, Uint8 red, Uint8 green, Uint8 blue);
 */
  setGamepadLed: lib.symbols.SDL_SetGamepadLED,

/**
 * Send a gamepad specific effect packet.
 *
 * @param gamepad the gamepad to affect.
 * @param data the data to send to the gamepad.
 * @param size the size of the data to send to the gamepad.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gamepad.h:1460 bool SDL_SendGamepadEffect(SDL_Gamepad *gamepad, const void *data, int size);
 */
  sendGamepadEffect: lib.symbols.SDL_SendGamepadEffect,

/**
 * Close a gamepad previously opened with SDL_OpenGamepad().
 *
 * @param gamepad a gamepad identifier previously returned by
 *                SDL_OpenGamepad().
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenGamepad
 *
 * @from SDL_gamepad.h:1472 void SDL_CloseGamepad(SDL_Gamepad *gamepad);
 */
  closeGamepad: lib.symbols.SDL_CloseGamepad,

/**
 * Return the sfSymbolsName for a given button on a gamepad on Apple
 * platforms.
 *
 * @param gamepad the gamepad to query.
 * @param button a button on the gamepad.
 * @returns the sfSymbolsName or NULL if the name can't be found.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadAppleSFSymbolsNameForAxis
 *
 * @from SDL_gamepad.h:1486 const char * SDL_GetGamepadAppleSFSymbolsNameForButton(SDL_Gamepad *gamepad, SDL_GamepadButton button);
 */
  getGamepadAppleSfSymbolsNameForButton: lib.symbols.SDL_GetGamepadAppleSFSymbolsNameForButton,

/**
 * Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.
 *
 * @param gamepad the gamepad to query.
 * @param axis an axis on the gamepad.
 * @returns the sfSymbolsName or NULL if the name can't be found.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGamepadAppleSFSymbolsNameForButton
 *
 * @from SDL_gamepad.h:1499 const char * SDL_GetGamepadAppleSFSymbolsNameForAxis(SDL_Gamepad *gamepad, SDL_GamepadAxis axis);
 */
  getGamepadAppleSfSymbolsNameForAxis: lib.symbols.SDL_GetGamepadAppleSFSymbolsNameForAxis,



/*--- SDL_gpu ---*/

/**
 * @from SDL_gpu:822 SDL_GPU_TEXTUREUSAGE_
 */
  GPU_TEXTUREUSAGE: SDL_gpu_enums.GPU_TEXTUREUSAGE,

/**
 * @from SDL_gpu:902 SDL_GPU_BUFFERUSAGE_
 */
  GPU_BUFFERUSAGE: SDL_gpu_enums.GPU_BUFFERUSAGE,

/**
 * @from SDL_gpu:949 SDL_GPU_SHADERFORMAT_
 */
  GPU_SHADERFORMAT: SDL_gpu_enums.GPU_SHADERFORMAT,

/**
 * @from SDL_gpu:1177 SDL_GPU_COLORCOMPONENT_
 */
  GPU_COLORCOMPONENT: SDL_gpu_enums.GPU_COLORCOMPONENT,

/**
 * @from SDL_gpu:2179 SDL_PROP_GPU_DEVICE_CREATE_
 */
  PROP_GPU_DEVICE_CREATE: SDL_gpu_enums.PROP_GPU_DEVICE_CREATE,

/**
 * @from SDL_gpu:2497 SDL_PROP_GPU_TEXTURE_CREATE_
 */
  PROP_GPU_TEXTURE_CREATE: SDL_gpu_enums.PROP_GPU_TEXTURE_CREATE,

/**
 * Specifies the primitive topology of a graphics pipeline.
 *
 * If you are using POINTLIST you must include a point size output in the
 * vertex shader.
 *
 * - For HLSL compiling to SPIRV you must decorate a float output with
 *   [[vk::builtin("PointSize")]].
 * - For GLSL you must set the gl_PointSize builtin.
 * - For MSL you must include a float output with the [[point_size]]
 *   decorator.
 *
 * Note that sized point topology is totally unsupported on D3D12. Any size
 * other than 1 will be ignored. In general, you should avoid using point
 * topology for both compatibility and performance reasons. You WILL regret
 * using it.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:537 SDL_GPU_PRIMITIVETYPE_
 */
  GPU_PRIMITIVETYPE: SDL_gpu_enums.SDL_GPUPrimitiveType,

/**
 * Specifies how the contents of a texture attached to a render pass are
 * treated at the beginning of the render pass.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_BeginGPURenderPass
 *
 * @from SDL_gpu.h:554 SDL_GPU_LOADOP_
 */
  GPU_LOADOP: SDL_gpu_enums.SDL_GPULoadOp,

/**
 * Specifies how the contents of a texture attached to a render pass are
 * treated at the end of the render pass.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_BeginGPURenderPass
 *
 * @from SDL_gpu.h:569 SDL_GPU_STOREOP_
 */
  GPU_STOREOP: SDL_gpu_enums.SDL_GPUStoreOp,

/**
 * Specifies the size of elements in an index buffer.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:584 SDL_GPU_INDEXELEMENTSIZE_
 */
  GPU_INDEXELEMENTSIZE: SDL_gpu_enums.SDL_GPUIndexElementSize,

/**
 * Specifies the pixel format of a texture.
 *
 * Texture format support varies depending on driver, hardware, and usage
 * flags. In general, you should use SDL_GPUTextureSupportsFormat to query if
 * a format is supported before using it. However, there are a few guaranteed
 * formats.
 *
 * FIXME: Check universal support for 32-bit component formats FIXME: Check
 * universal support for SIMULTANEOUS_READ_WRITE
 *
 * For SAMPLER usage, the following formats are universally supported:
 *
 * - R8G8B8A8_UNORM
 * - B8G8R8A8_UNORM
 * - R8_UNORM
 * - R8_SNORM
 * - R8G8_UNORM
 * - R8G8_SNORM
 * - R8G8B8A8_SNORM
 * - R16_FLOAT
 * - R16G16_FLOAT
 * - R16G16B16A16_FLOAT
 * - R32_FLOAT
 * - R32G32_FLOAT
 * - R32G32B32A32_FLOAT
 * - R11G11B10_UFLOAT
 * - R8G8B8A8_UNORM_SRGB
 * - B8G8R8A8_UNORM_SRGB
 * - D16_UNORM
 *
 * For COLOR_TARGET usage, the following formats are universally supported:
 *
 * - R8G8B8A8_UNORM
 * - B8G8R8A8_UNORM
 * - R8_UNORM
 * - R16_FLOAT
 * - R16G16_FLOAT
 * - R16G16B16A16_FLOAT
 * - R32_FLOAT
 * - R32G32_FLOAT
 * - R32G32B32A32_FLOAT
 * - R8_UINT
 * - R8G8_UINT
 * - R8G8B8A8_UINT
 * - R16_UINT
 * - R16G16_UINT
 * - R16G16B16A16_UINT
 * - R8_INT
 * - R8G8_INT
 * - R8G8B8A8_INT
 * - R16_INT
 * - R16G16_INT
 * - R16G16B16A16_INT
 * - R8G8B8A8_UNORM_SRGB
 * - B8G8R8A8_UNORM_SRGB
 *
 * For STORAGE usages, the following formats are universally supported:
 *
 * - R8G8B8A8_UNORM
 * - R8G8B8A8_SNORM
 * - R16G16B16A16_FLOAT
 * - R32_FLOAT
 * - R32G32_FLOAT
 * - R32G32B32A32_FLOAT
 * - R8G8B8A8_UINT
 * - R16G16B16A16_UINT
 * - R8G8B8A8_INT
 * - R16G16B16A16_INT
 *
 * For DEPTH_STENCIL_TARGET usage, the following formats are universally
 * supported:
 *
 * - D16_UNORM
 * - Either (but not necessarily both!) D24_UNORM or D32_FLOAT
 * - Either (but not necessarily both!) D24_UNORM_S8_UINT or D32_FLOAT_S8_UINT
 *
 * Unless D16_UNORM is sufficient for your purposes, always check which of
 * D24/D32 is supported before creating a depth-stencil texture!
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUTexture
 * @sa SDL_GPUTextureSupportsFormat
 *
 * @from SDL_gpu.h:675 SDL_GPU_TEXTUREFORMAT_
 */
  GPU_TEXTUREFORMAT: SDL_gpu_enums.SDL_GPUTextureFormat,

/**
 * Specifies the type of a texture.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUTexture
 *
 * @from SDL_gpu.h:837 SDL_GPU_TEXTURETYPE_
 */
  GPU_TEXTURETYPE: SDL_gpu_enums.SDL_GPUTextureType,

/**
 * Specifies the sample count of a texture.
 *
 * Used in multisampling. Note that this value only applies when the texture
 * is used as a render target.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUTexture
 * @sa SDL_GPUTextureSupportsSampleCount
 *
 * @from SDL_gpu.h:857 SDL_GPU_SAMPLECOUNT_
 */
  GPU_SAMPLECOUNT: SDL_gpu_enums.SDL_GPUSampleCount,

/**
 * Specifies the face of a cube map.
 *
 * Can be passed in as the layer field in texture-related structs.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:873 SDL_GPU_CUBEMAPFACE_
 */
  GPU_CUBEMAPFACE: SDL_gpu_enums.SDL_GPUCubeMapFace,

/**
 * Specifies how a transfer buffer is intended to be used by the client.
 *
 * Note that mapping and copying FROM an upload transfer buffer or TO a
 * download transfer buffer is undefined behavior.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUTransferBuffer
 *
 * @from SDL_gpu.h:919 SDL_GPU_TRANSFERBUFFERUSAGE_
 */
  GPU_TRANSFERBUFFERUSAGE: SDL_gpu_enums.SDL_GPUTransferBufferUsage,

/**
 * Specifies which stage a shader program corresponds to.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:932 SDL_GPU_SHADERSTAGE_
 */
  GPU_SHADERSTAGE: SDL_gpu_enums.SDL_GPUShaderStage,

/**
 * Specifies the format of a vertex attribute.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:964 SDL_GPU_VERTEXELEMENTFORMAT_
 */
  GPU_VERTEXELEMENTFORMAT: SDL_gpu_enums.SDL_GPUVertexElementFormat,

/**
 * Specifies the rate at which vertex attributes are pulled from buffers.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:1030 SDL_GPU_VERTEXINPUTRATE_
 */
  GPU_VERTEXINPUTRATE: SDL_gpu_enums.SDL_GPUVertexInputRate,

/**
 * Specifies the fill mode of the graphics pipeline.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:1043 SDL_GPU_FILLMODE_
 */
  GPU_FILLMODE: SDL_gpu_enums.SDL_GPUFillMode,

/**
 * Specifies the facing direction in which triangle faces will be culled.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:1056 SDL_GPU_CULLMODE_
 */
  GPU_CULLMODE: SDL_gpu_enums.SDL_GPUCullMode,

/**
 * Specifies the vertex winding that will cause a triangle to be determined to
 * be front-facing.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:1071 SDL_GPU_FRONTFACE_
 */
  GPU_FRONTFACE: SDL_gpu_enums.SDL_GPUFrontFace,

/**
 * Specifies a comparison operator for depth, stencil and sampler operations.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:1084 SDL_GPU_COMPAREOP_
 */
  GPU_COMPAREOP: SDL_gpu_enums.SDL_GPUCompareOp,

/**
 * Specifies what happens to a stored stencil value if stencil tests fail or
 * pass.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:1105 SDL_GPU_STENCILOP_
 */
  GPU_STENCILOP: SDL_gpu_enums.SDL_GPUStencilOp,

/**
 * Specifies the operator to be used when pixels in a render target are
 * blended with existing pixels in the texture.
 *
 * The source color is the value written by the fragment shader. The
 * destination color is the value currently existing in the texture.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:1129 SDL_GPU_BLENDOP_
 */
  GPU_BLENDOP: SDL_gpu_enums.SDL_GPUBlendOp,

/**
 * Specifies a blending factor to be used when pixels in a render target are
 * blended with existing pixels in the texture.
 *
 * The source color is the value written by the fragment shader. The
 * destination color is the value currently existing in the texture.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:1150 SDL_GPU_BLENDFACTOR_
 */
  GPU_BLENDFACTOR: SDL_gpu_enums.SDL_GPUBlendFactor,

/**
 * Specifies a filter operation used by a sampler.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUSampler
 *
 * @from SDL_gpu.h:1189 SDL_GPU_FILTER_
 */
  GPU_FILTER: SDL_gpu_enums.SDL_GPUFilter,

/**
 * Specifies a mipmap mode used by a sampler.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUSampler
 *
 * @from SDL_gpu.h:1202 SDL_GPU_SAMPLERMIPMAPMODE_
 */
  GPU_SAMPLERMIPMAPMODE: SDL_gpu_enums.SDL_GPUSamplerMipmapMode,

/**
 * Specifies behavior of texture sampling when the coordinates exceed the 0-1
 * range.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUSampler
 *
 * @from SDL_gpu.h:1216 SDL_GPU_SAMPLERADDRESSMODE_
 */
  GPU_SAMPLERADDRESSMODE: SDL_gpu_enums.SDL_GPUSamplerAddressMode,

/**
 * Specifies the timing that will be used to present swapchain textures to the
 * OS.
 *
 * VSYNC mode will always be supported. IMMEDIATE and MAILBOX modes may not be
 * supported on certain systems.
 *
 * It is recommended to query SDL_WindowSupportsGPUPresentMode after claiming
 * the window if you wish to change the present mode to IMMEDIATE or MAILBOX.
 *
 * - VSYNC: Waits for vblank before presenting. No tearing is possible. If
 *   there is a pending image to present, the new image is enqueued for
 *   presentation. Disallows tearing at the cost of visual latency.
 * - IMMEDIATE: Immediately presents. Lowest latency option, but tearing may
 *   occur.
 * - MAILBOX: Waits for vblank before presenting. No tearing is possible. If
 *   there is a pending image to present, the pending image is replaced by the
 *   new image. Similar to VSYNC, but with reduced visual latency.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_SetGPUSwapchainParameters
 * @sa SDL_WindowSupportsGPUPresentMode
 * @sa SDL_WaitAndAcquireGPUSwapchainTexture
 *
 * @from SDL_gpu.h:1248 SDL_GPU_PRESENTMODE_
 */
  GPU_PRESENTMODE: SDL_gpu_enums.SDL_GPUPresentMode,

/**
 * Specifies the texture format and colorspace of the swapchain textures.
 *
 * SDR will always be supported. Other compositions may not be supported on
 * certain systems.
 *
 * It is recommended to query SDL_WindowSupportsGPUSwapchainComposition after
 * claiming the window if you wish to change the swapchain composition from
 * SDR.
 *
 * - SDR: B8G8R8A8 or R8G8B8A8 swapchain. Pixel values are in sRGB encoding.
 * - SDR_LINEAR: B8G8R8A8_SRGB or R8G8B8A8_SRGB swapchain. Pixel values are
 *   stored in memory in sRGB encoding but accessed in shaders in "linear
 *   sRGB" encoding which is sRGB but with a linear transfer function.
 * - HDR_EXTENDED_LINEAR: R16G16B16A16_FLOAT swapchain. Pixel values are in
 *   extended linear sRGB encoding and permits values outside of the [0, 1]
 *   range.
 * - HDR10_ST2084: A2R10G10B10 or A2B10G10R10 swapchain. Pixel values are in
 *   BT.2020 ST2084 (PQ) encoding.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_SetGPUSwapchainParameters
 * @sa SDL_WindowSupportsGPUSwapchainComposition
 * @sa SDL_WaitAndAcquireGPUSwapchainTexture
 *
 * @from SDL_gpu.h:1281 SDL_GPU_SWAPCHAINCOMPOSITION_
 */
  GPU_SWAPCHAINCOMPOSITION: SDL_gpu_enums.SDL_GPUSwapchainComposition,



/**
 * Checks for GPU runtime support.
 *
 * @param format_flags a bitflag indicating which shader formats the app is
 *                     able to provide.
 * @param name the preferred GPU driver, or NULL to let SDL pick the optimal
 *             driver.
 * @returns true if supported, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUDevice
 *
 * @from SDL_gpu.h:2093 bool SDL_GPUSupportsShaderFormats(    SDL_GPUShaderFormat format_flags,    const char *name);
 */
  gpuSupportsShaderFormats: lib.symbols.SDL_GPUSupportsShaderFormats,

/**
 * Checks for GPU runtime support.
 *
 * @param props the properties to use.
 * @returns true if supported, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUDeviceWithProperties
 *
 * @from SDL_gpu.h:2107 bool SDL_GPUSupportsProperties(    SDL_PropertiesID props);
 */
  gpuSupportsProperties: lib.symbols.SDL_GPUSupportsProperties,

/**
 * Creates a GPU context.
 *
 * @param format_flags a bitflag indicating which shader formats the app is
 *                     able to provide.
 * @param debug_mode enable debug mode properties and validations.
 * @param name the preferred GPU driver, or NULL to let SDL pick the optimal
 *             driver.
 * @returns a GPU context on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGPUShaderFormats
 * @sa SDL_GetGPUDeviceDriver
 * @sa SDL_DestroyGPUDevice
 * @sa SDL_GPUSupportsShaderFormats
 *
 * @from SDL_gpu.h:2128 SDL_GPUDevice * SDL_CreateGPUDevice(    SDL_GPUShaderFormat format_flags,    bool debug_mode,    const char *name);
 */
  createGpuDevice: lib.symbols.SDL_CreateGPUDevice,

/**
 * Creates a GPU context.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN`: enable debug mode
 *   properties and validations, defaults to true.
 * - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN`: enable to prefer
 *   energy efficiency over maximum GPU performance, defaults to false.
 * - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to
 *   use, if a specific one is desired.
 *
 * These are the current shader format properties:
 *
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN`: The app is able to
 *   provide shaders for an NDA platform.
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN`: The app is able to
 *   provide SPIR-V shaders if applicable.
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN`: The app is able to
 *   provide DXBC shaders if applicable
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN`: The app is able to
 *   provide DXIL shaders if applicable.
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN`: The app is able to
 *   provide MSL shaders if applicable.
 * - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN`: The app is able to
 *   provide Metal shader libraries if applicable.
 *
 * With the D3D12 renderer:
 *
 * - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to
 *   use for all vertex semantics, default is "TEXCOORD".
 *
 * @param props the properties to use.
 * @returns a GPU context on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGPUShaderFormats
 * @sa SDL_GetGPUDeviceDriver
 * @sa SDL_DestroyGPUDevice
 * @sa SDL_GPUSupportsProperties
 *
 * @from SDL_gpu.h:2176 SDL_GPUDevice * SDL_CreateGPUDeviceWithProperties(    SDL_PropertiesID props);
 */
  createGpuDeviceWithProperties: lib.symbols.SDL_CreateGPUDeviceWithProperties,

/**
 * Destroys a GPU context previously returned by SDL_CreateGPUDevice.
 *
 * @param device a GPU Context to destroy.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUDevice
 *
 * @from SDL_gpu.h:2199 void SDL_DestroyGPUDevice(SDL_GPUDevice *device);
 */
  destroyGpuDevice: lib.symbols.SDL_DestroyGPUDevice,

/**
 * Get the number of GPU drivers compiled into SDL.
 *
 * @returns the number of built in GPU drivers.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGPUDriver
 *
 * @from SDL_gpu.h:2210 int SDL_GetNumGPUDrivers(void);
 */
  getNumGpuDrivers: lib.symbols.SDL_GetNumGPUDrivers,

/**
 * Get the name of a built in GPU driver.
 *
 * The GPU drivers are presented in the order in which they are normally
 * checked during initialization.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "vulkan",
 * "metal" or "direct3d12". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @param index the index of a GPU driver.
 * @returns the name of the GPU driver with the given **index**.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumGPUDrivers
 *
 * @from SDL_gpu.h:2229 const char * SDL_GetGPUDriver(int index);
 */
  getGpuDriver: lib.symbols.SDL_GetGPUDriver,

/**
 * Returns the name of the backend used to create this GPU context.
 *
 * @param device a GPU context to query.
 * @returns the name of the device's driver, or NULL on error.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2239 const char * SDL_GetGPUDeviceDriver(SDL_GPUDevice *device);
 */
  getGpuDeviceDriver: lib.symbols.SDL_GetGPUDeviceDriver,

/**
 * Returns the supported shader formats for this GPU context.
 *
 * @param device a GPU context to query.
 * @returns a bitflag indicating which shader formats the driver is able to
 *          consume.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2250 SDL_GPUShaderFormat SDL_GetGPUShaderFormats(SDL_GPUDevice *device);
 */
  getGpuShaderFormats: lib.symbols.SDL_GetGPUShaderFormats,

/**
 * Creates a pipeline object to be used in a compute workflow.
 *
 * Shader resource bindings must be authored to follow a particular order
 * depending on the shader format.
 *
 * For SPIR-V shaders, use the following resource sets:
 *
 * - 0: Sampled textures, followed by read-only storage textures, followed by
 *   read-only storage buffers
 * - 1: Read-write storage textures, followed by read-write storage buffers
 * - 2: Uniform buffers
 *
 * For DXBC and DXIL shaders, use the following register order:
 *
 * - (t[n], space0): Sampled textures, followed by read-only storage textures,
 *   followed by read-only storage buffers
 * - (u[n], space1): Read-write storage textures, followed by read-write
 *   storage buffers
 * - (b[n], space2): Uniform buffers
 *
 * For MSL/metallib, use the following order:
 *
 * - [[buffer]]: Uniform buffers, followed by read-only storage buffers,
 *   followed by read-write storage buffers
 * - [[texture]]: Sampled textures, followed by read-only storage textures,
 *   followed by read-write storage textures
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be
 *   displayed in debugging tools.
 *
 * @param device a GPU Context.
 * @param createinfo a struct describing the state of the compute pipeline to
 *                   create.
 * @returns a compute pipeline object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BindGPUComputePipeline
 * @sa SDL_ReleaseGPUComputePipeline
 *
 * @from SDL_gpu.h:2299 SDL_GPUComputePipeline * SDL_CreateGPUComputePipeline(    SDL_GPUDevice *device,    const SDL_GPUComputePipelineCreateInfo *createinfo);
 */
  createGpuComputePipeline: lib.symbols.SDL_CreateGPUComputePipeline,

/**
 * Creates a pipeline object to be used in a graphics workflow.
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be
 *   displayed in debugging tools.
 *
 * @param device a GPU Context.
 * @param createinfo a struct describing the state of the graphics pipeline to
 *                   create.
 * @returns a graphics pipeline object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 * @sa SDL_BindGPUGraphicsPipeline
 * @sa SDL_ReleaseGPUGraphicsPipeline
 *
 * @from SDL_gpu.h:2326 SDL_GPUGraphicsPipeline * SDL_CreateGPUGraphicsPipeline(    SDL_GPUDevice *device,    const SDL_GPUGraphicsPipelineCreateInfo *createinfo);
 */
  createGpuGraphicsPipeline: lib.symbols.SDL_CreateGPUGraphicsPipeline,

/**
 * Creates a sampler object to be used when binding textures in a graphics
 * workflow.
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed
 *   in debugging tools.
 *
 * @param device a GPU Context.
 * @param createinfo a struct describing the state of the sampler to create.
 * @returns a sampler object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BindGPUVertexSamplers
 * @sa SDL_BindGPUFragmentSamplers
 * @sa SDL_ReleaseGPUSampler
 *
 * @from SDL_gpu.h:2353 SDL_GPUSampler * SDL_CreateGPUSampler(    SDL_GPUDevice *device,    const SDL_GPUSamplerCreateInfo *createinfo);
 */
  createGpuSampler: lib.symbols.SDL_CreateGPUSampler,

/**
 * Creates a shader to be used when creating a graphics pipeline.
 *
 * Shader resource bindings must be authored to follow a particular order
 * depending on the shader format.
 *
 * For SPIR-V shaders, use the following resource sets:
 *
 * For vertex shaders:
 *
 * - 0: Sampled textures, followed by storage textures, followed by storage
 *   buffers
 * - 1: Uniform buffers
 *
 * For fragment shaders:
 *
 * - 2: Sampled textures, followed by storage textures, followed by storage
 *   buffers
 * - 3: Uniform buffers
 *
 * For DXBC and DXIL shaders, use the following register order:
 *
 * For vertex shaders:
 *
 * - (t[n], space0): Sampled textures, followed by storage textures, followed
 *   by storage buffers
 * - (s[n], space0): Samplers with indices corresponding to the sampled
 *   textures
 * - (b[n], space1): Uniform buffers
 *
 * For pixel shaders:
 *
 * - (t[n], space2): Sampled textures, followed by storage textures, followed
 *   by storage buffers
 * - (s[n], space2): Samplers with indices corresponding to the sampled
 *   textures
 * - (b[n], space3): Uniform buffers
 *
 * For MSL/metallib, use the following order:
 *
 * - [[texture]]: Sampled textures, followed by storage textures
 * - [[sampler]]: Samplers with indices corresponding to the sampled textures
 * - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0
 *   is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.
 *   Rather than manually authoring vertex buffer indices, use the
 *   [[stage_in]] attribute which will automatically use the vertex input
 *   information from the SDL_GPUGraphicsPipeline.
 *
 * Shader semantics other than system-value semantics do not matter in D3D12
 * and for ease of use the SDL implementation assumes that non system-value
 * semantics will all be TEXCOORD. If you are using HLSL as the shader source
 * language, your vertex semantics should start at TEXCOORD0 and increment
 * like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic
 * prefix to something other than TEXCOORD you can use
 * SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with
 * SDL_CreateGPUDeviceWithProperties().
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in
 *   debugging tools.
 *
 * @param device a GPU Context.
 * @param createinfo a struct describing the state of the shader to create.
 * @returns a shader object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUGraphicsPipeline
 * @sa SDL_ReleaseGPUShader
 *
 * @from SDL_gpu.h:2432 SDL_GPUShader * SDL_CreateGPUShader(    SDL_GPUDevice *device,    const SDL_GPUShaderCreateInfo *createinfo);
 */
  createGpuShader: lib.symbols.SDL_CreateGPUShader,

/**
 * Creates a texture object to be used in graphics or compute workflows.
 *
 * The contents of this texture are undefined until data is written to the
 * texture.
 *
 * Note that certain combinations of usage flags are invalid. For example, a
 * texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.
 *
 * If you request a sample count higher than the hardware supports, the
 * implementation will automatically fall back to the highest available sample
 * count.
 *
 * There are optional properties that can be provided through
 * SDL_GPUTextureCreateInfo's `props`. These are the supported properties:
 *
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if
 *   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
 *   to a color with this red intensity. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if
 *   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
 *   to a color with this green intensity. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if
 *   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
 *   to a color with this blue intensity. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if
 *   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
 *   to a color with this alpha intensity. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)
 *   if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear
 *   the texture to a depth of this value. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8`: (Direct3D 12
 *   only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,
 *   clear the texture to a stencil of this value. Defaults to zero.
 * - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed
 *   in debugging tools.
 *
 * @param device a GPU Context.
 * @param createinfo a struct describing the state of the texture to create.
 * @returns a texture object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UploadToGPUTexture
 * @sa SDL_DownloadFromGPUTexture
 * @sa SDL_BindGPUVertexSamplers
 * @sa SDL_BindGPUVertexStorageTextures
 * @sa SDL_BindGPUFragmentSamplers
 * @sa SDL_BindGPUFragmentStorageTextures
 * @sa SDL_BindGPUComputeStorageTextures
 * @sa SDL_BlitGPUTexture
 * @sa SDL_ReleaseGPUTexture
 * @sa SDL_GPUTextureSupportsFormat
 *
 * @from SDL_gpu.h:2493 SDL_GPUTexture * SDL_CreateGPUTexture(    SDL_GPUDevice *device,    const SDL_GPUTextureCreateInfo *createinfo);
 */
  createGpuTexture: lib.symbols.SDL_CreateGPUTexture,

/**
 * Creates a buffer object to be used in graphics or compute workflows.
 *
 * The contents of this buffer are undefined until data is written to the
 * buffer.
 *
 * Note that certain combinations of usage flags are invalid. For example, a
 * buffer cannot have both the VERTEX and INDEX flags.
 *
 * If you use a STORAGE flag, the data in the buffer must respect std140
 * layout conventions. In practical terms this means you must ensure that vec3
 * and vec4 fields are 16-byte aligned.
 *
 * For better understanding of underlying concepts and memory management with
 * SDL GPU API, you may refer
 * [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)
 * .
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in
 *   debugging tools.
 *
 * @param device a GPU Context.
 * @param createinfo a struct describing the state of the buffer to create.
 * @returns a buffer object on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UploadToGPUBuffer
 * @sa SDL_DownloadFromGPUBuffer
 * @sa SDL_CopyGPUBufferToBuffer
 * @sa SDL_BindGPUVertexBuffers
 * @sa SDL_BindGPUIndexBuffer
 * @sa SDL_BindGPUVertexStorageBuffers
 * @sa SDL_BindGPUFragmentStorageBuffers
 * @sa SDL_DrawGPUPrimitivesIndirect
 * @sa SDL_DrawGPUIndexedPrimitivesIndirect
 * @sa SDL_BindGPUComputeStorageBuffers
 * @sa SDL_DispatchGPUComputeIndirect
 * @sa SDL_ReleaseGPUBuffer
 *
 * @from SDL_gpu.h:2549 SDL_GPUBuffer * SDL_CreateGPUBuffer(    SDL_GPUDevice *device,    const SDL_GPUBufferCreateInfo *createinfo);
 */
  createGpuBuffer: lib.symbols.SDL_CreateGPUBuffer,

/**
 * Creates a transfer buffer to be used when uploading to or downloading from
 * graphics resources.
 *
 * Download buffers can be particularly expensive to create, so it is good
 * practice to reuse them if data will be downloaded regularly.
 *
 * There are optional properties that can be provided through `props`. These
 * are the supported properties:
 *
 * - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be
 *   displayed in debugging tools.
 *
 * @param device a GPU Context.
 * @param createinfo a struct describing the state of the transfer buffer to
 *                   create.
 * @returns a transfer buffer on success, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UploadToGPUBuffer
 * @sa SDL_DownloadFromGPUBuffer
 * @sa SDL_UploadToGPUTexture
 * @sa SDL_DownloadFromGPUTexture
 * @sa SDL_ReleaseGPUTransferBuffer
 *
 * @from SDL_gpu.h:2582 SDL_GPUTransferBuffer * SDL_CreateGPUTransferBuffer(    SDL_GPUDevice *device,    const SDL_GPUTransferBufferCreateInfo *createinfo);
 */
  createGpuTransferBuffer: lib.symbols.SDL_CreateGPUTransferBuffer,

/**
 * Sets an arbitrary string constant to label a buffer.
 *
 * You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with
 * SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.
 *
 * @param device a GPU Context.
 * @param buffer a buffer to attach the name to.
 * @param text a UTF-8 string constant to mark as the name of the buffer.
 *
 * @threadsafety This function is not thread safe, you must make sure the
 *               buffer is not simultaneously used by any other thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUBuffer
 *
 * @from SDL_gpu.h:2607 void SDL_SetGPUBufferName(    SDL_GPUDevice *device,    SDL_GPUBuffer *buffer,    const char *text);
 */
  setGpuBufferName: lib.symbols.SDL_SetGPUBufferName,

/**
 * Sets an arbitrary string constant to label a texture.
 *
 * You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with
 * SDL_CreateGPUTexture instead of this function to avoid thread safety
 * issues.
 *
 * @param device a GPU Context.
 * @param texture a texture to attach the name to.
 * @param text a UTF-8 string constant to mark as the name of the texture.
 *
 * @threadsafety This function is not thread safe, you must make sure the
 *               texture is not simultaneously used by any other thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUTexture
 *
 * @from SDL_gpu.h:2630 void SDL_SetGPUTextureName(    SDL_GPUDevice *device,    SDL_GPUTexture *texture,    const char *text);
 */
  setGpuTextureName: lib.symbols.SDL_SetGPUTextureName,

/**
 * Inserts an arbitrary string label into the command buffer callstream.
 *
 * Useful for debugging.
 *
 * @param command_buffer a command buffer.
 * @param text a UTF-8 string constant to insert as the label.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2645 void SDL_InsertGPUDebugLabel(    SDL_GPUCommandBuffer *command_buffer,    const char *text);
 */
  insertGpuDebugLabel: lib.symbols.SDL_InsertGPUDebugLabel,

/**
 * Begins a debug group with an arbitary name.
 *
 * Used for denoting groups of calls when viewing the command buffer
 * callstream in a graphics debugging tool.
 *
 * Each call to SDL_PushGPUDebugGroup must have a corresponding call to
 * SDL_PopGPUDebugGroup.
 *
 * On some backends (e.g. Metal), pushing a debug group during a
 * render/blit/compute pass will create a group that is scoped to the native
 * pass rather than the command buffer. For best results, if you push a debug
 * group during a pass, always pop it in the same pass.
 *
 * @param command_buffer a command buffer.
 * @param name a UTF-8 string constant that names the group.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PopGPUDebugGroup
 *
 * @from SDL_gpu.h:2670 void SDL_PushGPUDebugGroup(    SDL_GPUCommandBuffer *command_buffer,    const char *name);
 */
  pushGpuDebugGroup: lib.symbols.SDL_PushGPUDebugGroup,

/**
 * Ends the most-recently pushed debug group.
 *
 * @param command_buffer a command buffer.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PushGPUDebugGroup
 *
 * @from SDL_gpu.h:2683 void SDL_PopGPUDebugGroup(    SDL_GPUCommandBuffer *command_buffer);
 */
  popGpuDebugGroup: lib.symbols.SDL_PopGPUDebugGroup,

/**
 * Frees the given texture as soon as it is safe to do so.
 *
 * You must not reference the texture after calling this function.
 *
 * @param device a GPU context.
 * @param texture a texture to be destroyed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2698 void SDL_ReleaseGPUTexture(    SDL_GPUDevice *device,    SDL_GPUTexture *texture);
 */
  releaseGpuTexture: lib.symbols.SDL_ReleaseGPUTexture,

/**
 * Frees the given sampler as soon as it is safe to do so.
 *
 * You must not reference the sampler after calling this function.
 *
 * @param device a GPU context.
 * @param sampler a sampler to be destroyed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2712 void SDL_ReleaseGPUSampler(    SDL_GPUDevice *device,    SDL_GPUSampler *sampler);
 */
  releaseGpuSampler: lib.symbols.SDL_ReleaseGPUSampler,

/**
 * Frees the given buffer as soon as it is safe to do so.
 *
 * You must not reference the buffer after calling this function.
 *
 * @param device a GPU context.
 * @param buffer a buffer to be destroyed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2726 void SDL_ReleaseGPUBuffer(    SDL_GPUDevice *device,    SDL_GPUBuffer *buffer);
 */
  releaseGpuBuffer: lib.symbols.SDL_ReleaseGPUBuffer,

/**
 * Frees the given transfer buffer as soon as it is safe to do so.
 *
 * You must not reference the transfer buffer after calling this function.
 *
 * @param device a GPU context.
 * @param transfer_buffer a transfer buffer to be destroyed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2740 void SDL_ReleaseGPUTransferBuffer(    SDL_GPUDevice *device,    SDL_GPUTransferBuffer *transfer_buffer);
 */
  releaseGpuTransferBuffer: lib.symbols.SDL_ReleaseGPUTransferBuffer,

/**
 * Frees the given compute pipeline as soon as it is safe to do so.
 *
 * You must not reference the compute pipeline after calling this function.
 *
 * @param device a GPU context.
 * @param compute_pipeline a compute pipeline to be destroyed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2754 void SDL_ReleaseGPUComputePipeline(    SDL_GPUDevice *device,    SDL_GPUComputePipeline *compute_pipeline);
 */
  releaseGpuComputePipeline: lib.symbols.SDL_ReleaseGPUComputePipeline,

/**
 * Frees the given shader as soon as it is safe to do so.
 *
 * You must not reference the shader after calling this function.
 *
 * @param device a GPU context.
 * @param shader a shader to be destroyed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2768 void SDL_ReleaseGPUShader(    SDL_GPUDevice *device,    SDL_GPUShader *shader);
 */
  releaseGpuShader: lib.symbols.SDL_ReleaseGPUShader,

/**
 * Frees the given graphics pipeline as soon as it is safe to do so.
 *
 * You must not reference the graphics pipeline after calling this function.
 *
 * @param device a GPU context.
 * @param graphics_pipeline a graphics pipeline to be destroyed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2782 void SDL_ReleaseGPUGraphicsPipeline(    SDL_GPUDevice *device,    SDL_GPUGraphicsPipeline *graphics_pipeline);
 */
  releaseGpuGraphicsPipeline: lib.symbols.SDL_ReleaseGPUGraphicsPipeline,

/**
 * Acquire a command buffer.
 *
 * This command buffer is managed by the implementation and should not be
 * freed by the user. The command buffer may only be used on the thread it was
 * acquired on. The command buffer should be submitted on the thread it was
 * acquired on.
 *
 * It is valid to acquire multiple command buffers on the same thread at once.
 * In fact a common design pattern is to acquire two command buffers per frame
 * where one is dedicated to render and compute passes and the other is
 * dedicated to copy passes and other preparatory work such as generating
 * mipmaps. Interleaving commands between the two command buffers reduces the
 * total amount of passes overall which improves rendering performance.
 *
 * @param device a GPU context.
 * @returns a command buffer, or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SubmitGPUCommandBuffer
 * @sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *
 * @from SDL_gpu.h:2810 SDL_GPUCommandBuffer * SDL_AcquireGPUCommandBuffer(    SDL_GPUDevice *device);
 */
  acquireGpuCommandBuffer: lib.symbols.SDL_AcquireGPUCommandBuffer,

/**
 * Pushes data to a vertex uniform slot on the command buffer.
 *
 * Subsequent draw calls will use this uniform data.
 *
 * The data being pushed must respect std140 layout conventions. In practical
 * terms this means you must ensure that vec3 and vec4 fields are 16-byte
 * aligned.
 *
 * @param command_buffer a command buffer.
 * @param slot_index the vertex uniform slot to push data to.
 * @param data client data to write.
 * @param length the length of the data to write.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2831 void SDL_PushGPUVertexUniformData(    SDL_GPUCommandBuffer *command_buffer,    Uint32 slot_index,    const void *data,    Uint32 length);
 */
  pushGpuVertexUniformData: lib.symbols.SDL_PushGPUVertexUniformData,

/**
 * Pushes data to a fragment uniform slot on the command buffer.
 *
 * Subsequent draw calls will use this uniform data.
 *
 * The data being pushed must respect std140 layout conventions. In practical
 * terms this means you must ensure that vec3 and vec4 fields are 16-byte
 * aligned.
 *
 * @param command_buffer a command buffer.
 * @param slot_index the fragment uniform slot to push data to.
 * @param data client data to write.
 * @param length the length of the data to write.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2853 void SDL_PushGPUFragmentUniformData(    SDL_GPUCommandBuffer *command_buffer,    Uint32 slot_index,    const void *data,    Uint32 length);
 */
  pushGpuFragmentUniformData: lib.symbols.SDL_PushGPUFragmentUniformData,

/**
 * Pushes data to a uniform slot on the command buffer.
 *
 * Subsequent draw calls will use this uniform data.
 *
 * The data being pushed must respect std140 layout conventions. In practical
 * terms this means you must ensure that vec3 and vec4 fields are 16-byte
 * aligned.
 *
 * @param command_buffer a command buffer.
 * @param slot_index the uniform slot to push data to.
 * @param data client data to write.
 * @param length the length of the data to write.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2875 void SDL_PushGPUComputeUniformData(    SDL_GPUCommandBuffer *command_buffer,    Uint32 slot_index,    const void *data,    Uint32 length);
 */
  pushGpuComputeUniformData: lib.symbols.SDL_PushGPUComputeUniformData,

/**
 * Begins a render pass on a command buffer.
 *
 * A render pass consists of a set of texture subresources (or depth slices in
 * the 3D texture case) which will be rendered to during the render pass,
 * along with corresponding clear values and load/store operations. All
 * operations related to graphics pipelines must take place inside of a render
 * pass. A default viewport and scissor state are automatically set when this
 * is called. You cannot begin another render pass, or begin a compute pass or
 * copy pass until you have ended the render pass.
 *
 * @param command_buffer a command buffer.
 * @param color_target_infos an array of texture subresources with
 *                           corresponding clear values and load/store ops.
 * @param num_color_targets the number of color targets in the
 *                          color_target_infos array.
 * @param depth_stencil_target_info a texture subresource with corresponding
 *                                  clear value and load/store ops, may be
 *                                  NULL.
 * @returns a render pass handle.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_EndGPURenderPass
 *
 * @from SDL_gpu.h:2908 SDL_GPURenderPass * SDL_BeginGPURenderPass(    SDL_GPUCommandBuffer *command_buffer,    const SDL_GPUColorTargetInfo *color_target_infos,    Uint32 num_color_targets,    const SDL_GPUDepthStencilTargetInfo *depth_stencil_target_info);
 */
  beginGpuRenderPass: lib.symbols.SDL_BeginGPURenderPass,

/**
 * Binds a graphics pipeline on a render pass to be used in rendering.
 *
 * A graphics pipeline must be bound before making any draw calls.
 *
 * @param render_pass a render pass handle.
 * @param graphics_pipeline the graphics pipeline to bind.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2924 void SDL_BindGPUGraphicsPipeline(    SDL_GPURenderPass *render_pass,    SDL_GPUGraphicsPipeline *graphics_pipeline);
 */
  bindGpuGraphicsPipeline: lib.symbols.SDL_BindGPUGraphicsPipeline,

/**
 * Sets the current viewport state on a command buffer.
 *
 * @param render_pass a render pass handle.
 * @param viewport the viewport to set.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2936 void SDL_SetGPUViewport(    SDL_GPURenderPass *render_pass,    const SDL_GPUViewport *viewport);
 */
  setGpuViewport: lib.symbols.SDL_SetGPUViewport,

/**
 * Sets the current scissor state on a command buffer.
 *
 * @param render_pass a render pass handle.
 * @param scissor the scissor area to set.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2948 void SDL_SetGPUScissor(    SDL_GPURenderPass *render_pass,    const SDL_Rect *scissor);
 */
  setGpuScissor: lib.symbols.SDL_SetGPUScissor,

/**
 * Sets the current stencil reference value on a command buffer.
 *
 * @param render_pass a render pass handle.
 * @param reference the stencil reference value to set.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2975 void SDL_SetGPUStencilReference(    SDL_GPURenderPass *render_pass,    Uint8 reference);
 */
  setGpuStencilReference: lib.symbols.SDL_SetGPUStencilReference,

/**
 * Binds vertex buffers on a command buffer for use with subsequent draw
 * calls.
 *
 * @param render_pass a render pass handle.
 * @param first_slot the vertex buffer slot to begin binding from.
 * @param bindings an array of SDL_GPUBufferBinding structs containing vertex
 *                 buffers and offset values.
 * @param num_bindings the number of bindings in the bindings array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:2991 void SDL_BindGPUVertexBuffers(    SDL_GPURenderPass *render_pass,    Uint32 first_slot,    const SDL_GPUBufferBinding *bindings,    Uint32 num_bindings);
 */
  bindGpuVertexBuffers: lib.symbols.SDL_BindGPUVertexBuffers,

/**
 * Binds an index buffer on a command buffer for use with subsequent draw
 * calls.
 *
 * @param render_pass a render pass handle.
 * @param binding a pointer to a struct containing an index buffer and offset.
 * @param index_element_size whether the index values in the buffer are 16- or
 *                           32-bit.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3008 void SDL_BindGPUIndexBuffer(    SDL_GPURenderPass *render_pass,    const SDL_GPUBufferBinding *binding,    SDL_GPUIndexElementSize index_element_size);
 */
  bindGpuIndexBuffer: lib.symbols.SDL_BindGPUIndexBuffer,

/**
 * Binds texture-sampler pairs for use on the vertex shader.
 *
 * The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param render_pass a render pass handle.
 * @param first_slot the vertex sampler slot to begin binding from.
 * @param texture_sampler_bindings an array of texture-sampler binding
 *                                 structs.
 * @param num_bindings the number of texture-sampler pairs to bind from the
 *                     array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3032 void SDL_BindGPUVertexSamplers(    SDL_GPURenderPass *render_pass,    Uint32 first_slot,    const SDL_GPUTextureSamplerBinding *texture_sampler_bindings,    Uint32 num_bindings);
 */
  bindGpuVertexSamplers: lib.symbols.SDL_BindGPUVertexSamplers,

/**
 * Binds storage textures for use on the vertex shader.
 *
 * These textures must have been created with
 * SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param render_pass a render pass handle.
 * @param first_slot the vertex storage texture slot to begin binding from.
 * @param storage_textures an array of storage textures.
 * @param num_bindings the number of storage texture to bind from the array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3056 void SDL_BindGPUVertexStorageTextures(    SDL_GPURenderPass *render_pass,    Uint32 first_slot,    SDL_GPUTexture *const *storage_textures,    Uint32 num_bindings);
 */
  bindGpuVertexStorageTextures: lib.symbols.SDL_BindGPUVertexStorageTextures,

/**
 * Binds storage buffers for use on the vertex shader.
 *
 * These buffers must have been created with
 * SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param render_pass a render pass handle.
 * @param first_slot the vertex storage buffer slot to begin binding from.
 * @param storage_buffers an array of buffers.
 * @param num_bindings the number of buffers to bind from the array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3080 void SDL_BindGPUVertexStorageBuffers(    SDL_GPURenderPass *render_pass,    Uint32 first_slot,    SDL_GPUBuffer *const *storage_buffers,    Uint32 num_bindings);
 */
  bindGpuVertexStorageBuffers: lib.symbols.SDL_BindGPUVertexStorageBuffers,

/**
 * Binds texture-sampler pairs for use on the fragment shader.
 *
 * The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param render_pass a render pass handle.
 * @param first_slot the fragment sampler slot to begin binding from.
 * @param texture_sampler_bindings an array of texture-sampler binding
 *                                 structs.
 * @param num_bindings the number of texture-sampler pairs to bind from the
 *                     array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3105 void SDL_BindGPUFragmentSamplers(    SDL_GPURenderPass *render_pass,    Uint32 first_slot,    const SDL_GPUTextureSamplerBinding *texture_sampler_bindings,    Uint32 num_bindings);
 */
  bindGpuFragmentSamplers: lib.symbols.SDL_BindGPUFragmentSamplers,

/**
 * Binds storage textures for use on the fragment shader.
 *
 * These textures must have been created with
 * SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param render_pass a render pass handle.
 * @param first_slot the fragment storage texture slot to begin binding from.
 * @param storage_textures an array of storage textures.
 * @param num_bindings the number of storage textures to bind from the array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3129 void SDL_BindGPUFragmentStorageTextures(    SDL_GPURenderPass *render_pass,    Uint32 first_slot,    SDL_GPUTexture *const *storage_textures,    Uint32 num_bindings);
 */
  bindGpuFragmentStorageTextures: lib.symbols.SDL_BindGPUFragmentStorageTextures,

/**
 * Binds storage buffers for use on the fragment shader.
 *
 * These buffers must have been created with
 * SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param render_pass a render pass handle.
 * @param first_slot the fragment storage buffer slot to begin binding from.
 * @param storage_buffers an array of storage buffers.
 * @param num_bindings the number of storage buffers to bind from the array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3153 void SDL_BindGPUFragmentStorageBuffers(    SDL_GPURenderPass *render_pass,    Uint32 first_slot,    SDL_GPUBuffer *const *storage_buffers,    Uint32 num_bindings);
 */
  bindGpuFragmentStorageBuffers: lib.symbols.SDL_BindGPUFragmentStorageBuffers,

/**
 * Draws data using bound graphics state with an index buffer and instancing
 * enabled.
 *
 * You must not call this function before binding a graphics pipeline.
 *
 * Note that the `first_vertex` and `first_instance` parameters are NOT
 * compatible with built-in vertex/instance ID variables in shaders (for
 * example, SV_VertexID); GPU APIs and shader languages do not define these
 * built-in variables consistently, so if your shader depends on them, the
 * only way to keep behavior consistent and portable is to always pass 0 for
 * the correlating parameter in the draw calls.
 *
 * @param render_pass a render pass handle.
 * @param num_indices the number of indices to draw per instance.
 * @param num_instances the number of instances to draw.
 * @param first_index the starting index within the index buffer.
 * @param vertex_offset value added to vertex index before indexing into the
 *                      vertex buffer.
 * @param first_instance the ID of the first instance to draw.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3184 void SDL_DrawGPUIndexedPrimitives(    SDL_GPURenderPass *render_pass,    Uint32 num_indices,    Uint32 num_instances,    Uint32 first_index,    Sint32 vertex_offset,    Uint32 first_instance);
 */
  drawGpuIndexedPrimitives: lib.symbols.SDL_DrawGPUIndexedPrimitives,

/**
 * Draws data using bound graphics state.
 *
 * You must not call this function before binding a graphics pipeline.
 *
 * Note that the `first_vertex` and `first_instance` parameters are NOT
 * compatible with built-in vertex/instance ID variables in shaders (for
 * example, SV_VertexID); GPU APIs and shader languages do not define these
 * built-in variables consistently, so if your shader depends on them, the
 * only way to keep behavior consistent and portable is to always pass 0 for
 * the correlating parameter in the draw calls.
 *
 * @param render_pass a render pass handle.
 * @param num_vertices the number of vertices to draw.
 * @param num_instances the number of instances that will be drawn.
 * @param first_vertex the index of the first vertex to draw.
 * @param first_instance the ID of the first instance to draw.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3212 void SDL_DrawGPUPrimitives(    SDL_GPURenderPass *render_pass,    Uint32 num_vertices,    Uint32 num_instances,    Uint32 first_vertex,    Uint32 first_instance);
 */
  drawGpuPrimitives: lib.symbols.SDL_DrawGPUPrimitives,

/**
 * Draws data using bound graphics state and with draw parameters set from a
 * buffer.
 *
 * The buffer must consist of tightly-packed draw parameter sets that each
 * match the layout of SDL_GPUIndirectDrawCommand. You must not call this
 * function before binding a graphics pipeline.
 *
 * @param render_pass a render pass handle.
 * @param buffer a buffer containing draw parameters.
 * @param offset the offset to start reading from the draw buffer.
 * @param draw_count the number of draw parameter sets that should be read
 *                   from the draw buffer.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3235 void SDL_DrawGPUPrimitivesIndirect(    SDL_GPURenderPass *render_pass,    SDL_GPUBuffer *buffer,    Uint32 offset,    Uint32 draw_count);
 */
  drawGpuPrimitivesIndirect: lib.symbols.SDL_DrawGPUPrimitivesIndirect,

/**
 * Draws data using bound graphics state with an index buffer enabled and with
 * draw parameters set from a buffer.
 *
 * The buffer must consist of tightly-packed draw parameter sets that each
 * match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call
 * this function before binding a graphics pipeline.
 *
 * @param render_pass a render pass handle.
 * @param buffer a buffer containing draw parameters.
 * @param offset the offset to start reading from the draw buffer.
 * @param draw_count the number of draw parameter sets that should be read
 *                   from the draw buffer.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3257 void SDL_DrawGPUIndexedPrimitivesIndirect(    SDL_GPURenderPass *render_pass,    SDL_GPUBuffer *buffer,    Uint32 offset,    Uint32 draw_count);
 */
  drawGpuIndexedPrimitivesIndirect: lib.symbols.SDL_DrawGPUIndexedPrimitivesIndirect,

/**
 * Ends the given render pass.
 *
 * All bound graphics state on the render pass command buffer is unset. The
 * render pass handle is now invalid.
 *
 * @param render_pass a render pass handle.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3273 void SDL_EndGPURenderPass(    SDL_GPURenderPass *render_pass);
 */
  endGpuRenderPass: lib.symbols.SDL_EndGPURenderPass,

/**
 * Begins a compute pass on a command buffer.
 *
 * A compute pass is defined by a set of texture subresources and buffers that
 * may be written to by compute pipelines. These textures and buffers must
 * have been created with the COMPUTE_STORAGE_WRITE bit or the
 * COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture
 * with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the
 * texture in the compute pass. All operations related to compute pipelines
 * must take place inside of a compute pass. You must not begin another
 * compute pass, or a render pass or copy pass before ending the compute pass.
 *
 * A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT
 * implicitly synchronized. This means you may cause data races by both
 * reading and writing a resource region in a compute pass, or by writing
 * multiple times to a resource region. If your compute work depends on
 * reading the completed output from a previous dispatch, you MUST end the
 * current compute pass and begin a new one before you can safely access the
 * data. Otherwise you will receive unexpected results. Reading and writing a
 * texture in the same compute pass is only supported by specific texture
 * formats. Make sure you check the format support!
 *
 * @param command_buffer a command buffer.
 * @param storage_texture_bindings an array of writeable storage texture
 *                                 binding structs.
 * @param num_storage_texture_bindings the number of storage textures to bind
 *                                     from the array.
 * @param storage_buffer_bindings an array of writeable storage buffer binding
 *                                structs.
 * @param num_storage_buffer_bindings the number of storage buffers to bind
 *                                    from the array.
 * @returns a compute pass handle.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_EndGPUComputePass
 *
 * @from SDL_gpu.h:3315 SDL_GPUComputePass * SDL_BeginGPUComputePass(    SDL_GPUCommandBuffer *command_buffer,    const SDL_GPUStorageTextureReadWriteBinding *storage_texture_bindings,    Uint32 num_storage_texture_bindings,    const SDL_GPUStorageBufferReadWriteBinding *storage_buffer_bindings,    Uint32 num_storage_buffer_bindings);
 */
  beginGpuComputePass: lib.symbols.SDL_BeginGPUComputePass,

/**
 * Binds a compute pipeline on a command buffer for use in compute dispatch.
 *
 * @param compute_pass a compute pass handle.
 * @param compute_pipeline a compute pipeline to bind.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3330 void SDL_BindGPUComputePipeline(    SDL_GPUComputePass *compute_pass,    SDL_GPUComputePipeline *compute_pipeline);
 */
  bindGpuComputePipeline: lib.symbols.SDL_BindGPUComputePipeline,

/**
 * Binds texture-sampler pairs for use on the compute shader.
 *
 * The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param compute_pass a compute pass handle.
 * @param first_slot the compute sampler slot to begin binding from.
 * @param texture_sampler_bindings an array of texture-sampler binding
 *                                 structs.
 * @param num_bindings the number of texture-sampler bindings to bind from the
 *                     array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3353 void SDL_BindGPUComputeSamplers(    SDL_GPUComputePass *compute_pass,    Uint32 first_slot,    const SDL_GPUTextureSamplerBinding *texture_sampler_bindings,    Uint32 num_bindings);
 */
  bindGpuComputeSamplers: lib.symbols.SDL_BindGPUComputeSamplers,

/**
 * Binds storage textures as readonly for use on the compute pipeline.
 *
 * These textures must have been created with
 * SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param compute_pass a compute pass handle.
 * @param first_slot the compute storage texture slot to begin binding from.
 * @param storage_textures an array of storage textures.
 * @param num_bindings the number of storage textures to bind from the array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3377 void SDL_BindGPUComputeStorageTextures(    SDL_GPUComputePass *compute_pass,    Uint32 first_slot,    SDL_GPUTexture *const *storage_textures,    Uint32 num_bindings);
 */
  bindGpuComputeStorageTextures: lib.symbols.SDL_BindGPUComputeStorageTextures,

/**
 * Binds storage buffers as readonly for use on the compute pipeline.
 *
 * These buffers must have been created with
 * SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.
 *
 * Be sure your shader is set up according to the requirements documented in
 * SDL_CreateGPUShader().
 *
 * @param compute_pass a compute pass handle.
 * @param first_slot the compute storage buffer slot to begin binding from.
 * @param storage_buffers an array of storage buffer binding structs.
 * @param num_bindings the number of storage buffers to bind from the array.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateGPUShader
 *
 * @from SDL_gpu.h:3401 void SDL_BindGPUComputeStorageBuffers(    SDL_GPUComputePass *compute_pass,    Uint32 first_slot,    SDL_GPUBuffer *const *storage_buffers,    Uint32 num_bindings);
 */
  bindGpuComputeStorageBuffers: lib.symbols.SDL_BindGPUComputeStorageBuffers,

/**
 * Dispatches compute work.
 *
 * You must not call this function before binding a compute pipeline.
 *
 * A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and
 * the dispatches write to the same resource region as each other, there is no
 * guarantee of which order the writes will occur. If the write order matters,
 * you MUST end the compute pass and begin another one.
 *
 * @param compute_pass a compute pass handle.
 * @param groupcount_x number of local workgroups to dispatch in the X
 *                     dimension.
 * @param groupcount_y number of local workgroups to dispatch in the Y
 *                     dimension.
 * @param groupcount_z number of local workgroups to dispatch in the Z
 *                     dimension.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3427 void SDL_DispatchGPUCompute(    SDL_GPUComputePass *compute_pass,    Uint32 groupcount_x,    Uint32 groupcount_y,    Uint32 groupcount_z);
 */
  dispatchGpuCompute: lib.symbols.SDL_DispatchGPUCompute,

/**
 * Dispatches compute work with parameters set from a buffer.
 *
 * The buffer layout should match the layout of
 * SDL_GPUIndirectDispatchCommand. You must not call this function before
 * binding a compute pipeline.
 *
 * A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and
 * the dispatches write to the same resource region as each other, there is no
 * guarantee of which order the writes will occur. If the write order matters,
 * you MUST end the compute pass and begin another one.
 *
 * @param compute_pass a compute pass handle.
 * @param buffer a buffer containing dispatch parameters.
 * @param offset the offset to start reading from the dispatch buffer.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3451 void SDL_DispatchGPUComputeIndirect(    SDL_GPUComputePass *compute_pass,    SDL_GPUBuffer *buffer,    Uint32 offset);
 */
  dispatchGpuComputeIndirect: lib.symbols.SDL_DispatchGPUComputeIndirect,

/**
 * Ends the current compute pass.
 *
 * All bound compute state on the command buffer is unset. The compute pass
 * handle is now invalid.
 *
 * @param compute_pass a compute pass handle.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3466 void SDL_EndGPUComputePass(    SDL_GPUComputePass *compute_pass);
 */
  endGpuComputePass: lib.symbols.SDL_EndGPUComputePass,

/**
 * Maps a transfer buffer into application address space.
 *
 * You must unmap the transfer buffer before encoding upload commands. The
 * memory is owned by the graphics driver - do NOT call SDL_free() on the
 * returned pointer.
 *
 * @param device a GPU context.
 * @param transfer_buffer a transfer buffer.
 * @param cycle if true, cycles the transfer buffer if it is already bound.
 * @returns the address of the mapped transfer buffer memory, or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3486 void * SDL_MapGPUTransferBuffer(    SDL_GPUDevice *device,    SDL_GPUTransferBuffer *transfer_buffer,    bool cycle);
 */
  mapGpuTransferBuffer: lib.symbols.SDL_MapGPUTransferBuffer,

/**
 * Unmaps a previously mapped transfer buffer.
 *
 * @param device a GPU context.
 * @param transfer_buffer a previously mapped transfer buffer.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3499 void SDL_UnmapGPUTransferBuffer(    SDL_GPUDevice *device,    SDL_GPUTransferBuffer *transfer_buffer);
 */
  unmapGpuTransferBuffer: lib.symbols.SDL_UnmapGPUTransferBuffer,

/**
 * Begins a copy pass on a command buffer.
 *
 * All operations related to copying to or from buffers or textures take place
 * inside a copy pass. You must not begin another copy pass, or a render pass
 * or compute pass before ending the copy pass.
 *
 * @param command_buffer a command buffer.
 * @returns a copy pass handle.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3517 SDL_GPUCopyPass * SDL_BeginGPUCopyPass(    SDL_GPUCommandBuffer *command_buffer);
 */
  beginGpuCopyPass: lib.symbols.SDL_BeginGPUCopyPass,

/**
 * Uploads data from a transfer buffer to a texture.
 *
 * The upload occurs on the GPU timeline. You may assume that the upload has
 * finished in subsequent commands.
 *
 * You must align the data in the transfer buffer to a multiple of the texel
 * size of the texture format.
 *
 * @param copy_pass a copy pass handle.
 * @param source the source transfer buffer with image layout information.
 * @param destination the destination texture region.
 * @param cycle if true, cycles the texture if the texture is bound, otherwise
 *              overwrites the data.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3537 void SDL_UploadToGPUTexture(    SDL_GPUCopyPass *copy_pass,    const SDL_GPUTextureTransferInfo *source,    const SDL_GPUTextureRegion *destination,    bool cycle);
 */
  uploadToGpuTexture: lib.symbols.SDL_UploadToGPUTexture,

/**
 * Uploads data from a transfer buffer to a buffer.
 *
 * The upload occurs on the GPU timeline. You may assume that the upload has
 * finished in subsequent commands.
 *
 * @param copy_pass a copy pass handle.
 * @param source the source transfer buffer with offset.
 * @param destination the destination buffer with offset and size.
 * @param cycle if true, cycles the buffer if it is already bound, otherwise
 *              overwrites the data.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3557 void SDL_UploadToGPUBuffer(    SDL_GPUCopyPass *copy_pass,    const SDL_GPUTransferBufferLocation *source,    const SDL_GPUBufferRegion *destination,    bool cycle);
 */
  uploadToGpuBuffer: lib.symbols.SDL_UploadToGPUBuffer,

/**
 * Performs a texture-to-texture copy.
 *
 * This copy occurs on the GPU timeline. You may assume the copy has finished
 * in subsequent commands.
 *
 * @param copy_pass a copy pass handle.
 * @param source a source texture region.
 * @param destination a destination texture region.
 * @param w the width of the region to copy.
 * @param h the height of the region to copy.
 * @param d the depth of the region to copy.
 * @param cycle if true, cycles the destination texture if the destination
 *              texture is bound, otherwise overwrites the data.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3580 void SDL_CopyGPUTextureToTexture(    SDL_GPUCopyPass *copy_pass,    const SDL_GPUTextureLocation *source,    const SDL_GPUTextureLocation *destination,    Uint32 w,    Uint32 h,    Uint32 d,    bool cycle);
 */
  copyGpuTextureToTexture: lib.symbols.SDL_CopyGPUTextureToTexture,

/**
 * Performs a buffer-to-buffer copy.
 *
 * This copy occurs on the GPU timeline. You may assume the copy has finished
 * in subsequent commands.
 *
 * @param copy_pass a copy pass handle.
 * @param source the buffer and offset to copy from.
 * @param destination the buffer and offset to copy to.
 * @param size the length of the buffer to copy.
 * @param cycle if true, cycles the destination buffer if it is already bound,
 *              otherwise overwrites the data.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3604 void SDL_CopyGPUBufferToBuffer(    SDL_GPUCopyPass *copy_pass,    const SDL_GPUBufferLocation *source,    const SDL_GPUBufferLocation *destination,    Uint32 size,    bool cycle);
 */
  copyGpuBufferToBuffer: lib.symbols.SDL_CopyGPUBufferToBuffer,

/**
 * Copies data from a texture to a transfer buffer on the GPU timeline.
 *
 * This data is not guaranteed to be copied until the command buffer fence is
 * signaled.
 *
 * @param copy_pass a copy pass handle.
 * @param source the source texture region.
 * @param destination the destination transfer buffer with image layout
 *                    information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3624 void SDL_DownloadFromGPUTexture(    SDL_GPUCopyPass *copy_pass,    const SDL_GPUTextureRegion *source,    const SDL_GPUTextureTransferInfo *destination);
 */
  downloadFromGpuTexture: lib.symbols.SDL_DownloadFromGPUTexture,

/**
 * Copies data from a buffer to a transfer buffer on the GPU timeline.
 *
 * This data is not guaranteed to be copied until the command buffer fence is
 * signaled.
 *
 * @param copy_pass a copy pass handle.
 * @param source the source buffer with offset and size.
 * @param destination the destination transfer buffer with offset.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3641 void SDL_DownloadFromGPUBuffer(    SDL_GPUCopyPass *copy_pass,    const SDL_GPUBufferRegion *source,    const SDL_GPUTransferBufferLocation *destination);
 */
  downloadFromGpuBuffer: lib.symbols.SDL_DownloadFromGPUBuffer,

/**
 * Ends the current copy pass.
 *
 * @param copy_pass a copy pass handle.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3653 void SDL_EndGPUCopyPass(    SDL_GPUCopyPass *copy_pass);
 */
  endGpuCopyPass: lib.symbols.SDL_EndGPUCopyPass,

/**
 * Generates mipmaps for the given texture.
 *
 * This function must not be called inside of any pass.
 *
 * @param command_buffer a command_buffer.
 * @param texture a texture with more than 1 mip level.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3666 void SDL_GenerateMipmapsForGPUTexture(    SDL_GPUCommandBuffer *command_buffer,    SDL_GPUTexture *texture);
 */
  generateMipmapsForGpuTexture: lib.symbols.SDL_GenerateMipmapsForGPUTexture,

/**
 * Blits from a source texture region to a destination texture region.
 *
 * This function must not be called inside of any pass.
 *
 * @param command_buffer a command buffer.
 * @param info the blit info struct containing the blit parameters.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3680 void SDL_BlitGPUTexture(    SDL_GPUCommandBuffer *command_buffer,    const SDL_GPUBlitInfo *info);
 */
  blitGpuTexture: lib.symbols.SDL_BlitGPUTexture,

/**
 * Determines whether a swapchain composition is supported by the window.
 *
 * The window must be claimed before calling this function.
 *
 * @param device a GPU context.
 * @param window an SDL_Window.
 * @param swapchain_composition the swapchain composition to check.
 * @returns true if supported, false if unsupported.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ClaimWindowForGPUDevice
 *
 * @from SDL_gpu.h:3700 bool SDL_WindowSupportsGPUSwapchainComposition(    SDL_GPUDevice *device,    SDL_Window *window,    SDL_GPUSwapchainComposition swapchain_composition);
 */
  windowSupportsGpuSwapchainComposition: lib.symbols.SDL_WindowSupportsGPUSwapchainComposition,

/**
 * Determines whether a presentation mode is supported by the window.
 *
 * The window must be claimed before calling this function.
 *
 * @param device a GPU context.
 * @param window an SDL_Window.
 * @param present_mode the presentation mode to check.
 * @returns true if supported, false if unsupported.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ClaimWindowForGPUDevice
 *
 * @from SDL_gpu.h:3719 bool SDL_WindowSupportsGPUPresentMode(    SDL_GPUDevice *device,    SDL_Window *window,    SDL_GPUPresentMode present_mode);
 */
  windowSupportsGpuPresentMode: lib.symbols.SDL_WindowSupportsGPUPresentMode,

/**
 * Claims a window, creating a swapchain structure for it.
 *
 * This must be called before SDL_AcquireGPUSwapchainTexture is called using
 * the window. You should only call this function from the thread that created
 * the window.
 *
 * The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and
 * SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain
 * parameters, you must call SDL_SetGPUSwapchainParameters after claiming the
 * window.
 *
 * @param device a GPU context.
 * @param window an SDL_Window.
 * @returns true on success, or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called from the thread that
 *               created the window.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WaitAndAcquireGPUSwapchainTexture
 * @sa SDL_ReleaseWindowFromGPUDevice
 * @sa SDL_WindowSupportsGPUPresentMode
 * @sa SDL_WindowSupportsGPUSwapchainComposition
 *
 * @from SDL_gpu.h:3751 bool SDL_ClaimWindowForGPUDevice(    SDL_GPUDevice *device,    SDL_Window *window);
 */
  claimWindowForGpuDevice: lib.symbols.SDL_ClaimWindowForGPUDevice,

/**
 * Unclaims a window, destroying its swapchain structure.
 *
 * @param device a GPU context.
 * @param window an SDL_Window that has been claimed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ClaimWindowForGPUDevice
 *
 * @from SDL_gpu.h:3765 void SDL_ReleaseWindowFromGPUDevice(    SDL_GPUDevice *device,    SDL_Window *window);
 */
  releaseWindowFromGpuDevice: lib.symbols.SDL_ReleaseWindowFromGPUDevice,

/**
 * Changes the swapchain parameters for the given claimed window.
 *
 * This function will fail if the requested present mode or swapchain
 * composition are unsupported by the device. Check if the parameters are
 * supported via SDL_WindowSupportsGPUPresentMode /
 * SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.
 *
 * SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always
 * supported.
 *
 * @param device a GPU context.
 * @param window an SDL_Window that has been claimed.
 * @param swapchain_composition the desired composition of the swapchain.
 * @param present_mode the desired present mode for the swapchain.
 * @returns true if successful, false on error; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WindowSupportsGPUPresentMode
 * @sa SDL_WindowSupportsGPUSwapchainComposition
 *
 * @from SDL_gpu.h:3792 bool SDL_SetGPUSwapchainParameters(    SDL_GPUDevice *device,    SDL_Window *window,    SDL_GPUSwapchainComposition swapchain_composition,    SDL_GPUPresentMode present_mode);
 */
  setGpuSwapchainParameters: lib.symbols.SDL_SetGPUSwapchainParameters,

/**
 * Configures the maximum allowed number of frames in flight.
 *
 * The default value when the device is created is 2. This means that after
 * you have submitted 2 frames for presentation, if the GPU has not finished
 * working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the
 * swapchain texture pointer with NULL, and
 * SDL_WaitAndAcquireGPUSwapchainTexture() will block.
 *
 * Higher values increase throughput at the expense of visual latency. Lower
 * values decrease visual latency at the expense of throughput.
 *
 * Note that calling this function will stall and flush the command queue to
 * prevent synchronization issues.
 *
 * The minimum value of allowed frames in flight is 1, and the maximum is 3.
 *
 * @param device a GPU context.
 * @param allowed_frames_in_flight the maximum number of frames that can be
 *                                 pending on the GPU.
 * @returns true if successful, false on error; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3823 bool SDL_SetGPUAllowedFramesInFlight(    SDL_GPUDevice *device,    Uint32 allowed_frames_in_flight);
 */
  setGpuAllowedFramesInFlight: lib.symbols.SDL_SetGPUAllowedFramesInFlight,

/**
 * Obtains the texture format of the swapchain for the given window.
 *
 * Note that this format can change if the swapchain parameters change.
 *
 * @param device a GPU context.
 * @param window an SDL_Window that has been claimed.
 * @returns the texture format of the swapchain.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:3838 SDL_GPUTextureFormat SDL_GetGPUSwapchainTextureFormat(    SDL_GPUDevice *device,    SDL_Window *window);
 */
  getGpuSwapchainTextureFormat: lib.symbols.SDL_GetGPUSwapchainTextureFormat,

/**
 * Acquire a texture to use in presentation.
 *
 * When a swapchain texture is acquired on a command buffer, it will
 * automatically be submitted for presentation when the command buffer is
 * submitted. The swapchain texture should only be referenced by the command
 * buffer used to acquire it.
 *
 * This function will fill the swapchain texture handle with NULL if too many
 * frames are in flight. This is not an error.
 *
 * If you use this function, it is possible to create a situation where many
 * command buffers are allocated while the rendering context waits for the GPU
 * to catch up, which will cause memory usage to grow. You should use
 * SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing
 * with timing.
 *
 * The swapchain texture is managed by the implementation and must not be
 * freed by the user. You MUST NOT call this function from any thread other
 * than the one that created the window.
 *
 * @param command_buffer a command buffer.
 * @param window a window that has been claimed.
 * @param swapchain_texture a pointer filled in with a swapchain texture
 *                          handle.
 * @param swapchain_texture_width a pointer filled in with the swapchain
 *                                texture width, may be NULL.
 * @param swapchain_texture_height a pointer filled in with the swapchain
 *                                 texture height, may be NULL.
 * @returns true on success, false on error; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called from the thread that
 *               created the window.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ClaimWindowForGPUDevice
 * @sa SDL_SubmitGPUCommandBuffer
 * @sa SDL_SubmitGPUCommandBufferAndAcquireFence
 * @sa SDL_CancelGPUCommandBuffer
 * @sa SDL_GetWindowSizeInPixels
 * @sa SDL_WaitForGPUSwapchain
 * @sa SDL_WaitAndAcquireGPUSwapchainTexture
 * @sa SDL_SetGPUAllowedFramesInFlight
 *
 * @from SDL_gpu.h:3888 bool SDL_AcquireGPUSwapchainTexture(    SDL_GPUCommandBuffer *command_buffer,    SDL_Window *window,    SDL_GPUTexture **swapchain_texture,    Uint32 *swapchain_texture_width,    Uint32 *swapchain_texture_height);
 */
  acquireGpuSwapchainTexture: lib.symbols.SDL_AcquireGPUSwapchainTexture,

/**
 * Blocks the thread until a swapchain texture is available to be acquired.
 *
 * @param device a GPU context.
 * @param window a window that has been claimed.
 * @returns true on success, false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called from the thread that
 *               created the window.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AcquireGPUSwapchainTexture
 * @sa SDL_WaitAndAcquireGPUSwapchainTexture
 * @sa SDL_SetGPUAllowedFramesInFlight
 *
 * @from SDL_gpu.h:3912 bool SDL_WaitForGPUSwapchain(    SDL_GPUDevice *device,    SDL_Window *window);
 */
  waitForGpuSwapchain: lib.symbols.SDL_WaitForGPUSwapchain,

/**
 * Blocks the thread until a swapchain texture is available to be acquired,
 * and then acquires it.
 *
 * When a swapchain texture is acquired on a command buffer, it will
 * automatically be submitted for presentation when the command buffer is
 * submitted. The swapchain texture should only be referenced by the command
 * buffer used to acquire it. It is an error to call
 * SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.
 *
 * This function can fill the swapchain texture handle with NULL in certain
 * cases, for example if the window is minimized. This is not an error. You
 * should always make sure to check whether the pointer is NULL before
 * actually using it.
 *
 * The swapchain texture is managed by the implementation and must not be
 * freed by the user. You MUST NOT call this function from any thread other
 * than the one that created the window.
 *
 * The swapchain texture is write-only and cannot be used as a sampler or for
 * another reading operation.
 *
 * @param command_buffer a command buffer.
 * @param window a window that has been claimed.
 * @param swapchain_texture a pointer filled in with a swapchain texture
 *                          handle.
 * @param swapchain_texture_width a pointer filled in with the swapchain
 *                                texture width, may be NULL.
 * @param swapchain_texture_height a pointer filled in with the swapchain
 *                                 texture height, may be NULL.
 * @returns true on success, false on error; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called from the thread that
 *               created the window.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SubmitGPUCommandBuffer
 * @sa SDL_SubmitGPUCommandBufferAndAcquireFence
 * @sa SDL_AcquireGPUSwapchainTexture
 *
 * @from SDL_gpu.h:3958 bool SDL_WaitAndAcquireGPUSwapchainTexture(    SDL_GPUCommandBuffer *command_buffer,    SDL_Window *window,    SDL_GPUTexture **swapchain_texture,    Uint32 *swapchain_texture_width,    Uint32 *swapchain_texture_height);
 */
  waitAndAcquireGpuSwapchainTexture: lib.symbols.SDL_WaitAndAcquireGPUSwapchainTexture,

/**
 * Submits a command buffer so its commands can be processed on the GPU.
 *
 * It is invalid to use the command buffer after this is called.
 *
 * This must be called from the thread the command buffer was acquired on.
 *
 * All commands in the submission are guaranteed to begin executing before any
 * command in a subsequent submission begins executing.
 *
 * @param command_buffer a command buffer.
 * @returns true on success, false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AcquireGPUCommandBuffer
 * @sa SDL_WaitAndAcquireGPUSwapchainTexture
 * @sa SDL_AcquireGPUSwapchainTexture
 * @sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *
 * @from SDL_gpu.h:3986 bool SDL_SubmitGPUCommandBuffer(    SDL_GPUCommandBuffer *command_buffer);
 */
  submitGpuCommandBuffer: lib.symbols.SDL_SubmitGPUCommandBuffer,

/**
 * Submits a command buffer so its commands can be processed on the GPU, and
 * acquires a fence associated with the command buffer.
 *
 * You must release this fence when it is no longer needed or it will cause a
 * leak. It is invalid to use the command buffer after this is called.
 *
 * This must be called from the thread the command buffer was acquired on.
 *
 * All commands in the submission are guaranteed to begin executing before any
 * command in a subsequent submission begins executing.
 *
 * @param command_buffer a command buffer.
 * @returns a fence associated with the command buffer, or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AcquireGPUCommandBuffer
 * @sa SDL_WaitAndAcquireGPUSwapchainTexture
 * @sa SDL_AcquireGPUSwapchainTexture
 * @sa SDL_SubmitGPUCommandBuffer
 * @sa SDL_ReleaseGPUFence
 *
 * @from SDL_gpu.h:4013 SDL_GPUFence * SDL_SubmitGPUCommandBufferAndAcquireFence(    SDL_GPUCommandBuffer *command_buffer);
 */
  submitGpuCommandBufferAndAcquireFence: lib.symbols.SDL_SubmitGPUCommandBufferAndAcquireFence,

/**
 * Cancels a command buffer.
 *
 * None of the enqueued commands are executed.
 *
 * It is an error to call this function after a swapchain texture has been
 * acquired.
 *
 * This must be called from the thread the command buffer was acquired on.
 *
 * You must not reference the command buffer after calling this function.
 *
 * @param command_buffer a command buffer.
 * @returns true on success, false on error; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WaitAndAcquireGPUSwapchainTexture
 * @sa SDL_AcquireGPUCommandBuffer
 * @sa SDL_AcquireGPUSwapchainTexture
 *
 * @from SDL_gpu.h:4038 bool SDL_CancelGPUCommandBuffer(    SDL_GPUCommandBuffer *command_buffer);
 */
  cancelGpuCommandBuffer: lib.symbols.SDL_CancelGPUCommandBuffer,

/**
 * Blocks the thread until the GPU is completely idle.
 *
 * @param device a GPU context.
 * @returns true on success, false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WaitForGPUFences
 *
 * @from SDL_gpu.h:4052 bool SDL_WaitForGPUIdle(    SDL_GPUDevice *device);
 */
  waitForGpuIdle: lib.symbols.SDL_WaitForGPUIdle,

/**
 * Blocks the thread until the given fences are signaled.
 *
 * @param device a GPU context.
 * @param wait_all if 0, wait for any fence to be signaled, if 1, wait for all
 *                 fences to be signaled.
 * @param fences an array of fences to wait on.
 * @param num_fences the number of fences in the fences array.
 * @returns true on success, false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SubmitGPUCommandBufferAndAcquireFence
 * @sa SDL_WaitForGPUIdle
 *
 * @from SDL_gpu.h:4071 bool SDL_WaitForGPUFences(    SDL_GPUDevice *device,    bool wait_all,    SDL_GPUFence *const *fences,    Uint32 num_fences);
 */
  waitForGpuFences: lib.symbols.SDL_WaitForGPUFences,

/**
 * Checks the status of a fence.
 *
 * @param device a GPU context.
 * @param fence a fence.
 * @returns true if the fence is signaled, false if it is not.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *
 * @from SDL_gpu.h:4088 bool SDL_QueryGPUFence(    SDL_GPUDevice *device,    SDL_GPUFence *fence);
 */
  queryGpuFence: lib.symbols.SDL_QueryGPUFence,

/**
 * Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.
 *
 * You must not reference the fence after calling this function.
 *
 * @param device a GPU context.
 * @param fence a fence.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SubmitGPUCommandBufferAndAcquireFence
 *
 * @from SDL_gpu.h:4104 void SDL_ReleaseGPUFence(    SDL_GPUDevice *device,    SDL_GPUFence *fence);
 */
  releaseGpuFence: lib.symbols.SDL_ReleaseGPUFence,

/**
 * Obtains the texel block size for a texture format.
 *
 * @param format the texture format you want to know the texel size of.
 * @returns the texel block size of the texture format.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UploadToGPUTexture
 *
 * @from SDL_gpu.h:4120 Uint32 SDL_GPUTextureFormatTexelBlockSize(    SDL_GPUTextureFormat format);
 */
  gpuTextureFormatTexelBlockSize: lib.symbols.SDL_GPUTextureFormatTexelBlockSize,

/**
 * Determines whether a texture format is supported for a given type and
 * usage.
 *
 * @param device a GPU context.
 * @param format the texture format to check.
 * @param type the type of texture (2D, 3D, Cube).
 * @param usage a bitmask of all usage scenarios to check.
 * @returns whether the texture format is supported for this type and usage.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:4135 bool SDL_GPUTextureSupportsFormat(    SDL_GPUDevice *device,    SDL_GPUTextureFormat format,    SDL_GPUTextureType type,    SDL_GPUTextureUsageFlags usage);
 */
  gpuTextureSupportsFormat: lib.symbols.SDL_GPUTextureSupportsFormat,

/**
 * Determines if a sample count for a texture format is supported.
 *
 * @param device a GPU context.
 * @param format the texture format to check.
 * @param sample_count the sample count to check.
 * @returns whether the sample count is supported for this texture format.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:4151 bool SDL_GPUTextureSupportsSampleCount(    SDL_GPUDevice *device,    SDL_GPUTextureFormat format,    SDL_GPUSampleCount sample_count);
 */
  gpuTextureSupportsSampleCount: lib.symbols.SDL_GPUTextureSupportsSampleCount,

/**
 * Calculate the size in bytes of a texture format with dimensions.
 *
 * @param format a texture format.
 * @param width width in pixels.
 * @param height height in pixels.
 * @param depth_or_layer_count depth for 3D textures or layer count otherwise.
 * @returns the size of a texture with this format and dimensions.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_gpu.h:4167 Uint32 SDL_CalculateGPUTextureFormatSize(    SDL_GPUTextureFormat format,    Uint32 width,    Uint32 height,    Uint32 depth_or_layer_count);
 */
  calculateGpuTextureFormatSize: lib.symbols.SDL_CalculateGPUTextureFormatSize,

/**
 * Call this to suspend GPU operation on Xbox when you receive the
 * SDL_EVENT_DID_ENTER_BACKGROUND event.
 *
 * Do NOT call any SDL_GPU functions after calling this function! This must
 * also be called before calling SDL_GDKSuspendComplete.
 *
 * @param device a GPU context.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddEventWatch
 *
 * @from SDL_gpu.h:4188 void SDL_GDKSuspendGPU(SDL_GPUDevice *device);
 */
  /* gdkSuspendGpu: lib.symbols.SDL_GDKSuspendGPU, */

/**
 * Call this to resume GPU operation on Xbox when you receive the
 * SDL_EVENT_WILL_ENTER_FOREGROUND event.
 *
 * When resuming, this function MUST be called before calling any other
 * SDL_GPU functions.
 *
 * @param device a GPU context.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddEventWatch
 *
 * @from SDL_gpu.h:4203 void SDL_GDKResumeGPU(SDL_GPUDevice *device);
 */
  /* gdkResumeGpu: lib.symbols.SDL_GDKResumeGPU, */



/*--- SDL_guid ---*/

/**
 * Get an ASCII string representation for a given SDL_GUID.
 *
 * @param guid the SDL_GUID you wish to convert to string.
 * @param pszGUID buffer in which to write the ASCII string.
 * @param cbGUID the size of pszGUID, should be at least 33 bytes.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StringToGUID
 *
 * @from SDL_guid.h:79 void SDL_GUIDToString(SDL_GUID guid, char *pszGUID, int cbGUID);
 */
  guidToString: lib.symbols.SDL_GUIDToString,

/**
 * Convert a GUID string into a SDL_GUID structure.
 *
 * Performs no error checking. If this function is given a string containing
 * an invalid GUID, the function will silently succeed, but the GUID generated
 * will not be useful.
 *
 * @param pchGUID string containing an ASCII representation of a GUID.
 * @returns a SDL_GUID structure.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GUIDToString
 *
 * @from SDL_guid.h:97 SDL_GUID SDL_StringToGUID(const char *pchGUID);
 */
  stringToGuid: lib.symbols.SDL_StringToGUID,



/*--- SDL_haptic ---*/

/**
 * Get a list of currently connected haptic devices.
 *
 * @param count a pointer filled in with the number of haptic devices
 *              returned, may be NULL.
 * @returns a 0 terminated array of haptic device instance IDs or NULL on
 *          failure; call SDL_GetError() for more information. This should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenHaptic
 *
 * @from SDL_haptic.h:954 SDL_HapticID * SDL_GetHaptics(int *count);
 */
  getHaptics: lib.symbols.SDL_GetHaptics,

/**
 * Get the implementation dependent name of a haptic device.
 *
 * This can be called before any haptic devices are opened.
 *
 * @param instance_id the haptic device instance ID.
 * @returns the name of the selected haptic device. If no name can be found,
 *          this function returns NULL; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHapticName
 * @sa SDL_OpenHaptic
 *
 * @from SDL_haptic.h:971 const char * SDL_GetHapticNameForID(SDL_HapticID instance_id);
 */
  getHapticNameForId: lib.symbols.SDL_GetHapticNameForID,

/**
 * Open a haptic device for use.
 *
 * The index passed as an argument refers to the N'th haptic device on this
 * system.
 *
 * When opening a haptic device, its gain will be set to maximum and
 * autocenter will be disabled. To modify these values use SDL_SetHapticGain()
 * and SDL_SetHapticAutocenter().
 *
 * @param instance_id the haptic device instance ID.
 * @returns the device identifier or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseHaptic
 * @sa SDL_GetHaptics
 * @sa SDL_OpenHapticFromJoystick
 * @sa SDL_OpenHapticFromMouse
 * @sa SDL_SetHapticAutocenter
 * @sa SDL_SetHapticGain
 *
 * @from SDL_haptic.h:996 SDL_Haptic * SDL_OpenHaptic(SDL_HapticID instance_id);
 */
  openHaptic: lib.symbols.SDL_OpenHaptic,

/**
 * Get the SDL_Haptic associated with an instance ID, if it has been opened.
 *
 * @param instance_id the instance ID to get the SDL_Haptic for.
 * @returns an SDL_Haptic on success or NULL on failure or if it hasn't been
 *          opened yet; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_haptic.h:1008 SDL_Haptic * SDL_GetHapticFromID(SDL_HapticID instance_id);
 */
  getHapticFromId: lib.symbols.SDL_GetHapticFromID,

/**
 * Get the instance ID of an opened haptic device.
 *
 * @param haptic the SDL_Haptic device to query.
 * @returns the instance ID of the specified haptic device on success or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_haptic.h:1019 SDL_HapticID SDL_GetHapticID(SDL_Haptic *haptic);
 */
  getHapticId: lib.symbols.SDL_GetHapticID,

/**
 * Get the implementation dependent name of a haptic device.
 *
 * @param haptic the SDL_Haptic obtained from SDL_OpenJoystick().
 * @returns the name of the selected haptic device. If no name can be found,
 *          this function returns NULL; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHapticNameForID
 *
 * @from SDL_haptic.h:1033 const char * SDL_GetHapticName(SDL_Haptic *haptic);
 */
  getHapticName: lib.symbols.SDL_GetHapticName,

/**
 * Query whether or not the current mouse has haptic capabilities.
 *
 * @returns true if the mouse is haptic or false if it isn't.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenHapticFromMouse
 *
 * @from SDL_haptic.h:1044 bool SDL_IsMouseHaptic(void);
 */
  isMouseHaptic: lib.symbols.SDL_IsMouseHaptic,

/**
 * Try to open a haptic device from the current mouse.
 *
 * @returns the haptic device identifier or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseHaptic
 * @sa SDL_IsMouseHaptic
 *
 * @from SDL_haptic.h:1057 SDL_Haptic * SDL_OpenHapticFromMouse(void);
 */
  openHapticFromMouse: lib.symbols.SDL_OpenHapticFromMouse,

/**
 * Query if a joystick has haptic features.
 *
 * @param joystick the SDL_Joystick to test for haptic capabilities.
 * @returns true if the joystick is haptic or false if it isn't.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenHapticFromJoystick
 *
 * @from SDL_haptic.h:1069 bool SDL_IsJoystickHaptic(SDL_Joystick *joystick);
 */
  isJoystickHaptic: lib.symbols.SDL_IsJoystickHaptic,

/**
 * Open a haptic device for use from a joystick device.
 *
 * You must still close the haptic device separately. It will not be closed
 * with the joystick.
 *
 * When opened from a joystick you should first close the haptic device before
 * closing the joystick device. If not, on some implementations the haptic
 * device will also get unallocated and you'll be unable to use force feedback
 * on that device.
 *
 * @param joystick the SDL_Joystick to create a haptic device from.
 * @returns a valid haptic device identifier on success or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseHaptic
 * @sa SDL_IsJoystickHaptic
 *
 * @from SDL_haptic.h:1091 SDL_Haptic * SDL_OpenHapticFromJoystick(SDL_Joystick *joystick);
 */
  openHapticFromJoystick: lib.symbols.SDL_OpenHapticFromJoystick,

/**
 * Close a haptic device previously opened with SDL_OpenHaptic().
 *
 * @param haptic the SDL_Haptic device to close.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenHaptic
 *
 * @from SDL_haptic.h:1102 void SDL_CloseHaptic(SDL_Haptic *haptic);
 */
  closeHaptic: lib.symbols.SDL_CloseHaptic,

/**
 * Get the number of effects a haptic device can store.
 *
 * On some platforms this isn't fully supported, and therefore is an
 * approximation. Always check to see if your created effect was actually
 * created and do not rely solely on SDL_GetMaxHapticEffects().
 *
 * @param haptic the SDL_Haptic device to query.
 * @returns the number of effects the haptic device can store or a negative
 *          error code on failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetMaxHapticEffectsPlaying
 * @sa SDL_GetHapticFeatures
 *
 * @from SDL_haptic.h:1120 int SDL_GetMaxHapticEffects(SDL_Haptic *haptic);
 */
  getMaxHapticEffects: lib.symbols.SDL_GetMaxHapticEffects,

/**
 * Get the number of effects a haptic device can play at the same time.
 *
 * This is not supported on all platforms, but will always return a value.
 *
 * @param haptic the SDL_Haptic device to query maximum playing effects.
 * @returns the number of effects the haptic device can play at the same time
 *          or -1 on failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetMaxHapticEffects
 * @sa SDL_GetHapticFeatures
 *
 * @from SDL_haptic.h:1136 int SDL_GetMaxHapticEffectsPlaying(SDL_Haptic *haptic);
 */
  getMaxHapticEffectsPlaying: lib.symbols.SDL_GetMaxHapticEffectsPlaying,

/**
 * Get the haptic device's supported features in bitwise manner.
 *
 * @param haptic the SDL_Haptic device to query.
 * @returns a list of supported haptic features in bitwise manner (OR'd), or 0
 *          on failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HapticEffectSupported
 * @sa SDL_GetMaxHapticEffects
 *
 * @from SDL_haptic.h:1150 Uint32 SDL_GetHapticFeatures(SDL_Haptic *haptic);
 */
  getHapticFeatures: lib.symbols.SDL_GetHapticFeatures,

/**
 * Get the number of haptic axes the device has.
 *
 * The number of haptic axes might be useful if working with the
 * SDL_HapticDirection effect.
 *
 * @param haptic the SDL_Haptic device to query.
 * @returns the number of axes on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_haptic.h:1164 int SDL_GetNumHapticAxes(SDL_Haptic *haptic);
 */
  getNumHapticAxes: lib.symbols.SDL_GetNumHapticAxes,

/**
 * Check to see if an effect is supported by a haptic device.
 *
 * @param haptic the SDL_Haptic device to query.
 * @param effect the desired effect to query.
 * @returns true if the effect is supported or false if it isn't.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateHapticEffect
 * @sa SDL_GetHapticFeatures
 *
 * @from SDL_haptic.h:1178 bool SDL_HapticEffectSupported(SDL_Haptic *haptic, const SDL_HapticEffect *effect);
 */
  hapticEffectSupported: lib.symbols.SDL_HapticEffectSupported,

/**
 * Create a new haptic effect on a specified device.
 *
 * @param haptic an SDL_Haptic device to create the effect on.
 * @param effect an SDL_HapticEffect structure containing the properties of
 *               the effect to create.
 * @returns the ID of the effect on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyHapticEffect
 * @sa SDL_RunHapticEffect
 * @sa SDL_UpdateHapticEffect
 *
 * @from SDL_haptic.h:1195 int SDL_CreateHapticEffect(SDL_Haptic *haptic, const SDL_HapticEffect *effect);
 */
  createHapticEffect: lib.symbols.SDL_CreateHapticEffect,

/**
 * Update the properties of an effect.
 *
 * Can be used dynamically, although behavior when dynamically changing
 * direction may be strange. Specifically the effect may re-upload itself and
 * start playing from the start. You also cannot change the type either when
 * running SDL_UpdateHapticEffect().
 *
 * @param haptic the SDL_Haptic device that has the effect.
 * @param effect the identifier of the effect to update.
 * @param data an SDL_HapticEffect structure containing the new effect
 *             properties to use.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateHapticEffect
 * @sa SDL_RunHapticEffect
 *
 * @from SDL_haptic.h:1217 bool SDL_UpdateHapticEffect(SDL_Haptic *haptic, int effect, const SDL_HapticEffect *data);
 */
  updateHapticEffect: lib.symbols.SDL_UpdateHapticEffect,

/**
 * Run the haptic effect on its associated haptic device.
 *
 * To repeat the effect over and over indefinitely, set `iterations` to
 * `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make
 * one instance of the effect last indefinitely (so the effect does not fade),
 * set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`
 * instead.
 *
 * @param haptic the SDL_Haptic device to run the effect on.
 * @param effect the ID of the haptic effect to run.
 * @param iterations the number of iterations to run the effect; use
 *                   `SDL_HAPTIC_INFINITY` to repeat forever.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHapticEffectStatus
 * @sa SDL_StopHapticEffect
 * @sa SDL_StopHapticEffects
 *
 * @from SDL_haptic.h:1241 bool SDL_RunHapticEffect(SDL_Haptic *haptic, int effect, Uint32 iterations);
 */
  runHapticEffect: lib.symbols.SDL_RunHapticEffect,

/**
 * Stop the haptic effect on its associated haptic device.
 *
 * @param haptic the SDL_Haptic device to stop the effect on.
 * @param effect the ID of the haptic effect to stop.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RunHapticEffect
 * @sa SDL_StopHapticEffects
 *
 * @from SDL_haptic.h:1256 bool SDL_StopHapticEffect(SDL_Haptic *haptic, int effect);
 */
  stopHapticEffect: lib.symbols.SDL_StopHapticEffect,

/**
 * Destroy a haptic effect on the device.
 *
 * This will stop the effect if it's running. Effects are automatically
 * destroyed when the device is closed.
 *
 * @param haptic the SDL_Haptic device to destroy the effect on.
 * @param effect the ID of the haptic effect to destroy.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateHapticEffect
 *
 * @from SDL_haptic.h:1271 void SDL_DestroyHapticEffect(SDL_Haptic *haptic, int effect);
 */
  destroyHapticEffect: lib.symbols.SDL_DestroyHapticEffect,

/**
 * Get the status of the current effect on the specified haptic device.
 *
 * Device must support the SDL_HAPTIC_STATUS feature.
 *
 * @param haptic the SDL_Haptic device to query for the effect status on.
 * @param effect the ID of the haptic effect to query its status.
 * @returns true if it is playing, false if it isn't playing or haptic status
 *          isn't supported.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHapticFeatures
 *
 * @from SDL_haptic.h:1287 bool SDL_GetHapticEffectStatus(SDL_Haptic *haptic, int effect);
 */
  getHapticEffectStatus: lib.symbols.SDL_GetHapticEffectStatus,

/**
 * Set the global gain of the specified haptic device.
 *
 * Device must support the SDL_HAPTIC_GAIN feature.
 *
 * The user may specify the maximum gain by setting the environment variable
 * `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to
 * SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the
 * maximum.
 *
 * @param haptic the SDL_Haptic device to set the gain on.
 * @param gain value to set the gain to, should be between 0 and 100 (0 -
 *             100).
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHapticFeatures
 *
 * @from SDL_haptic.h:1309 bool SDL_SetHapticGain(SDL_Haptic *haptic, int gain);
 */
  setHapticGain: lib.symbols.SDL_SetHapticGain,

/**
 * Set the global autocenter of the device.
 *
 * Autocenter should be between 0 and 100. Setting it to 0 will disable
 * autocentering.
 *
 * Device must support the SDL_HAPTIC_AUTOCENTER feature.
 *
 * @param haptic the SDL_Haptic device to set autocentering on.
 * @param autocenter value to set autocenter to (0-100).
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHapticFeatures
 *
 * @from SDL_haptic.h:1328 bool SDL_SetHapticAutocenter(SDL_Haptic *haptic, int autocenter);
 */
  setHapticAutocenter: lib.symbols.SDL_SetHapticAutocenter,

/**
 * Pause a haptic device.
 *
 * Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()
 * to resume playback.
 *
 * Do not modify the effects nor add new ones while the device is paused. That
 * can cause all sorts of weird errors.
 *
 * @param haptic the SDL_Haptic device to pause.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ResumeHaptic
 *
 * @from SDL_haptic.h:1347 bool SDL_PauseHaptic(SDL_Haptic *haptic);
 */
  pauseHaptic: lib.symbols.SDL_PauseHaptic,

/**
 * Resume a haptic device.
 *
 * Call to unpause after SDL_PauseHaptic().
 *
 * @param haptic the SDL_Haptic device to unpause.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PauseHaptic
 *
 * @from SDL_haptic.h:1362 bool SDL_ResumeHaptic(SDL_Haptic *haptic);
 */
  resumeHaptic: lib.symbols.SDL_ResumeHaptic,

/**
 * Stop all the currently playing effects on a haptic device.
 *
 * @param haptic the SDL_Haptic device to stop.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RunHapticEffect
 * @sa SDL_StopHapticEffects
 *
 * @from SDL_haptic.h:1376 bool SDL_StopHapticEffects(SDL_Haptic *haptic);
 */
  stopHapticEffects: lib.symbols.SDL_StopHapticEffects,

/**
 * Check whether rumble is supported on a haptic device.
 *
 * @param haptic haptic device to check for rumble support.
 * @returns true if the effect is supported or false if it isn't.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_InitHapticRumble
 *
 * @from SDL_haptic.h:1388 bool SDL_HapticRumbleSupported(SDL_Haptic *haptic);
 */
  hapticRumbleSupported: lib.symbols.SDL_HapticRumbleSupported,

/**
 * Initialize a haptic device for simple rumble playback.
 *
 * @param haptic the haptic device to initialize for simple rumble playback.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PlayHapticRumble
 * @sa SDL_StopHapticRumble
 * @sa SDL_HapticRumbleSupported
 *
 * @from SDL_haptic.h:1403 bool SDL_InitHapticRumble(SDL_Haptic *haptic);
 */
  initHapticRumble: lib.symbols.SDL_InitHapticRumble,

/**
 * Run a simple rumble effect on a haptic device.
 *
 * @param haptic the haptic device to play the rumble effect on.
 * @param strength strength of the rumble to play as a 0-1 float value.
 * @param length length of the rumble to play in milliseconds.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_InitHapticRumble
 * @sa SDL_StopHapticRumble
 *
 * @from SDL_haptic.h:1419 bool SDL_PlayHapticRumble(SDL_Haptic *haptic, float strength, Uint32 length);
 */
  playHapticRumble: lib.symbols.SDL_PlayHapticRumble,

/**
 * Stop the simple rumble on a haptic device.
 *
 * @param haptic the haptic device to stop the rumble effect on.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PlayHapticRumble
 *
 * @from SDL_haptic.h:1432 bool SDL_StopHapticRumble(SDL_Haptic *haptic);
 */
  stopHapticRumble: lib.symbols.SDL_StopHapticRumble,



/*--- SDL_hidapi ---*/

/**
 * HID underlying bus types.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:76 SDL_HID_API_BUS_
 */
  HID_API_BUS: SDL_hidapi_enums.SDL_hid_bus_type,



/**
 * Initialize the HIDAPI library.
 *
 * This function initializes the HIDAPI library. Calling it is not strictly
 * necessary, as it will be called automatically by SDL_hid_enumerate() and
 * any of the SDL_hid_open_*() functions if it is needed. This function should
 * be called at the beginning of execution however, if there is a chance of
 * HIDAPI handles being opened by different threads simultaneously.
 *
 * Each call to this function should have a matching call to SDL_hid_exit()
 *
 * @returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_hid_exit
 *
 * @from SDL_hidapi.h:175 int SDL_hid_init(void);
 */
  hidInit: lib.symbols.SDL_hid_init,

/**
 * Finalize the HIDAPI library.
 *
 * This function frees all of the static data associated with HIDAPI. It
 * should be called at the end of execution to avoid memory leaks.
 *
 * @returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_hid_init
 *
 * @from SDL_hidapi.h:190 int SDL_hid_exit(void);
 */
  hidExit: lib.symbols.SDL_hid_exit,

/**
 * Check to see if devices may have been added or removed.
 *
 * Enumerating the HID devices is an expensive operation, so you can call this
 * to see if there have been any system device changes since the last call to
 * this function. A change in the counter returned doesn't necessarily mean
 * that anything has changed, but you can call SDL_hid_enumerate() to get an
 * updated device list.
 *
 * Calling this function for the first time may cause a thread or other system
 * resource to be allocated to track device change notifications.
 *
 * @returns a change counter that is incremented with each potential device
 *          change, or 0 if device change detection isn't available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_hid_enumerate
 *
 * @from SDL_hidapi.h:211 Uint32 SDL_hid_device_change_count(void);
 */
  hidDeviceChangeCount: lib.symbols.SDL_hid_device_change_count,

/**
 * Enumerate the HID Devices.
 *
 * This function returns a linked list of all the HID devices attached to the
 * system which match vendor_id and product_id. If `vendor_id` is set to 0
 * then any vendor matches. If `product_id` is set to 0 then any product
 * matches. If `vendor_id` and `product_id` are both set to 0, then all HID
 * devices will be returned.
 *
 * By default SDL will only enumerate controllers, to reduce risk of hanging
 * or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS
 * can be set to "0" to enumerate all HID devices.
 *
 * @param vendor_id the Vendor ID (VID) of the types of device to open, or 0
 *                  to match any vendor.
 * @param product_id the Product ID (PID) of the types of device to open, or 0
 *                   to match any product.
 * @returns a pointer to a linked list of type SDL_hid_device_info, containing
 *          information about the HID devices attached to the system, or NULL
 *          in the case of failure. Free this linked list by calling
 *          SDL_hid_free_enumeration().
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_hid_device_change_count
 *
 * @from SDL_hidapi.h:239 SDL_hid_device_info * SDL_hid_enumerate(unsigned short vendor_id, unsigned short product_id);
 */
  hidEnumerate: lib.symbols.SDL_hid_enumerate,

/**
 * Free an enumeration linked list.
 *
 * This function frees a linked list created by SDL_hid_enumerate().
 *
 * @param devs pointer to a list of struct_device returned from
 *             SDL_hid_enumerate().
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:251 void SDL_hid_free_enumeration(SDL_hid_device_info *devs);
 */
  hidFreeEnumeration: lib.symbols.SDL_hid_free_enumeration,

/**
 * Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally
 * a serial number.
 *
 * If `serial_number` is NULL, the first device with the specified VID and PID
 * is opened.
 *
 * @param vendor_id the Vendor ID (VID) of the device to open.
 * @param product_id the Product ID (PID) of the device to open.
 * @param serial_number the Serial Number of the device to open (Optionally
 *                      NULL).
 * @returns a pointer to a SDL_hid_device object on success or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:269 SDL_hid_device * SDL_hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number);
 */
  hidOpen: lib.symbols.SDL_hid_open,

/**
 * Open a HID device by its path name.
 *
 * The path name be determined by calling SDL_hid_enumerate(), or a
 * platform-specific path name can be used (eg: /dev/hidraw0 on Linux).
 *
 * @param path the path name of the device to open.
 * @returns a pointer to a SDL_hid_device object on success or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:283 SDL_hid_device * SDL_hid_open_path(const char *path);
 */
  hidOpenPath: lib.symbols.SDL_hid_open_path,

/**
 * Write an Output report to a HID device.
 *
 * The first byte of `data` must contain the Report ID. For devices which only
 * support a single report, this must be set to 0x0. The remaining bytes
 * contain the report data. Since the Report ID is mandatory, calls to
 * SDL_hid_write() will always contain one more byte than the report contains.
 * For example, if a hid report is 16 bytes long, 17 bytes must be passed to
 * SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),
 * followed by the report data (16 bytes). In this example, the length passed
 * in would be 17.
 *
 * SDL_hid_write() will send the data on the first OUT endpoint, if one
 * exists. If it does not, it will send the data through the Control Endpoint
 * (Endpoint 0).
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param data the data to send, including the report number as the first
 *             byte.
 * @param length the length in bytes of the data to send.
 * @returns the actual number of bytes written and -1 on on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:310 int SDL_hid_write(SDL_hid_device *dev, const unsigned char *data, size_t length);
 */
  hidWrite: lib.symbols.SDL_hid_write,

/**
 * Read an Input report from a HID device with timeout.
 *
 * Input reports are returned to the host through the INTERRUPT IN endpoint.
 * The first byte will contain the Report number if the device uses numbered
 * reports.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param data a buffer to put the read data into.
 * @param length the number of bytes to read. For devices with multiple
 *               reports, make sure to read an extra byte for the report
 *               number.
 * @param milliseconds timeout in milliseconds or -1 for blocking wait.
 * @returns the actual number of bytes read and -1 on on failure; call
 *          SDL_GetError() for more information. If no packet was available to
 *          be read within the timeout period, this function returns 0.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:331 int SDL_hid_read_timeout(SDL_hid_device *dev, unsigned char *data, size_t length, int milliseconds);
 */
  hidReadTimeout: lib.symbols.SDL_hid_read_timeout,

/**
 * Read an Input report from a HID device.
 *
 * Input reports are returned to the host through the INTERRUPT IN endpoint.
 * The first byte will contain the Report number if the device uses numbered
 * reports.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param data a buffer to put the read data into.
 * @param length the number of bytes to read. For devices with multiple
 *               reports, make sure to read an extra byte for the report
 *               number.
 * @returns the actual number of bytes read and -1 on failure; call
 *          SDL_GetError() for more information. If no packet was available to
 *          be read and the handle is in non-blocking mode, this function
 *          returns 0.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:352 int SDL_hid_read(SDL_hid_device *dev, unsigned char *data, size_t length);
 */
  hidRead: lib.symbols.SDL_hid_read,

/**
 * Set the device handle to be non-blocking.
 *
 * In non-blocking mode calls to SDL_hid_read() will return immediately with a
 * value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()
 * will wait (block) until there is data to read before returning.
 *
 * Nonblocking can be turned on and off at any time.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param nonblock enable or not the nonblocking reads - 1 to enable
 *                 nonblocking - 0 to disable nonblocking.
 * @returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:371 int SDL_hid_set_nonblocking(SDL_hid_device *dev, int nonblock);
 */
  hidSetNonblocking: lib.symbols.SDL_hid_set_nonblocking,

/**
 * Send a Feature report to the device.
 *
 * Feature reports are sent over the Control endpoint as a Set_Report
 * transfer. The first byte of `data` must contain the Report ID. For devices
 * which only support a single report, this must be set to 0x0. The remaining
 * bytes contain the report data. Since the Report ID is mandatory, calls to
 * SDL_hid_send_feature_report() will always contain one more byte than the
 * report contains. For example, if a hid report is 16 bytes long, 17 bytes
 * must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for
 * devices which do not use numbered reports), followed by the report data (16
 * bytes). In this example, the length passed in would be 17.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param data the data to send, including the report number as the first
 *             byte.
 * @param length the length in bytes of the data to send, including the report
 *               number.
 * @returns the actual number of bytes written and -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:396 int SDL_hid_send_feature_report(SDL_hid_device *dev, const unsigned char *data, size_t length);
 */
  hidSendFeatureReport: lib.symbols.SDL_hid_send_feature_report,

/**
 * Get a feature report from a HID device.
 *
 * Set the first byte of `data` to the Report ID of the report to be read.
 * Make sure to allow space for this extra byte in `data`. Upon return, the
 * first byte will still contain the Report ID, and the report data will start
 * in data[1].
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param data a buffer to put the read data into, including the Report ID.
 *             Set the first byte of `data` to the Report ID of the report to
 *             be read, or set it to zero if your device does not use numbered
 *             reports.
 * @param length the number of bytes to read, including an extra byte for the
 *               report ID. The buffer can be longer than the actual report.
 * @returns the number of bytes read plus one for the report ID (which is
 *          still in the first byte), or -1 on on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:419 int SDL_hid_get_feature_report(SDL_hid_device *dev, unsigned char *data, size_t length);
 */
  hidGetFeatureReport: lib.symbols.SDL_hid_get_feature_report,

/**
 * Get an input report from a HID device.
 *
 * Set the first byte of `data` to the Report ID of the report to be read.
 * Make sure to allow space for this extra byte in `data`. Upon return, the
 * first byte will still contain the Report ID, and the report data will start
 * in data[1].
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param data a buffer to put the read data into, including the Report ID.
 *             Set the first byte of `data` to the Report ID of the report to
 *             be read, or set it to zero if your device does not use numbered
 *             reports.
 * @param length the number of bytes to read, including an extra byte for the
 *               report ID. The buffer can be longer than the actual report.
 * @returns the number of bytes read plus one for the report ID (which is
 *          still in the first byte), or -1 on on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:442 int SDL_hid_get_input_report(SDL_hid_device *dev, unsigned char *data, size_t length);
 */
  hidGetInputReport: lib.symbols.SDL_hid_get_input_report,

/**
 * Close a HID device.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:453 int SDL_hid_close(SDL_hid_device *dev);
 */
  hidClose: lib.symbols.SDL_hid_close,

/**
 * Get The Manufacturer String from a HID device.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param string a wide string buffer to put the data into.
 * @param maxlen the length of the buffer in multiples of wchar_t.
 * @returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:466 int SDL_hid_get_manufacturer_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
 */
  hidGetManufacturerString: lib.symbols.SDL_hid_get_manufacturer_string,

/**
 * Get The Product String from a HID device.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param string a wide string buffer to put the data into.
 * @param maxlen the length of the buffer in multiples of wchar_t.
 * @returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:479 int SDL_hid_get_product_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
 */
  hidGetProductString: lib.symbols.SDL_hid_get_product_string,

/**
 * Get The Serial Number String from a HID device.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param string a wide string buffer to put the data into.
 * @param maxlen the length of the buffer in multiples of wchar_t.
 * @returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:492 int SDL_hid_get_serial_number_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
 */
  hidGetSerialNumberString: lib.symbols.SDL_hid_get_serial_number_string,

/**
 * Get a string from a HID device, based on its string index.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param string_index the index of the string to get.
 * @param string a wide string buffer to put the data into.
 * @param maxlen the length of the buffer in multiples of wchar_t.
 * @returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:506 int SDL_hid_get_indexed_string(SDL_hid_device *dev, int string_index, wchar_t *string, size_t maxlen);
 */
  hidGetIndexedString: lib.symbols.SDL_hid_get_indexed_string,

/**
 * Get the device info from a HID device.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @returns a pointer to the SDL_hid_device_info for this hid_device or NULL
 *          on failure; call SDL_GetError() for more information. This struct
 *          is valid until the device is closed with SDL_hid_close().
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:518 SDL_hid_device_info * SDL_hid_get_device_info(SDL_hid_device *dev);
 */
  hidGetDeviceInfo: lib.symbols.SDL_hid_get_device_info,

/**
 * Get a report descriptor from a HID device.
 *
 * User has to provide a preallocated buffer where descriptor will be copied
 * to. The recommended size for a preallocated buffer is 4096 bytes.
 *
 * @param dev a device handle returned from SDL_hid_open().
 * @param buf the buffer to copy descriptor into.
 * @param buf_size the size of the buffer in bytes.
 * @returns the number of bytes actually copied or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:534 int SDL_hid_get_report_descriptor(SDL_hid_device *dev, unsigned char *buf, size_t buf_size);
 */
  hidGetReportDescriptor: lib.symbols.SDL_hid_get_report_descriptor,

/**
 * Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers.
 *
 * @param active true to start the scan, false to stop the scan.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_hidapi.h:543 void SDL_hid_ble_scan(bool active);
 */
  hidBleScan: lib.symbols.SDL_hid_ble_scan,



/*--- SDL_hints ---*/

/**
 * An enumeration of hint priorities.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_hints.h:4295 SDL_HINT_
 */
  HINT: SDL_hints_enums.SDL_HintPriority,



/**
 * Set a hint with a specific priority.
 *
 * The priority controls the behavior when setting a hint that already has a
 * value. Hints will replace existing hints of their priority and lower.
 * Environment variables are considered to have override priority.
 *
 * @param name the hint to set.
 * @param value the value of the hint variable.
 * @param priority the SDL_HintPriority level for the hint.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHint
 * @sa SDL_ResetHint
 * @sa SDL_SetHint
 *
 * @from SDL_hints.h:4323 bool SDL_SetHintWithPriority(const char *name, const char *value, SDL_HintPriority priority);
 */
  setHintWithPriority: lib.symbols.SDL_SetHintWithPriority,

/**
 * Set a hint with normal priority.
 *
 * Hints will not be set if there is an existing override hint or environment
 * variable that takes precedence. You can use SDL_SetHintWithPriority() to
 * set the hint with override priority instead.
 *
 * @param name the hint to set.
 * @param value the value of the hint variable.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHint
 * @sa SDL_ResetHint
 * @sa SDL_SetHintWithPriority
 *
 * @from SDL_hints.h:4345 bool SDL_SetHint(const char *name, const char *value);
 */
  setHint: lib.symbols.SDL_SetHint,

/**
 * Reset a hint to the default value.
 *
 * This will reset a hint to the value of the environment variable, or NULL if
 * the environment isn't set. Callbacks will be called normally with this
 * change.
 *
 * @param name the hint to set.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetHint
 * @sa SDL_ResetHints
 *
 * @from SDL_hints.h:4365 bool SDL_ResetHint(const char *name);
 */
  resetHint: lib.symbols.SDL_ResetHint,

/**
 * Reset all hints to the default values.
 *
 * This will reset all hints to the value of the associated environment
 * variable, or NULL if the environment isn't set. Callbacks will be called
 * normally with this change.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ResetHint
 *
 * @from SDL_hints.h:4380 void SDL_ResetHints(void);
 */
  resetHints: lib.symbols.SDL_ResetHints,

/**
 * Get the value of a hint.
 *
 * @param name the hint to query.
 * @returns the string value of a hint or NULL if the hint isn't set.
 *
 * @threadsafety It is safe to call this function from any thread, however the
 *               return value only remains valid until the hint is changed; if
 *               another thread might do so, the app should supply locks
 *               and/or make a copy of the string. Note that using a hint
 *               callback instead is always thread-safe, as SDL holds a lock
 *               on the thread subsystem during the callback.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetHint
 * @sa SDL_SetHintWithPriority
 *
 * @from SDL_hints.h:4400 const char * SDL_GetHint(const char *name);
 */
  getHint: lib.symbols.SDL_GetHint,

/**
 * Get the boolean value of a hint variable.
 *
 * @param name the name of the hint to get the boolean value from.
 * @param default_value the value to return if the hint does not exist.
 * @returns the boolean value of a hint or the provided default value if the
 *          hint does not exist.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetHint
 * @sa SDL_SetHint
 *
 * @from SDL_hints.h:4417 bool SDL_GetHintBoolean(const char *name, bool default_value);
 */
  getHintBoolean: lib.symbols.SDL_GetHintBoolean,

/**
 * Add a function to watch a particular hint.
 *
 * The callback function is called _during_ this function, to provide it an
 * initial value, and again each time the hint's value changes.
 *
 * @param name the hint to watch.
 * @param callback An SDL_HintCallback function that will be called when the
 *                 hint value changes.
 * @param userdata a pointer to pass to the callback function.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RemoveHintCallback
 *
 * @from SDL_hints.h:4459 bool SDL_AddHintCallback(const char *name, SDL_HintCallback callback, void *userdata);
 */
  addHintCallback: lib.symbols.SDL_AddHintCallback,

/**
 * Remove a function watching a particular hint.
 *
 * @param name the hint being watched.
 * @param callback an SDL_HintCallback function that will be called when the
 *                 hint value changes.
 * @param userdata a pointer being passed to the callback function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddHintCallback
 *
 * @from SDL_hints.h:4475 void SDL_RemoveHintCallback(const char *name,                                                     SDL_HintCallback callback,                                                     void *userdata);
 */
  removeHintCallback: lib.symbols.SDL_RemoveHintCallback,



/*--- SDL_init ---*/

/**
 * @from SDL_init:79 SDL_INIT_
 */
  INIT: SDL_init_enums.INIT,

/**
 * @from SDL_init:459 SDL_PROP_APP_METADATA_
 */
  PROP_APP_METADATA: SDL_init_enums.PROP_APP_METADATA,

/**
 * Return values for optional main callbacks.
 *
 * Returning SDL_APP_SUCCESS or SDL_APP_FAILURE from SDL_AppInit,
 * SDL_AppEvent, or SDL_AppIterate will terminate the program and report
 * success/failure to the operating system. What that means is
 * platform-dependent. On Unix, for example, on success, the process error
 * code will be zero, and on failure it will be 1. This interface doesn't
 * allow you to return specific exit codes, just whether there was an error
 * generally or not.
 *
 * Returning SDL_APP_CONTINUE from these functions will let the app continue
 * to run.
 *
 * See
 * [Main callbacks in SDL3](https://wiki.libsdl.org/SDL3/README/main-functions#main-callbacks-in-sdl3)
 * for complete details.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_init.h:108 SDL_APP_
 */
  APP: SDL_init_enums.SDL_AppResult,



/**
 * Initialize the SDL library.
 *
 * SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the
 * two may be used interchangeably. Though for readability of your code
 * SDL_InitSubSystem() might be preferred.
 *
 * The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)
 * subsystems are initialized by default. Message boxes
 * (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
 * video subsystem, in hopes of being useful in showing an error dialog when
 * SDL_Init fails. You must specifically initialize other subsystems if you
 * use them in your application.
 *
 * Logging (such as SDL_Log) works without initialization, too.
 *
 * `flags` may be any of the following OR'd together:
 *
 * - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events
 *   subsystem
 * - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events
 *   subsystem, should be initialized on the main thread.
 * - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the
 *   events subsystem
 * - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem
 * - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the
 *   joystick subsystem
 * - `SDL_INIT_EVENTS`: events subsystem
 * - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events
 *   subsystem
 * - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events
 *   subsystem
 *
 * Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()
 * for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or
 * call SDL_Quit() to force shutdown). If a subsystem is already loaded then
 * this call will increase the ref-count and return.
 *
 * Consider reporting some basic metadata about your application before
 * calling SDL_Init, using either SDL_SetAppMetadata() or
 * SDL_SetAppMetadataProperty().
 *
 * @param flags subsystem initialization flags.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAppMetadata
 * @sa SDL_SetAppMetadataProperty
 * @sa SDL_InitSubSystem
 * @sa SDL_Quit
 * @sa SDL_SetMainReady
 * @sa SDL_WasInit
 *
 * @from SDL_init.h:235 bool SDL_Init(SDL_InitFlags flags);
 */
  init: lib.symbols.SDL_Init,

/**
 * Compatibility function to initialize the SDL library.
 *
 * This function and SDL_Init() are interchangeable.
 *
 * @param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Init
 * @sa SDL_Quit
 * @sa SDL_QuitSubSystem
 *
 * @from SDL_init.h:252 bool SDL_InitSubSystem(SDL_InitFlags flags);
 */
  initSubSystem: lib.symbols.SDL_InitSubSystem,

/**
 * Shut down specific SDL subsystems.
 *
 * You still need to call SDL_Quit() even if you close all open subsystems
 * with SDL_QuitSubSystem().
 *
 * @param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_InitSubSystem
 * @sa SDL_Quit
 *
 * @from SDL_init.h:267 void SDL_QuitSubSystem(SDL_InitFlags flags);
 */
  quitSubSystem: lib.symbols.SDL_QuitSubSystem,

/**
 * Get a mask of the specified subsystems which are currently initialized.
 *
 * @param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 * @returns a mask of all initialized subsystems if `flags` is 0, otherwise it
 *          returns the initialization status of the specified subsystems.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Init
 * @sa SDL_InitSubSystem
 *
 * @from SDL_init.h:281 SDL_InitFlags SDL_WasInit(SDL_InitFlags flags);
 */
  wasInit: lib.symbols.SDL_WasInit,

/**
 * Clean up all initialized subsystems.
 *
 * You should call this function even if you have already shutdown each
 * initialized subsystem with SDL_QuitSubSystem(). It is safe to call this
 * function even in the case of errors in initialization.
 *
 * You can use this function with atexit() to ensure that it is run when your
 * application is shutdown, but it is not wise to do this from a library or
 * other dynamically loaded code.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Init
 * @sa SDL_QuitSubSystem
 *
 * @from SDL_init.h:299 void SDL_Quit(void);
 */
  quit: lib.symbols.SDL_Quit,

/**
 * Return whether this is the main thread.
 *
 * On Apple platforms, the main thread is the thread that runs your program's
 * main() entry point. On other platforms, the main thread is the one that
 * calls SDL_Init(SDL_INIT_VIDEO), which should usually be the one that runs
 * your program's main() entry point. If you are using the main callbacks,
 * SDL_AppInit(), SDL_AppIterate(), and SDL_AppQuit() are all called on the
 * main thread.
 *
 * @returns true if this thread is the main thread, or false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RunOnMainThread
 *
 * @from SDL_init.h:319 bool SDL_IsMainThread(void);
 */
  isMainThread: lib.symbols.SDL_IsMainThread,

/**
 * Call a function on the main thread during event processing.
 *
 * If this is called on the main thread, the callback is executed immediately.
 * If this is called on another thread, this callback is queued for execution
 * on the main thread during event processing.
 *
 * Be careful of deadlocks when using this functionality. You should not have
 * the main thread wait for the current thread while this function is being
 * called with `wait_complete` true.
 *
 * @param callback the callback to call on the main thread.
 * @param userdata a pointer that is passed to `callback`.
 * @param wait_complete true to wait for the callback to complete, false to
 *                      return immediately.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_IsMainThread
 *
 * @from SDL_init.h:356 bool SDL_RunOnMainThread(SDL_MainThreadCallback callback, void *userdata, bool wait_complete);
 */
  runOnMainThread: lib.symbols.SDL_RunOnMainThread,

/**
 * Specify basic metadata about your app.
 *
 * You can optionally provide metadata about your app to SDL. This is not
 * required, but strongly encouraged.
 *
 * There are several locations where SDL can make use of metadata (an "About"
 * box in the macOS menu bar, the name of the app can be shown on some audio
 * mixers, etc). Any piece of metadata can be left as NULL, if a specific
 * detail doesn't make sense for the app.
 *
 * This function should be called as early as possible, before SDL_Init.
 * Multiple calls to this function are allowed, but various state might not
 * change once it has been set up with a previous call to this function.
 *
 * Passing a NULL removes any previous metadata.
 *
 * This is a simplified interface for the most important information. You can
 * supply significantly more detailed metadata with
 * SDL_SetAppMetadataProperty().
 *
 * @param appname The name of the application ("My Game 2: Bad Guy's
 *                Revenge!").
 * @param appversion The version of the application ("1.0.0beta5" or a git
 *                   hash, or whatever makes sense).
 * @param appidentifier A unique string in reverse-domain format that
 *                      identifies this app ("com.example.mygame2").
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAppMetadataProperty
 *
 * @from SDL_init.h:394 bool SDL_SetAppMetadata(const char *appname, const char *appversion, const char *appidentifier);
 */
  setAppMetadata: lib.symbols.SDL_SetAppMetadata,

/**
 * Specify metadata about your app through a set of properties.
 *
 * You can optionally provide metadata about your app to SDL. This is not
 * required, but strongly encouraged.
 *
 * There are several locations where SDL can make use of metadata (an "About"
 * box in the macOS menu bar, the name of the app can be shown on some audio
 * mixers, etc). Any piece of metadata can be left out, if a specific detail
 * doesn't make sense for the app.
 *
 * This function should be called as early as possible, before SDL_Init.
 * Multiple calls to this function are allowed, but various state might not
 * change once it has been set up with a previous call to this function.
 *
 * Once set, this metadata can be read using SDL_GetAppMetadataProperty().
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the
 *   application, like "My Game 2: Bad Guy's Revenge!". This will show up
 *   anywhere the OS shows the name of the application separately from window
 *   titles, such as volume control applets, etc. This defaults to "SDL
 *   Application".
 * - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is
 *   running; there are no rules on format, so "1.0.3beta2" and "April 22nd,
 *   2024" and a git hash are all valid options. This has no default.
 * - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that
 *   identifies this app. This must be in reverse-domain format, like
 *   "com.example.mygame2". This string is used by desktop compositors to
 *   identify and group windows together, as well as match applications with
 *   associated desktop settings and icons. If you plan to package your
 *   application in a container such as Flatpak, the app ID should match the
 *   name of your Flatpak container as well. This has no default.
 * - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the
 *   creator/developer/maker of this app, like "MojoWorkshop, LLC"
 * - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright
 *   notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this
 *   to one line, don't paste a copy of a whole software license in here. This
 *   has no default.
 * - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a
 *   product page, or a storefront, or even a GitHub repository, for user's
 *   further information This has no default.
 * - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.
 *   Currently this string can be "game" for a video game, "mediaplayer" for a
 *   media player, or generically "application" if nothing else applies.
 *   Future versions of SDL might add new types. This defaults to
 *   "application".
 *
 * @param name the name of the metadata property to set.
 * @param value the value of the property, or NULL to remove that property.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAppMetadataProperty
 * @sa SDL_SetAppMetadata
 *
 * @from SDL_init.h:457 bool SDL_SetAppMetadataProperty(const char *name, const char *value);
 */
  setAppMetadataProperty: lib.symbols.SDL_SetAppMetadataProperty,

/**
 * Get metadata about your app.
 *
 * This returns metadata previously set using SDL_SetAppMetadata() or
 * SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list
 * of available properties and their meanings.
 *
 * @param name the name of the metadata property to get.
 * @returns the current value of the metadata property, or the default if it
 *          is not set, NULL for properties with no default.
 *
 * @threadsafety It is safe to call this function from any thread, although
 *               the string returned is not protected and could potentially be
 *               freed if you call SDL_SetAppMetadataProperty() to set that
 *               property from another thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetAppMetadata
 * @sa SDL_SetAppMetadataProperty
 *
 * @from SDL_init.h:488 const char * SDL_GetAppMetadataProperty(const char *name);
 */
  getAppMetadataProperty: lib.symbols.SDL_GetAppMetadataProperty,



/*--- SDL_intrin ---*/

/**
 * @from SDL_intrin:262 __ARM_
 */
  __ARM: SDL_intrin_enums.__ARM,





/*--- SDL_iostream ---*/

/**
 * @from SDL_iostream:275 SDL_PROP_IOSTREAM_
 */
  PROP_IOSTREAM: SDL_iostream_enums.PROP_IOSTREAM,

/**
 * @from SDL_iostream:321 SDL_PROP_IOSTREAM_MEMORY_
 */
  PROP_IOSTREAM_MEMORY: SDL_iostream_enums.PROP_IOSTREAM_MEMORY,

/**
 * @from SDL_iostream:395 SDL_PROP_IOSTREAM_DYNAMIC_
 */
  PROP_IOSTREAM_DYNAMIC: SDL_iostream_enums.PROP_IOSTREAM_DYNAMIC,

/**
 * SDL_IOStream status, set by a read or write operation.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:52 SDL_IO_STATUS_
 */
  IO_STATUS: SDL_iostream_enums.SDL_IOStatus,

/**
 * Possible `whence` values for SDL_IOStream seeking.
 *
 * These map to the same "whence" concept that `fseek` or `lseek` use in the
 * standard C runtime.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:70 SDL_IO_SEEK_
 */
  IO_SEEK: SDL_iostream_enums.SDL_IOWhence,



/**
 * Use this function to create a new SDL_IOStream structure for reading from
 * and/or writing to a named file.
 *
 * The `mode` string is treated roughly the same as in a call to the C
 * library's fopen(), even if SDL doesn't happen to use fopen() behind the
 * scenes.
 *
 * Available `mode` strings:
 *
 * - "r": Open a file for reading. The file must exist.
 * - "w": Create an empty file for writing. If a file with the same name
 *   already exists its content is erased and the file is treated as a new
 *   empty file.
 * - "a": Append to a file. Writing operations append data at the end of the
 *   file. The file is created if it does not exist.
 * - "r+": Open a file for update both reading and writing. The file must
 *   exist.
 * - "w+": Create an empty file for both reading and writing. If a file with
 *   the same name already exists its content is erased and the file is
 *   treated as a new empty file.
 * - "a+": Open a file for reading and appending. All writing operations are
 *   performed at the end of the file, protecting the previous content to be
 *   overwritten. You can reposition (fseek, rewind) the internal pointer to
 *   anywhere in the file for reading, but writing operations will move it
 *   back to the end of file. The file is created if it does not exist.
 *
 * **NOTE**: In order to open a file as a binary file, a "b" character has to
 * be included in the `mode` string. This additional "b" character can either
 * be appended at the end of the string (thus making the following compound
 * modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
 * letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
 * Additional characters may follow the sequence, although they should have no
 * effect. For example, "t" is sometimes appended to make explicit the file is
 * a text file.
 *
 * This function supports Unicode filenames, but they must be encoded in UTF-8
 * format, regardless of the underlying operating system.
 *
 * In Android, SDL_IOFromFile() can be used to open content:// URIs. As a
 * fallback, SDL_IOFromFile() will transparently open a matching filename in
 * the app's `assets`.
 *
 * Closing the SDL_IOStream will close SDL's internal file handle.
 *
 * The following properties may be set at creation time by SDL:
 *
 * - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast
 *   to a win32 `HANDLE`, that this SDL_IOStream is using to access the
 *   filesystem. If the program isn't running on Windows, or SDL used some
 *   other method to access the filesystem, this property will not be set.
 * - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a
 *   stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.
 *   If SDL used some other method to access the filesystem, this property
 *   will not be set. PLEASE NOTE that if SDL is using a different C runtime
 *   than your app, trying to use this pointer will almost certainly result in
 *   a crash! This is mostly a problem on Windows; make sure you build SDL and
 *   your app with the same compiler and settings to avoid it.
 * - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this
 *   SDL_IOStream is using to access the filesystem.
 * - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast
 *   to an Android NDK `AAsset *`, that this SDL_IOStream is using to access
 *   the filesystem. If SDL used some other method to access the filesystem,
 *   this property will not be set.
 *
 * @param file a UTF-8 string representing the filename to open.
 * @param mode an ASCII string representing the mode to be used for opening
 *             the file.
 * @returns a pointer to the SDL_IOStream structure that is created or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseIO
 * @sa SDL_FlushIO
 * @sa SDL_ReadIO
 * @sa SDL_SeekIO
 * @sa SDL_TellIO
 * @sa SDL_WriteIO
 *
 * @from SDL_iostream.h:273 SDL_IOStream * SDL_IOFromFile(const char *file, const char *mode);
 */
  ioFromFile: lib.symbols.SDL_IOFromFile,

/**
 * Use this function to prepare a read-write memory buffer for use with
 * SDL_IOStream.
 *
 * This function sets up an SDL_IOStream struct based on a memory area of a
 * certain size, for both read and write access.
 *
 * This memory buffer is not copied by the SDL_IOStream; the pointer you
 * provide must remain valid until you close the stream. Closing the stream
 * will not free the original buffer.
 *
 * If you need to make sure the SDL_IOStream never writes to the memory
 * buffer, you should use SDL_IOFromConstMem() with a read-only buffer of
 * memory instead.
 *
 * The following properties will be set at creation time by SDL:
 *
 * - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that
 *   was passed to this function.
 * - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter
 *   that was passed to this function.
 *
 * @param mem a pointer to a buffer to feed an SDL_IOStream stream.
 * @param size the buffer size, in bytes.
 * @returns a pointer to a new SDL_IOStream structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_IOFromConstMem
 * @sa SDL_CloseIO
 * @sa SDL_FlushIO
 * @sa SDL_ReadIO
 * @sa SDL_SeekIO
 * @sa SDL_TellIO
 * @sa SDL_WriteIO
 *
 * @from SDL_iostream.h:319 SDL_IOStream * SDL_IOFromMem(void *mem, size_t size);
 */
  ioFromMem: lib.symbols.SDL_IOFromMem,

/**
 * Use this function to prepare a read-only memory buffer for use with
 * SDL_IOStream.
 *
 * This function sets up an SDL_IOStream struct based on a memory area of a
 * certain size. It assumes the memory area is not writable.
 *
 * Attempting to write to this SDL_IOStream stream will report an error
 * without writing to the memory buffer.
 *
 * This memory buffer is not copied by the SDL_IOStream; the pointer you
 * provide must remain valid until you close the stream. Closing the stream
 * will not free the original buffer.
 *
 * If you need to write to a memory buffer, you should use SDL_IOFromMem()
 * with a writable buffer of memory instead.
 *
 * The following properties will be set at creation time by SDL:
 *
 * - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that
 *   was passed to this function.
 * - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter
 *   that was passed to this function.
 *
 * @param mem a pointer to a read-only buffer to feed an SDL_IOStream stream.
 * @param size the buffer size, in bytes.
 * @returns a pointer to a new SDL_IOStream structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_IOFromMem
 * @sa SDL_CloseIO
 * @sa SDL_ReadIO
 * @sa SDL_SeekIO
 * @sa SDL_TellIO
 *
 * @from SDL_iostream.h:363 SDL_IOStream * SDL_IOFromConstMem(const void *mem, size_t size);
 */
  ioFromConstMem: lib.symbols.SDL_IOFromConstMem,

/**
 * Use this function to create an SDL_IOStream that is backed by dynamically
 * allocated memory.
 *
 * This supports the following properties to provide access to the memory and
 * control over allocations:
 *
 * - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal
 *   memory of the stream. This can be set to NULL to transfer ownership of
 *   the memory to the application, which should free the memory with
 *   SDL_free(). If this is done, the next operation on the stream must be
 *   SDL_CloseIO().
 * - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in
 *   multiples of this size, defaulting to 1024.
 *
 * @returns a pointer to a new SDL_IOStream structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseIO
 * @sa SDL_ReadIO
 * @sa SDL_SeekIO
 * @sa SDL_TellIO
 * @sa SDL_WriteIO
 *
 * @from SDL_iostream.h:393 SDL_IOStream * SDL_IOFromDynamicMem(void);
 */
  ioFromDynamicMem: lib.symbols.SDL_IOFromDynamicMem,

/**
 * Create a custom SDL_IOStream.
 *
 * Applications do not need to use this function unless they are providing
 * their own SDL_IOStream implementation. If you just need an SDL_IOStream to
 * read/write a common data source, you should use the built-in
 * implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.
 *
 * This function makes a copy of `iface` and the caller does not need to keep
 * it around after this call.
 *
 * @param iface the interface that implements this SDL_IOStream, initialized
 *              using SDL_INIT_INTERFACE().
 * @param userdata the pointer that will be passed to the interface functions.
 * @returns a pointer to the allocated memory on success or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseIO
 * @sa SDL_INIT_INTERFACE
 * @sa SDL_IOFromConstMem
 * @sa SDL_IOFromFile
 * @sa SDL_IOFromMem
 *
 * @from SDL_iostream.h:428 SDL_IOStream * SDL_OpenIO(const SDL_IOStreamInterface *iface, void *userdata);
 */
  openIo: lib.symbols.SDL_OpenIO,

/**
 * Close and free an allocated SDL_IOStream structure.
 *
 * SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any
 * resources used by the stream and frees the SDL_IOStream itself. This
 * returns true on success, or false if the stream failed to flush to its
 * output (e.g. to disk).
 *
 * Note that if this fails to flush the stream for any reason, this function
 * reports an error, but the SDL_IOStream is still invalid once this function
 * returns.
 *
 * This call flushes any buffered writes to the operating system, but there
 * are no guarantees that those writes have gone to physical media; they might
 * be in the OS's file cache, waiting to go to disk later. If it's absolutely
 * crucial that writes go to disk immediately, so they are definitely stored
 * even if the power fails before the file cache would have caught up, one
 * should call SDL_FlushIO() before closing. Note that flushing takes time and
 * makes the system and your app operate less efficiently, so do so sparingly.
 *
 * @param context SDL_IOStream structure to close.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenIO
 *
 * @from SDL_iostream.h:460 bool SDL_CloseIO(SDL_IOStream *context);
 */
  closeIo: lib.symbols.SDL_CloseIO,

/**
 * Get the properties associated with an SDL_IOStream.
 *
 * @param context a pointer to an SDL_IOStream structure.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:473 SDL_PropertiesID SDL_GetIOProperties(SDL_IOStream *context);
 */
  getIoProperties: lib.symbols.SDL_GetIOProperties,

/**
 * Query the stream status of an SDL_IOStream.
 *
 * This information can be useful to decide if a short read or write was due
 * to an error, an EOF, or a non-blocking operation that isn't yet ready to
 * complete.
 *
 * An SDL_IOStream's status is only expected to change after a SDL_ReadIO or
 * SDL_WriteIO call; don't expect it to change if you just call this query
 * function in a tight loop.
 *
 * @param context the SDL_IOStream to query.
 * @returns an SDL_IOStatus enum with the current state.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:493 SDL_IOStatus SDL_GetIOStatus(SDL_IOStream *context);
 */
  getIoStatus: lib.symbols.SDL_GetIOStatus,

/**
 * Use this function to get the size of the data stream in an SDL_IOStream.
 *
 * @param context the SDL_IOStream to get the size of the data stream from.
 * @returns the size of the data stream in the SDL_IOStream on success or a
 *          negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:507 Sint64 SDL_GetIOSize(SDL_IOStream *context);
 */
  getIoSize: lib.symbols.SDL_GetIOSize,

/**
 * Seek within an SDL_IOStream data stream.
 *
 * This function seeks to byte `offset`, relative to `whence`.
 *
 * `whence` may be any of the following values:
 *
 * - `SDL_IO_SEEK_SET`: seek from the beginning of data
 * - `SDL_IO_SEEK_CUR`: seek relative to current read point
 * - `SDL_IO_SEEK_END`: seek relative to the end of data
 *
 * If this stream can not seek, it will return -1.
 *
 * @param context a pointer to an SDL_IOStream structure.
 * @param offset an offset in bytes, relative to `whence` location; can be
 *               negative.
 * @param whence any of `SDL_IO_SEEK_SET`, `SDL_IO_SEEK_CUR`,
 *               `SDL_IO_SEEK_END`.
 * @returns the final offset in the data stream after the seek or -1 on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_TellIO
 *
 * @from SDL_iostream.h:536 Sint64 SDL_SeekIO(SDL_IOStream *context, Sint64 offset, SDL_IOWhence whence);
 */
  seekIo: lib.symbols.SDL_SeekIO,

/**
 * Determine the current read/write offset in an SDL_IOStream data stream.
 *
 * SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's
 * `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to
 * simplify application development.
 *
 * @param context an SDL_IOStream data stream object from which to get the
 *                current offset.
 * @returns the current offset in the stream, or -1 if the information can not
 *          be determined.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SeekIO
 *
 * @from SDL_iostream.h:556 Sint64 SDL_TellIO(SDL_IOStream *context);
 */
  tellIo: lib.symbols.SDL_TellIO,

/**
 * Read from a data source.
 *
 * This function reads up `size` bytes from the data source to the area
 * pointed at by `ptr`. This function may read less bytes than requested.
 *
 * This function will return zero when the data stream is completely read, and
 * SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If zero is returned and
 * the stream is not at EOF, SDL_GetIOStatus() will return a different error
 * value and SDL_GetError() will offer a human-readable message.
 *
 * @param context a pointer to an SDL_IOStream structure.
 * @param ptr a pointer to a buffer to read data into.
 * @param size the number of bytes to read from the data source.
 * @returns the number of bytes read, or 0 on end of file or other failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WriteIO
 * @sa SDL_GetIOStatus
 *
 * @from SDL_iostream.h:582 size_t SDL_ReadIO(SDL_IOStream *context, void *ptr, size_t size);
 */
  readIo: lib.symbols.SDL_ReadIO,

/**
 * Write to an SDL_IOStream data stream.
 *
 * This function writes exactly `size` bytes from the area pointed at by `ptr`
 * to the stream. If this fails for any reason, it'll return less than `size`
 * to demonstrate how far the write progressed. On success, it returns `size`.
 *
 * On error, this function still attempts to write as much as possible, so it
 * might return a positive value less than the requested write size.
 *
 * The caller can use SDL_GetIOStatus() to determine if the problem is
 * recoverable, such as a non-blocking write that can simply be retried later,
 * or a fatal error.
 *
 * @param context a pointer to an SDL_IOStream structure.
 * @param ptr a pointer to a buffer containing data to write.
 * @param size the number of bytes to write.
 * @returns the number of bytes written, which will be less than `size` on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_IOprintf
 * @sa SDL_ReadIO
 * @sa SDL_SeekIO
 * @sa SDL_FlushIO
 * @sa SDL_GetIOStatus
 *
 * @from SDL_iostream.h:614 size_t SDL_WriteIO(SDL_IOStream *context, const void *ptr, size_t size);
 */
  writeIo: lib.symbols.SDL_WriteIO,

/**
 * Flush any buffered data in the stream.
 *
 * This function makes sure that any buffered data is written to the stream.
 * Normally this isn't necessary but if the stream is a pipe or socket it
 * guarantees that any pending data is sent.
 *
 * @param context SDL_IOStream structure to flush.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenIO
 * @sa SDL_WriteIO
 *
 * @from SDL_iostream.h:675 bool SDL_FlushIO(SDL_IOStream *context);
 */
  flushIo: lib.symbols.SDL_FlushIO,

/**
 * Load all the data from an SDL data stream.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported via
 * `datasize`.
 *
 * The data should be freed with SDL_free().
 *
 * @param src the SDL_IOStream to read all available data from.
 * @param datasize a pointer filled in with the number of bytes read, may be
 *                 NULL.
 * @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * @returns the data or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LoadFile
 * @sa SDL_SaveFile_IO
 *
 * @from SDL_iostream.h:701 void * SDL_LoadFile_IO(SDL_IOStream *src, size_t *datasize, bool closeio);
 */
  loadFileIo: lib.symbols.SDL_LoadFile_IO,

/**
 * Load all the data from a file path.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported via
 * `datasize`.
 *
 * The data should be freed with SDL_free().
 *
 * @param file the path to read all available data from.
 * @param datasize if not NULL, will store the number of bytes read.
 * @returns the data or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LoadFile_IO
 * @sa SDL_SaveFile
 *
 * @from SDL_iostream.h:724 void * SDL_LoadFile(const char *file, size_t *datasize);
 */
  loadFile: lib.symbols.SDL_LoadFile,

/**
 * Save all the data into an SDL data stream.
 *
 * @param src the SDL_IOStream to write all data to.
 * @param data the data to be written. If datasize is 0, may be NULL or a
 *             invalid pointer.
 * @param datasize the number of bytes to be written.
 * @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SaveFile
 * @sa SDL_LoadFile_IO
 *
 * @from SDL_iostream.h:745 bool SDL_SaveFile_IO(SDL_IOStream *src, const void *data, size_t datasize, bool closeio);
 */
  saveFileIo: lib.symbols.SDL_SaveFile_IO,

/**
 * Save all the data into a file path.
 *
 * @param file the path to write all available data into.
 * @param data the data to be written. If datasize is 0, may be NULL or a
 *             invalid pointer.
 * @param datasize the number of bytes to be written.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SaveFile_IO
 * @sa SDL_LoadFile
 *
 * @from SDL_iostream.h:764 bool SDL_SaveFile(const char *file, const void *data, size_t datasize);
 */
  saveFile: lib.symbols.SDL_SaveFile,

/**
 * Use this function to read a byte from an SDL_IOStream.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the SDL_IOStream to read from.
 * @param value a pointer filled in with the data read.
 * @returns true on success or false on failure or EOF; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:790 bool SDL_ReadU8(SDL_IOStream *src, Uint8 *value);
 */
  readU8: lib.symbols.SDL_ReadU8,

/**
 * Use this function to read a signed byte from an SDL_IOStream.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the SDL_IOStream to read from.
 * @param value a pointer filled in with the data read.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:809 bool SDL_ReadS8(SDL_IOStream *src, Sint8 *value);
 */
  readS8: lib.symbols.SDL_ReadS8,

/**
 * Use this function to read 16 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:832 bool SDL_ReadU16LE(SDL_IOStream *src, Uint16 *value);
 */
  readU16Le: lib.symbols.SDL_ReadU16LE,

/**
 * Use this function to read 16 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:855 bool SDL_ReadS16LE(SDL_IOStream *src, Sint16 *value);
 */
  readS16Le: lib.symbols.SDL_ReadS16LE,

/**
 * Use this function to read 16 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:878 bool SDL_ReadU16BE(SDL_IOStream *src, Uint16 *value);
 */
  readU16Be: lib.symbols.SDL_ReadU16BE,

/**
 * Use this function to read 16 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:901 bool SDL_ReadS16BE(SDL_IOStream *src, Sint16 *value);
 */
  readS16Be: lib.symbols.SDL_ReadS16BE,

/**
 * Use this function to read 32 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:924 bool SDL_ReadU32LE(SDL_IOStream *src, Uint32 *value);
 */
  readU32Le: lib.symbols.SDL_ReadU32LE,

/**
 * Use this function to read 32 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:947 bool SDL_ReadS32LE(SDL_IOStream *src, Sint32 *value);
 */
  readS32Le: lib.symbols.SDL_ReadS32LE,

/**
 * Use this function to read 32 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:970 bool SDL_ReadU32BE(SDL_IOStream *src, Uint32 *value);
 */
  readU32Be: lib.symbols.SDL_ReadU32BE,

/**
 * Use this function to read 32 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:993 bool SDL_ReadS32BE(SDL_IOStream *src, Sint32 *value);
 */
  readS32Be: lib.symbols.SDL_ReadS32BE,

/**
 * Use this function to read 64 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1016 bool SDL_ReadU64LE(SDL_IOStream *src, Uint64 *value);
 */
  readU64Le: lib.symbols.SDL_ReadU64LE,

/**
 * Use this function to read 64 bits of little-endian data from an
 * SDL_IOStream and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1039 bool SDL_ReadS64LE(SDL_IOStream *src, Sint64 *value);
 */
  readS64Le: lib.symbols.SDL_ReadS64LE,

/**
 * Use this function to read 64 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1062 bool SDL_ReadU64BE(SDL_IOStream *src, Uint64 *value);
 */
  readU64Be: lib.symbols.SDL_ReadU64BE,

/**
 * Use this function to read 64 bits of big-endian data from an SDL_IOStream
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * This function will return false when the data stream is completely read,
 * and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned
 * and the stream is not at EOF, SDL_GetIOStatus() will return a different
 * error value and SDL_GetError() will offer a human-readable message.
 *
 * @param src the stream from which to read data.
 * @param value a pointer filled in with the data read.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1085 bool SDL_ReadS64BE(SDL_IOStream *src, Sint64 *value);
 */
  readS64Be: lib.symbols.SDL_ReadS64BE,

/**
 * Use this function to write a byte to an SDL_IOStream.
 *
 * @param dst the SDL_IOStream to write to.
 * @param value the byte value to write.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1107 bool SDL_WriteU8(SDL_IOStream *dst, Uint8 value);
 */
  writeU8: lib.symbols.SDL_WriteU8,

/**
 * Use this function to write a signed byte to an SDL_IOStream.
 *
 * @param dst the SDL_IOStream to write to.
 * @param value the byte value to write.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1121 bool SDL_WriteS8(SDL_IOStream *dst, Sint8 value);
 */
  writeS8: lib.symbols.SDL_WriteS8,

/**
 * Use this function to write 16 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1140 bool SDL_WriteU16LE(SDL_IOStream *dst, Uint16 value);
 */
  writeU16Le: lib.symbols.SDL_WriteU16LE,

/**
 * Use this function to write 16 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1159 bool SDL_WriteS16LE(SDL_IOStream *dst, Sint16 value);
 */
  writeS16Le: lib.symbols.SDL_WriteS16LE,

/**
 * Use this function to write 16 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1177 bool SDL_WriteU16BE(SDL_IOStream *dst, Uint16 value);
 */
  writeU16Be: lib.symbols.SDL_WriteU16BE,

/**
 * Use this function to write 16 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1195 bool SDL_WriteS16BE(SDL_IOStream *dst, Sint16 value);
 */
  writeS16Be: lib.symbols.SDL_WriteS16BE,

/**
 * Use this function to write 32 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1214 bool SDL_WriteU32LE(SDL_IOStream *dst, Uint32 value);
 */
  writeU32Le: lib.symbols.SDL_WriteU32LE,

/**
 * Use this function to write 32 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1233 bool SDL_WriteS32LE(SDL_IOStream *dst, Sint32 value);
 */
  writeS32Le: lib.symbols.SDL_WriteS32LE,

/**
 * Use this function to write 32 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1251 bool SDL_WriteU32BE(SDL_IOStream *dst, Uint32 value);
 */
  writeU32Be: lib.symbols.SDL_WriteU32BE,

/**
 * Use this function to write 32 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1269 bool SDL_WriteS32BE(SDL_IOStream *dst, Sint32 value);
 */
  writeS32Be: lib.symbols.SDL_WriteS32BE,

/**
 * Use this function to write 64 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1288 bool SDL_WriteU64LE(SDL_IOStream *dst, Uint64 value);
 */
  writeU64Le: lib.symbols.SDL_WriteU64LE,

/**
 * Use this function to write 64 bits in native format to an SDL_IOStream as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1307 bool SDL_WriteS64LE(SDL_IOStream *dst, Sint64 value);
 */
  writeS64Le: lib.symbols.SDL_WriteS64LE,

/**
 * Use this function to write 64 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1325 bool SDL_WriteU64BE(SDL_IOStream *dst, Uint64 value);
 */
  writeU64Be: lib.symbols.SDL_WriteU64BE,

/**
 * Use this function to write 64 bits in native format to an SDL_IOStream as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * @param dst the stream to which data will be written.
 * @param value the data to be written, in native format.
 * @returns true on successful write or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_iostream.h:1343 bool SDL_WriteS64BE(SDL_IOStream *dst, Sint64 value);
 */
  writeS64Be: lib.symbols.SDL_WriteS64BE,



/*--- SDL_joystick ---*/

/**
 * @from SDL_joystick:654 SDL_PROP_JOYSTICK_CAP_
 */
  PROP_JOYSTICK_CAP: SDL_joystick_enums.PROP_JOYSTICK_CAP,

/**
 * @from SDL_joystick:1044 SDL_HAT_
 */
  HAT: SDL_joystick_enums.HAT,

/**
 * An enum of some common joystick types.
 *
 * In some cases, SDL can identify a low-level joystick as being a certain
 * type of device, and will report it through SDL_GetJoystickType (or
 * SDL_GetJoystickTypeForID).
 *
 * This is by no means a complete list of everything that can be plugged into
 * a computer.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:111 SDL_JOYSTICK_TYPE_
 */
  JOYSTICK_TYPE: SDL_joystick_enums.SDL_JoystickType,

/**
 * Possible connection states for a joystick device.
 *
 * This is used by SDL_GetJoystickConnectionState to report how a device is
 * connected to the system.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:134 SDL_JOYSTICK_CONNECTION_
 */
  JOYSTICK_CONNECTION: SDL_joystick_enums.SDL_JoystickConnectionState,



/**
 * Locking for atomic access to the joystick API.
 *
 * The SDL joystick functions are thread-safe, however you can lock the
 * joysticks while processing to guarantee that the joystick list won't change
 * and joystick and gamepad events will not be delivered.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:174 void SDL_LockJoysticks(void) SDL_ACQUIRE(SDL_joystick_lock);
 */
  lockJoysticks: lib.symbols.SDL_LockJoysticks,

/**
 * Unlocking for atomic access to the joystick API.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:181 void SDL_UnlockJoysticks(void) SDL_RELEASE(SDL_joystick_lock);
 */
  unlockJoysticks: lib.symbols.SDL_UnlockJoysticks,

/**
 * Return whether a joystick is currently connected.
 *
 * @returns true if a joystick is connected, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoysticks
 *
 * @from SDL_joystick.h:192 bool SDL_HasJoystick(void);
 */
  hasJoystick: lib.symbols.SDL_HasJoystick,

/**
 * Get a list of currently connected joysticks.
 *
 * @param count a pointer filled in with the number of joysticks returned, may
 *              be NULL.
 * @returns a 0 terminated array of joystick instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasJoystick
 * @sa SDL_OpenJoystick
 *
 * @from SDL_joystick.h:208 SDL_JoystickID * SDL_GetJoysticks(int *count);
 */
  getJoysticks: lib.symbols.SDL_GetJoysticks,

/**
 * Get the implementation dependent name of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the name of the selected joystick. If no name can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickName
 * @sa SDL_GetJoysticks
 *
 * @from SDL_joystick.h:224 const char * SDL_GetJoystickNameForID(SDL_JoystickID instance_id);
 */
  getJoystickNameForId: lib.symbols.SDL_GetJoystickNameForID,

/**
 * Get the implementation dependent path of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the path of the selected joystick. If no path can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickPath
 * @sa SDL_GetJoysticks
 *
 * @from SDL_joystick.h:240 const char * SDL_GetJoystickPathForID(SDL_JoystickID instance_id);
 */
  getJoystickPathForId: lib.symbols.SDL_GetJoystickPathForID,

/**
 * Get the player index of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the player index of a joystick, or -1 if it's not available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickPlayerIndex
 * @sa SDL_GetJoysticks
 *
 * @from SDL_joystick.h:255 int SDL_GetJoystickPlayerIndexForID(SDL_JoystickID instance_id);
 */
  getJoystickPlayerIndexForId: lib.symbols.SDL_GetJoystickPlayerIndexForID,

/**
 * Get the implementation-dependent GUID of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the GUID of the selected joystick. If called with an invalid
 *          instance_id, this function returns a zero GUID.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickGUID
 * @sa SDL_GUIDToString
 *
 * @from SDL_joystick.h:271 SDL_GUID SDL_GetJoystickGUIDForID(SDL_JoystickID instance_id);
 */
  getJoystickGuidForId: lib.symbols.SDL_GetJoystickGUIDForID,

/**
 * Get the USB vendor ID of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the vendor ID isn't
 * available this function returns 0.
 *
 * @param instance_id the joystick instance ID.
 * @returns the USB vendor ID of the selected joystick. If called with an
 *          invalid instance_id, this function returns 0.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickVendor
 * @sa SDL_GetJoysticks
 *
 * @from SDL_joystick.h:288 Uint16 SDL_GetJoystickVendorForID(SDL_JoystickID instance_id);
 */
  getJoystickVendorForId: lib.symbols.SDL_GetJoystickVendorForID,

/**
 * Get the USB product ID of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the product ID isn't
 * available this function returns 0.
 *
 * @param instance_id the joystick instance ID.
 * @returns the USB product ID of the selected joystick. If called with an
 *          invalid instance_id, this function returns 0.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickProduct
 * @sa SDL_GetJoysticks
 *
 * @from SDL_joystick.h:305 Uint16 SDL_GetJoystickProductForID(SDL_JoystickID instance_id);
 */
  getJoystickProductForId: lib.symbols.SDL_GetJoystickProductForID,

/**
 * Get the product version of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the product version
 * isn't available this function returns 0.
 *
 * @param instance_id the joystick instance ID.
 * @returns the product version of the selected joystick. If called with an
 *          invalid instance_id, this function returns 0.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickProductVersion
 * @sa SDL_GetJoysticks
 *
 * @from SDL_joystick.h:322 Uint16 SDL_GetJoystickProductVersionForID(SDL_JoystickID instance_id);
 */
  getJoystickProductVersionForId: lib.symbols.SDL_GetJoystickProductVersionForID,

/**
 * Get the type of a joystick, if available.
 *
 * This can be called before any joysticks are opened.
 *
 * @param instance_id the joystick instance ID.
 * @returns the SDL_JoystickType of the selected joystick. If called with an
 *          invalid instance_id, this function returns
 *          `SDL_JOYSTICK_TYPE_UNKNOWN`.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickType
 * @sa SDL_GetJoysticks
 *
 * @from SDL_joystick.h:339 SDL_JoystickType SDL_GetJoystickTypeForID(SDL_JoystickID instance_id);
 */
  getJoystickTypeForId: lib.symbols.SDL_GetJoystickTypeForID,

/**
 * Open a joystick for use.
 *
 * The joystick subsystem must be initialized before a joystick can be opened
 * for use.
 *
 * @param instance_id the joystick instance ID.
 * @returns a joystick identifier or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseJoystick
 *
 * @from SDL_joystick.h:355 SDL_Joystick * SDL_OpenJoystick(SDL_JoystickID instance_id);
 */
  openJoystick: lib.symbols.SDL_OpenJoystick,

/**
 * Get the SDL_Joystick associated with an instance ID, if it has been opened.
 *
 * @param instance_id the instance ID to get the SDL_Joystick for.
 * @returns an SDL_Joystick on success or NULL on failure or if it hasn't been
 *          opened yet; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:366 SDL_Joystick * SDL_GetJoystickFromID(SDL_JoystickID instance_id);
 */
  getJoystickFromId: lib.symbols.SDL_GetJoystickFromID,

/**
 * Get the SDL_Joystick associated with a player index.
 *
 * @param player_index the player index to get the SDL_Joystick for.
 * @returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickPlayerIndex
 * @sa SDL_SetJoystickPlayerIndex
 *
 * @from SDL_joystick.h:380 SDL_Joystick * SDL_GetJoystickFromPlayerIndex(int player_index);
 */
  getJoystickFromPlayerIndex: lib.symbols.SDL_GetJoystickFromPlayerIndex,

/**
 * Attach a new virtual joystick.
 *
 * @param desc joystick description, initialized using SDL_INIT_INTERFACE().
 * @returns the joystick instance ID, or 0 on failure; call SDL_GetError() for
 *          more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DetachVirtualJoystick
 *
 * @from SDL_joystick.h:475 SDL_JoystickID SDL_AttachVirtualJoystick(const SDL_VirtualJoystickDesc *desc);
 */
  attachVirtualJoystick: lib.symbols.SDL_AttachVirtualJoystick,

/**
 * Detach a virtual joystick.
 *
 * @param instance_id the joystick instance ID, previously returned from
 *                    SDL_AttachVirtualJoystick().
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AttachVirtualJoystick
 *
 * @from SDL_joystick.h:489 bool SDL_DetachVirtualJoystick(SDL_JoystickID instance_id);
 */
  detachVirtualJoystick: lib.symbols.SDL_DetachVirtualJoystick,

/**
 * Query whether or not a joystick is virtual.
 *
 * @param instance_id the joystick instance ID.
 * @returns true if the joystick is virtual, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:499 bool SDL_IsJoystickVirtual(SDL_JoystickID instance_id);
 */
  isJoystickVirtual: lib.symbols.SDL_IsJoystickVirtual,

/**
 * Set the state of an axis on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * Note that when sending trigger axes, you should scale the value to the full
 * range of Sint16. For example, a trigger at rest would have the value of
 * `SDL_JOYSTICK_AXIS_MIN`.
 *
 * @param joystick the virtual joystick on which to set state.
 * @param axis the index of the axis on the virtual joystick to update.
 * @param value the new value for the specified axis.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:522 bool SDL_SetJoystickVirtualAxis(SDL_Joystick *joystick, int axis, Sint16 value);
 */
  setJoystickVirtualAxis: lib.symbols.SDL_SetJoystickVirtualAxis,

/**
 * Generate ball motion on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * @param joystick the virtual joystick on which to set state.
 * @param ball the index of the ball on the virtual joystick to update.
 * @param xrel the relative motion on the X axis.
 * @param yrel the relative motion on the Y axis.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:542 bool SDL_SetJoystickVirtualBall(SDL_Joystick *joystick, int ball, Sint16 xrel, Sint16 yrel);
 */
  setJoystickVirtualBall: lib.symbols.SDL_SetJoystickVirtualBall,

/**
 * Set the state of a button on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * @param joystick the virtual joystick on which to set state.
 * @param button the index of the button on the virtual joystick to update.
 * @param down true if the button is pressed, false otherwise.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:561 bool SDL_SetJoystickVirtualButton(SDL_Joystick *joystick, int button, bool down);
 */
  setJoystickVirtualButton: lib.symbols.SDL_SetJoystickVirtualButton,

/**
 * Set the state of a hat on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * @param joystick the virtual joystick on which to set state.
 * @param hat the index of the hat on the virtual joystick to update.
 * @param value the new value for the specified hat.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:580 bool SDL_SetJoystickVirtualHat(SDL_Joystick *joystick, int hat, Uint8 value);
 */
  setJoystickVirtualHat: lib.symbols.SDL_SetJoystickVirtualHat,

/**
 * Set touchpad finger state on an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * @param joystick the virtual joystick on which to set state.
 * @param touchpad the index of the touchpad on the virtual joystick to
 *                 update.
 * @param finger the index of the finger on the touchpad to set.
 * @param down true if the finger is pressed, false if the finger is released.
 * @param x the x coordinate of the finger on the touchpad, normalized 0 to 1,
 *          with the origin in the upper left.
 * @param y the y coordinate of the finger on the touchpad, normalized 0 to 1,
 *          with the origin in the upper left.
 * @param pressure the pressure of the finger.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:606 bool SDL_SetJoystickVirtualTouchpad(SDL_Joystick *joystick, int touchpad, int finger, bool down, float x, float y, float pressure);
 */
  setJoystickVirtualTouchpad: lib.symbols.SDL_SetJoystickVirtualTouchpad,

/**
 * Send a sensor update for an opened virtual joystick.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_UpdateJoysticks, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * @param joystick the virtual joystick on which to set state.
 * @param type the type of the sensor on the virtual joystick to update.
 * @param sensor_timestamp a 64-bit timestamp in nanoseconds associated with
 *                         the sensor reading.
 * @param data the data associated with the sensor reading.
 * @param num_values the number of values pointed to by `data`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:628 bool SDL_SendJoystickVirtualSensorData(SDL_Joystick *joystick, SDL_SensorType type, Uint64 sensor_timestamp, const float *data, int num_values);
 */
  sendJoystickVirtualSensorData: lib.symbols.SDL_SendJoystickVirtualSensorData,

/**
 * Get the properties associated with a joystick.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an
 *   LED that has adjustable brightness
 * - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED
 *   that has adjustable color
 * - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a
 *   player LED
 * - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has
 *   left/right rumble
 * - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has
 *   simple trigger rumble
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:652 SDL_PropertiesID SDL_GetJoystickProperties(SDL_Joystick *joystick);
 */
  getJoystickProperties: lib.symbols.SDL_GetJoystickProperties,

/**
 * Get the implementation dependent name of a joystick.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the name of the selected joystick. If no name can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickNameForID
 *
 * @from SDL_joystick.h:671 const char * SDL_GetJoystickName(SDL_Joystick *joystick);
 */
  getJoystickName: lib.symbols.SDL_GetJoystickName,

/**
 * Get the implementation dependent path of a joystick.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the path of the selected joystick. If no path can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickPathForID
 *
 * @from SDL_joystick.h:684 const char * SDL_GetJoystickPath(SDL_Joystick *joystick);
 */
  getJoystickPath: lib.symbols.SDL_GetJoystickPath,

/**
 * Get the player index of an opened joystick.
 *
 * For XInput controllers this returns the XInput user index. Many joysticks
 * will not be able to supply this information.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the player index, or -1 if it's not available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetJoystickPlayerIndex
 *
 * @from SDL_joystick.h:699 int SDL_GetJoystickPlayerIndex(SDL_Joystick *joystick);
 */
  getJoystickPlayerIndex: lib.symbols.SDL_GetJoystickPlayerIndex,

/**
 * Set the player index of an opened joystick.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @param player_index player index to assign to this joystick, or -1 to clear
 *                     the player index and turn off player LEDs.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickPlayerIndex
 *
 * @from SDL_joystick.h:714 bool SDL_SetJoystickPlayerIndex(SDL_Joystick *joystick, int player_index);
 */
  setJoystickPlayerIndex: lib.symbols.SDL_SetJoystickPlayerIndex,

/**
 * Get the implementation-dependent GUID for the joystick.
 *
 * This function requires an open joystick.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the GUID of the given joystick. If called on an invalid index,
 *          this function returns a zero GUID; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickGUIDForID
 * @sa SDL_GUIDToString
 *
 * @from SDL_joystick.h:731 SDL_GUID SDL_GetJoystickGUID(SDL_Joystick *joystick);
 */
  getJoystickGuid: lib.symbols.SDL_GetJoystickGUID,

/**
 * Get the USB vendor ID of an opened joystick, if available.
 *
 * If the vendor ID isn't available this function returns 0.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the USB vendor ID of the selected joystick, or 0 if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickVendorForID
 *
 * @from SDL_joystick.h:745 Uint16 SDL_GetJoystickVendor(SDL_Joystick *joystick);
 */
  getJoystickVendor: lib.symbols.SDL_GetJoystickVendor,

/**
 * Get the USB product ID of an opened joystick, if available.
 *
 * If the product ID isn't available this function returns 0.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the USB product ID of the selected joystick, or 0 if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickProductForID
 *
 * @from SDL_joystick.h:759 Uint16 SDL_GetJoystickProduct(SDL_Joystick *joystick);
 */
  getJoystickProduct: lib.symbols.SDL_GetJoystickProduct,

/**
 * Get the product version of an opened joystick, if available.
 *
 * If the product version isn't available this function returns 0.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the product version of the selected joystick, or 0 if unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickProductVersionForID
 *
 * @from SDL_joystick.h:773 Uint16 SDL_GetJoystickProductVersion(SDL_Joystick *joystick);
 */
  getJoystickProductVersion: lib.symbols.SDL_GetJoystickProductVersion,

/**
 * Get the firmware version of an opened joystick, if available.
 *
 * If the firmware version isn't available this function returns 0.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the firmware version of the selected joystick, or 0 if
 *          unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:786 Uint16 SDL_GetJoystickFirmwareVersion(SDL_Joystick *joystick);
 */
  getJoystickFirmwareVersion: lib.symbols.SDL_GetJoystickFirmwareVersion,

/**
 * Get the serial number of an opened joystick, if available.
 *
 * Returns the serial number of the joystick, or NULL if it is not available.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the serial number of the selected joystick, or NULL if
 *          unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:799 const char * SDL_GetJoystickSerial(SDL_Joystick *joystick);
 */
  getJoystickSerial: lib.symbols.SDL_GetJoystickSerial,

/**
 * Get the type of an opened joystick.
 *
 * @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().
 * @returns the SDL_JoystickType of the selected joystick.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickTypeForID
 *
 * @from SDL_joystick.h:811 SDL_JoystickType SDL_GetJoystickType(SDL_Joystick *joystick);
 */
  getJoystickType: lib.symbols.SDL_GetJoystickType,

/**
 * Get the device information encoded in a SDL_GUID structure.
 *
 * @param guid the SDL_GUID you wish to get info about.
 * @param vendor a pointer filled in with the device VID, or 0 if not
 *               available.
 * @param product a pointer filled in with the device PID, or 0 if not
 *                available.
 * @param version a pointer filled in with the device version, or 0 if not
 *                available.
 * @param crc16 a pointer filled in with a CRC used to distinguish different
 *              products with the same VID/PID, or 0 if not available.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickGUIDForID
 *
 * @from SDL_joystick.h:830 void SDL_GetJoystickGUIDInfo(SDL_GUID guid, Uint16 *vendor, Uint16 *product, Uint16 *version, Uint16 *crc16);
 */
  getJoystickGuidInfo: lib.symbols.SDL_GetJoystickGUIDInfo,

/**
 * Get the status of a specified joystick.
 *
 * @param joystick the joystick to query.
 * @returns true if the joystick has been opened, false if it has not; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:841 bool SDL_JoystickConnected(SDL_Joystick *joystick);
 */
  joystickConnected: lib.symbols.SDL_JoystickConnected,

/**
 * Get the instance ID of an opened joystick.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @returns the instance ID of the specified joystick on success or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:852 SDL_JoystickID SDL_GetJoystickID(SDL_Joystick *joystick);
 */
  getJoystickId: lib.symbols.SDL_GetJoystickID,

/**
 * Get the number of general axis controls on a joystick.
 *
 * Often, the directional pad on a game controller will either look like 4
 * separate buttons or a POV hat, and not axes, but all of this is up to the
 * device and platform.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @returns the number of axis controls/number of axes on success or -1 on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickAxis
 * @sa SDL_GetNumJoystickBalls
 * @sa SDL_GetNumJoystickButtons
 * @sa SDL_GetNumJoystickHats
 *
 * @from SDL_joystick.h:872 int SDL_GetNumJoystickAxes(SDL_Joystick *joystick);
 */
  getNumJoystickAxes: lib.symbols.SDL_GetNumJoystickAxes,

/**
 * Get the number of trackballs on a joystick.
 *
 * Joystick trackballs have only relative motion events associated with them
 * and their state cannot be polled.
 *
 * Most joysticks do not have trackballs.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @returns the number of trackballs on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickBall
 * @sa SDL_GetNumJoystickAxes
 * @sa SDL_GetNumJoystickButtons
 * @sa SDL_GetNumJoystickHats
 *
 * @from SDL_joystick.h:893 int SDL_GetNumJoystickBalls(SDL_Joystick *joystick);
 */
  getNumJoystickBalls: lib.symbols.SDL_GetNumJoystickBalls,

/**
 * Get the number of POV hats on a joystick.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @returns the number of POV hats on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickHat
 * @sa SDL_GetNumJoystickAxes
 * @sa SDL_GetNumJoystickBalls
 * @sa SDL_GetNumJoystickButtons
 *
 * @from SDL_joystick.h:909 int SDL_GetNumJoystickHats(SDL_Joystick *joystick);
 */
  getNumJoystickHats: lib.symbols.SDL_GetNumJoystickHats,

/**
 * Get the number of buttons on a joystick.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @returns the number of buttons on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetJoystickButton
 * @sa SDL_GetNumJoystickAxes
 * @sa SDL_GetNumJoystickBalls
 * @sa SDL_GetNumJoystickHats
 *
 * @from SDL_joystick.h:925 int SDL_GetNumJoystickButtons(SDL_Joystick *joystick);
 */
  getNumJoystickButtons: lib.symbols.SDL_GetNumJoystickButtons,

/**
 * Set the state of joystick event processing.
 *
 * If joystick events are disabled, you must call SDL_UpdateJoysticks()
 * yourself and check the state of the joystick when you want joystick
 * information.
 *
 * @param enabled whether to process joystick events or not.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_JoystickEventsEnabled
 * @sa SDL_UpdateJoysticks
 *
 * @from SDL_joystick.h:941 void SDL_SetJoystickEventsEnabled(bool enabled);
 */
  setJoystickEventsEnabled: lib.symbols.SDL_SetJoystickEventsEnabled,

/**
 * Query the state of joystick event processing.
 *
 * If joystick events are disabled, you must call SDL_UpdateJoysticks()
 * yourself and check the state of the joystick when you want joystick
 * information.
 *
 * @returns true if joystick events are being processed, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetJoystickEventsEnabled
 *
 * @from SDL_joystick.h:956 bool SDL_JoystickEventsEnabled(void);
 */
  joystickEventsEnabled: lib.symbols.SDL_JoystickEventsEnabled,

/**
 * Update the current state of the open joysticks.
 *
 * This is called automatically by the event loop if any joystick events are
 * enabled.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:966 void SDL_UpdateJoysticks(void);
 */
  updateJoysticks: lib.symbols.SDL_UpdateJoysticks,

/**
 * Get the current state of an axis control on a joystick.
 *
 * SDL makes no promises about what part of the joystick any given axis refers
 * to. Your game should have some sort of configuration UI to let users
 * specify what each axis should be bound to. Alternately, SDL's higher-level
 * Game Controller API makes a great effort to apply order to this lower-level
 * interface, so you know that a specific axis is the "left thumb stick," etc.
 *
 * The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to
 * 32767) representing the current position of the axis. It may be necessary
 * to impose certain tolerances on these values to account for jitter.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @param axis the axis to query; the axis indices start at index 0.
 * @returns a 16-bit signed integer representing the current position of the
 *          axis or 0 on failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumJoystickAxes
 *
 * @from SDL_joystick.h:990 Sint16 SDL_GetJoystickAxis(SDL_Joystick *joystick, int axis);
 */
  getJoystickAxis: lib.symbols.SDL_GetJoystickAxis,

/**
 * Get the initial state of an axis control on a joystick.
 *
 * The state is a value ranging from -32768 to 32767.
 *
 * The axis indices start at index 0.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @param axis the axis to query; the axis indices start at index 0.
 * @param state upon return, the initial value is supplied here.
 * @returns true if this axis has any initial value, or false if not.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:1006 bool SDL_GetJoystickAxisInitialState(SDL_Joystick *joystick, int axis, Sint16 *state);
 */
  getJoystickAxisInitialState: lib.symbols.SDL_GetJoystickAxisInitialState,

/**
 * Get the ball axis change since the last poll.
 *
 * Trackballs can only return relative motion since the last call to
 * SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.
 *
 * Most joysticks do not have trackballs.
 *
 * @param joystick the SDL_Joystick to query.
 * @param ball the ball index to query; ball indices start at index 0.
 * @param dx stores the difference in the x axis position since the last poll.
 * @param dy stores the difference in the y axis position since the last poll.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumJoystickBalls
 *
 * @from SDL_joystick.h:1027 bool SDL_GetJoystickBall(SDL_Joystick *joystick, int ball, int *dx, int *dy);
 */
  getJoystickBall: lib.symbols.SDL_GetJoystickBall,

/**
 * Get the current state of a POV hat on a joystick.
 *
 * The returned value will be one of the `SDL_HAT_*` values.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @param hat the hat index to get the state from; indices start at index 0.
 * @returns the current hat position.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumJoystickHats
 *
 * @from SDL_joystick.h:1042 Uint8 SDL_GetJoystickHat(SDL_Joystick *joystick, int hat);
 */
  getJoystickHat: lib.symbols.SDL_GetJoystickHat,

/**
 * Get the current state of a button on a joystick.
 *
 * @param joystick an SDL_Joystick structure containing joystick information.
 * @param button the button index to get the state from; indices start at
 *               index 0.
 * @returns true if the button is pressed, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumJoystickButtons
 *
 * @from SDL_joystick.h:1066 bool SDL_GetJoystickButton(SDL_Joystick *joystick, int button);
 */
  getJoystickButton: lib.symbols.SDL_GetJoystickButton,

/**
 * Start a rumble effect.
 *
 * Each call to this function cancels any previous rumble effect, and calling
 * it with 0 intensity stops any rumbling.
 *
 * This function requires you to process SDL events or call
 * SDL_UpdateJoysticks() to update rumble state.
 *
 * @param joystick the joystick to vibrate.
 * @param low_frequency_rumble the intensity of the low frequency (left)
 *                             rumble motor, from 0 to 0xFFFF.
 * @param high_frequency_rumble the intensity of the high frequency (right)
 *                              rumble motor, from 0 to 0xFFFF.
 * @param duration_ms the duration of the rumble effect, in milliseconds.
 * @returns true, or false if rumble isn't supported on this joystick.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:1087 bool SDL_RumbleJoystick(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
 */
  rumbleJoystick: lib.symbols.SDL_RumbleJoystick,

/**
 * Start a rumble effect in the joystick's triggers.
 *
 * Each call to this function cancels any previous trigger rumble effect, and
 * calling it with 0 intensity stops any rumbling.
 *
 * Note that this is rumbling of the _triggers_ and not the game controller as
 * a whole. This is currently only supported on Xbox One controllers. If you
 * want the (more common) whole-controller rumble, use SDL_RumbleJoystick()
 * instead.
 *
 * This function requires you to process SDL events or call
 * SDL_UpdateJoysticks() to update rumble state.
 *
 * @param joystick the joystick to vibrate.
 * @param left_rumble the intensity of the left trigger rumble motor, from 0
 *                    to 0xFFFF.
 * @param right_rumble the intensity of the right trigger rumble motor, from 0
 *                     to 0xFFFF.
 * @param duration_ms the duration of the rumble effect, in milliseconds.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RumbleJoystick
 *
 * @from SDL_joystick.h:1116 bool SDL_RumbleJoystickTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
 */
  rumbleJoystickTriggers: lib.symbols.SDL_RumbleJoystickTriggers,

/**
 * Update a joystick's LED color.
 *
 * An example of a joystick LED is the light on the back of a PlayStation 4's
 * DualShock 4 controller.
 *
 * For joysticks with a single color LED, the maximum of the RGB values will
 * be used as the LED brightness.
 *
 * @param joystick the joystick to update.
 * @param red the intensity of the red LED.
 * @param green the intensity of the green LED.
 * @param blue the intensity of the blue LED.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:1136 bool SDL_SetJoystickLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue);
 */
  setJoystickLed: lib.symbols.SDL_SetJoystickLED,

/**
 * Send a joystick specific effect packet.
 *
 * @param joystick the joystick to affect.
 * @param data the data to send to the joystick.
 * @param size the size of the data to send to the joystick.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:1149 bool SDL_SendJoystickEffect(SDL_Joystick *joystick, const void *data, int size);
 */
  sendJoystickEffect: lib.symbols.SDL_SendJoystickEffect,

/**
 * Close a joystick previously opened with SDL_OpenJoystick().
 *
 * @param joystick the joystick device to close.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenJoystick
 *
 * @from SDL_joystick.h:1160 void SDL_CloseJoystick(SDL_Joystick *joystick);
 */
  closeJoystick: lib.symbols.SDL_CloseJoystick,

/**
 * Get the connection state of a joystick.
 *
 * @param joystick the joystick to query.
 * @returns the connection state on success or
 *          `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:1172 SDL_JoystickConnectionState SDL_GetJoystickConnectionState(SDL_Joystick *joystick);
 */
  getJoystickConnectionState: lib.symbols.SDL_GetJoystickConnectionState,

/**
 * Get the battery state of a joystick.
 *
 * You should never take a battery status as absolute truth. Batteries
 * (especially failing batteries) are delicate hardware, and the values
 * reported here are best estimates based on what that hardware reports. It's
 * not uncommon for older batteries to lose stored power much faster than it
 * reports, or completely drain when reporting it has 20 percent left, etc.
 *
 * @param joystick the joystick to query.
 * @param percent a pointer filled in with the percentage of battery life
 *                left, between 0 and 100, or NULL to ignore. This will be
 *                filled in with -1 we can't determine a value or there is no
 *                battery.
 * @returns the current battery state or `SDL_POWERSTATE_ERROR` on failure;
 *          call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_joystick.h:1193 SDL_PowerState SDL_GetJoystickPowerInfo(SDL_Joystick *joystick, int *percent);
 */
  getJoystickPowerInfo: lib.symbols.SDL_GetJoystickPowerInfo,



/*--- SDL_keyboard ---*/

/**
 * @from SDL_keyboard:475 SDL_PROP_TEXTINPUT_
 */
  PROP_TEXTINPUT: SDL_keyboard_enums.PROP_TEXTINPUT,

/**
 * Text input type.
 *
 * These are the valid values for SDL_PROP_TEXTINPUT_TYPE_NUMBER. Not every
 * value is valid on every platform, but where a value isn't supported, a
 * reasonable fallback will be used.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_StartTextInputWithProperties
 *
 * @from SDL_keyboard.h:391 SDL_TEXTINPUT_TYPE_
 */
  TEXTINPUT_TYPE: SDL_keyboard_enums.SDL_TextInputType,

/**
 * Auto capitalization type.
 *
 * These are the valid values for SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER.
 * Not every value is valid on every platform, but where a value isn't
 * supported, a reasonable fallback will be used.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_StartTextInputWithProperties
 *
 * @from SDL_keyboard.h:415 SDL_CAPITALIZE_
 */
  CAPITALIZE: SDL_keyboard_enums.SDL_Capitalization,



/**
 * Return whether a keyboard is currently connected.
 *
 * @returns true if a keyboard is connected, false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyboards
 *
 * @from SDL_keyboard.h:74 bool SDL_HasKeyboard(void);
 */
  hasKeyboard: lib.symbols.SDL_HasKeyboard,

/**
 * Get a list of currently connected keyboards.
 *
 * Note that this will include any device or virtual driver that includes
 * keyboard functionality, including some mice, KVM switches, motherboard
 * power buttons, etc. You should wait for input from a device before you
 * consider it actively in use.
 *
 * @param count a pointer filled in with the number of keyboards returned, may
 *              be NULL.
 * @returns a 0 terminated array of keyboards instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyboardNameForID
 * @sa SDL_HasKeyboard
 *
 * @from SDL_keyboard.h:97 SDL_KeyboardID * SDL_GetKeyboards(int *count);
 */
  getKeyboards: lib.symbols.SDL_GetKeyboards,

/**
 * Get the name of a keyboard.
 *
 * This function returns "" if the keyboard doesn't have a name.
 *
 * @param instance_id the keyboard instance ID.
 * @returns the name of the selected keyboard or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyboards
 *
 * @from SDL_keyboard.h:114 const char * SDL_GetKeyboardNameForID(SDL_KeyboardID instance_id);
 */
  getKeyboardNameForId: lib.symbols.SDL_GetKeyboardNameForID,

/**
 * Query the window which currently has keyboard focus.
 *
 * @returns the window with keyboard focus.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_keyboard.h:125 SDL_Window * SDL_GetKeyboardFocus(void);
 */
  getKeyboardFocus: lib.symbols.SDL_GetKeyboardFocus,

/**
 * Get a snapshot of the current state of the keyboard.
 *
 * The pointer returned is a pointer to an internal SDL array. It will be
 * valid for the whole lifetime of the application and should not be freed by
 * the caller.
 *
 * A array element with a value of true means that the key is pressed and a
 * value of false means that it is not. Indexes into this array are obtained
 * by using SDL_Scancode values.
 *
 * Use SDL_PumpEvents() to update the state array.
 *
 * This function gives you the current state after all events have been
 * processed, so if a key or button has been pressed and released before you
 * process events, then the pressed state will never show up in the
 * SDL_GetKeyboardState() calls.
 *
 * Note: This function doesn't take into account whether shift has been
 * pressed or not.
 *
 * @param numkeys if non-NULL, receives the length of the returned array.
 * @returns a pointer to an array of key states.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_PumpEvents
 * @sa SDL_ResetKeyboard
 *
 * @from SDL_keyboard.h:158 const bool * SDL_GetKeyboardState(int *numkeys);
 */
  getKeyboardState: lib.symbols.SDL_GetKeyboardState,

/**
 * Clear the state of the keyboard.
 *
 * This function will generate key up events for all pressed keys.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyboardState
 *
 * @from SDL_keyboard.h:171 void SDL_ResetKeyboard(void);
 */
  resetKeyboard: lib.symbols.SDL_ResetKeyboard,

/**
 * Get the current key modifier state for the keyboard.
 *
 * @returns an OR'd combination of the modifier keys for the keyboard. See
 *          SDL_Keymod for details.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyboardState
 * @sa SDL_SetModState
 *
 * @from SDL_keyboard.h:186 SDL_Keymod SDL_GetModState(void);
 */
  getModState: lib.symbols.SDL_GetModState,

/**
 * Set the current key modifier state for the keyboard.
 *
 * The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose
 * modifier key states on your application. Simply pass your desired modifier
 * states into `modstate`. This value may be a bitwise, OR'd combination of
 * SDL_Keymod values.
 *
 * This does not change the keyboard state, only the key modifier flags that
 * SDL reports.
 *
 * @param modstate the desired SDL_Keymod for the keyboard.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetModState
 *
 * @from SDL_keyboard.h:207 void SDL_SetModState(SDL_Keymod modstate);
 */
  setModState: lib.symbols.SDL_SetModState,

/**
 * Get the key code corresponding to the given scancode according to the
 * current keyboard layout.
 *
 * If you want to get the keycode as it would be delivered in key events,
 * including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should
 * pass `key_event` as true. Otherwise this function simply translates the
 * scancode based on the given modifier state.
 *
 * @param scancode the desired SDL_Scancode to query.
 * @param modstate the modifier state to use when translating the scancode to
 *                 a keycode.
 * @param key_event true if the keycode will be used in key events.
 * @returns the SDL_Keycode that corresponds to the given SDL_Scancode.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyName
 * @sa SDL_GetScancodeFromKey
 *
 * @from SDL_keyboard.h:231 SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode, SDL_Keymod modstate, bool key_event);
 */
  getKeyFromScancode: lib.symbols.SDL_GetKeyFromScancode,

/**
 * Get the scancode corresponding to the given key code according to the
 * current keyboard layout.
 *
 * Note that there may be multiple scancode+modifier states that can generate
 * this keycode, this will just return the first one found.
 *
 * @param key the desired SDL_Keycode to query.
 * @param modstate a pointer to the modifier state that would be used when the
 *                 scancode generates this key, may be NULL.
 * @returns the SDL_Scancode that corresponds to the given SDL_Keycode.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyFromScancode
 * @sa SDL_GetScancodeName
 *
 * @from SDL_keyboard.h:252 SDL_Scancode SDL_GetScancodeFromKey(SDL_Keycode key, SDL_Keymod *modstate);
 */
  getScancodeFromKey: lib.symbols.SDL_GetScancodeFromKey,

/**
 * Set a human-readable name for a scancode.
 *
 * @param scancode the desired SDL_Scancode.
 * @param name the name to use for the scancode, encoded as UTF-8. The string
 *             is not copied, so the pointer given to this function must stay
 *             valid while SDL is being used.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetScancodeName
 *
 * @from SDL_keyboard.h:270 bool SDL_SetScancodeName(SDL_Scancode scancode, const char *name);
 */
  setScancodeName: lib.symbols.SDL_SetScancodeName,

/**
 * Get a human-readable name for a scancode.
 *
 * **Warning**: The returned name is by design not stable across platforms,
 * e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left
 * Windows" under Microsoft Windows, and some scancodes like
 * `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
 * scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and
 * `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore
 * unsuitable for creating a stable cross-platform two-way mapping between
 * strings and scancodes.
 *
 * @param scancode the desired SDL_Scancode to query.
 * @returns a pointer to the name for the scancode. If the scancode doesn't
 *          have a name this function returns an empty string ("").
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetScancodeFromKey
 * @sa SDL_GetScancodeFromName
 * @sa SDL_SetScancodeName
 *
 * @from SDL_keyboard.h:296 const char * SDL_GetScancodeName(SDL_Scancode scancode);
 */
  getScancodeName: lib.symbols.SDL_GetScancodeName,

/**
 * Get a scancode from a human-readable name.
 *
 * @param name the human-readable scancode name.
 * @returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't
 *          recognized; call SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyFromName
 * @sa SDL_GetScancodeFromKey
 * @sa SDL_GetScancodeName
 *
 * @from SDL_keyboard.h:313 SDL_Scancode SDL_GetScancodeFromName(const char *name);
 */
  getScancodeFromName: lib.symbols.SDL_GetScancodeFromName,

/**
 * Get a human-readable name for a key.
 *
 * If the key doesn't have a name, this function returns an empty string ("").
 *
 * Letters will be presented in their uppercase form, if applicable.
 *
 * @param key the desired SDL_Keycode to query.
 * @returns a UTF-8 encoded string of the key name.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyFromName
 * @sa SDL_GetKeyFromScancode
 * @sa SDL_GetScancodeFromKey
 *
 * @from SDL_keyboard.h:333 const char * SDL_GetKeyName(SDL_Keycode key);
 */
  getKeyName: lib.symbols.SDL_GetKeyName,

/**
 * Get a key code from a human-readable name.
 *
 * @param name the human-readable key name.
 * @returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetKeyFromScancode
 * @sa SDL_GetKeyName
 * @sa SDL_GetScancodeFromName
 *
 * @from SDL_keyboard.h:350 SDL_Keycode SDL_GetKeyFromName(const char *name);
 */
  getKeyFromName: lib.symbols.SDL_GetKeyFromName,

/**
 * Start accepting Unicode text input events in a window.
 *
 * This function will enable text input (SDL_EVENT_TEXT_INPUT and
 * SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this
 * function paired with SDL_StopTextInput().
 *
 * Text input events are not received by default.
 *
 * On some platforms using this function shows the screen keyboard and/or
 * activates an IME, which can prevent some key press events from being passed
 * through.
 *
 * @param window the window to enable text input.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetTextInputArea
 * @sa SDL_StartTextInputWithProperties
 * @sa SDL_StopTextInput
 * @sa SDL_TextInputActive
 *
 * @from SDL_keyboard.h:378 bool SDL_StartTextInput(SDL_Window *window);
 */
  startTextInput: lib.symbols.SDL_StartTextInput,

/**
 * Start accepting Unicode text input events in a window, with properties
 * describing the input.
 *
 * This function will enable text input (SDL_EVENT_TEXT_INPUT and
 * SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this
 * function paired with SDL_StopTextInput().
 *
 * Text input events are not received by default.
 *
 * On some platforms using this function shows the screen keyboard and/or
 * activates an IME, which can prevent some key press events from being passed
 * through.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that
 *   describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.
 * - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value
 *   that describes how text should be capitalized, defaults to
 *   SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for
 *   SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail
 *   addresses, usernames, and passwords.
 * - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion
 *   and auto correction, defaults to true.
 * - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text
 *   are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is
 *   "0" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME
 *   is "1".
 *
 * On Android you can directly specify the input type:
 *
 * - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to
 *   use, overriding other properties. This is documented at
 *   https://developer.android.com/reference/android/text/InputType
 *
 * @param window the window to enable text input.
 * @param props the properties to use.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetTextInputArea
 * @sa SDL_StartTextInput
 * @sa SDL_StopTextInput
 * @sa SDL_TextInputActive
 *
 * @from SDL_keyboard.h:473 bool SDL_StartTextInputWithProperties(SDL_Window *window, SDL_PropertiesID props);
 */
  startTextInputWithProperties: lib.symbols.SDL_StartTextInputWithProperties,

/**
 * Check whether or not Unicode text input events are enabled for a window.
 *
 * @param window the window to check.
 * @returns true if text input events are enabled else false.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StartTextInput
 *
 * @from SDL_keyboard.h:493 bool SDL_TextInputActive(SDL_Window *window);
 */
  textInputActive: lib.symbols.SDL_TextInputActive,

/**
 * Stop receiving any text input events in a window.
 *
 * If SDL_StartTextInput() showed the screen keyboard, this function will hide
 * it.
 *
 * @param window the window to disable text input.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StartTextInput
 *
 * @from SDL_keyboard.h:511 bool SDL_StopTextInput(SDL_Window *window);
 */
  stopTextInput: lib.symbols.SDL_StopTextInput,

/**
 * Dismiss the composition window/IME without disabling the subsystem.
 *
 * @param window the window to affect.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StartTextInput
 * @sa SDL_StopTextInput
 *
 * @from SDL_keyboard.h:527 bool SDL_ClearComposition(SDL_Window *window);
 */
  clearComposition: lib.symbols.SDL_ClearComposition,

/**
 * Set the area used to type Unicode text input.
 *
 * Native input methods may place a window with word suggestions near the
 * cursor, without covering the text being entered.
 *
 * @param window the window for which to set the text input area.
 * @param rect the SDL_Rect representing the text input area, in window
 *             coordinates, or NULL to clear it.
 * @param cursor the offset of the current cursor location relative to
 *               `rect->x`, in window coordinates.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextInputArea
 * @sa SDL_StartTextInput
 *
 * @from SDL_keyboard.h:550 bool SDL_SetTextInputArea(SDL_Window *window, const SDL_Rect *rect, int cursor);
 */
  setTextInputArea: lib.symbols.SDL_SetTextInputArea,

/**
 * Get the area used to type Unicode text input.
 *
 * This returns the values previously set by SDL_SetTextInputArea().
 *
 * @param window the window for which to query the text input area.
 * @param rect a pointer to an SDL_Rect filled in with the text input area,
 *             may be NULL.
 * @param cursor a pointer to the offset of the current cursor location
 *               relative to `rect->x`, may be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetTextInputArea
 *
 * @from SDL_keyboard.h:571 bool SDL_GetTextInputArea(SDL_Window *window, SDL_Rect *rect, int *cursor);
 */
  getTextInputArea: lib.symbols.SDL_GetTextInputArea,

/**
 * Check whether the platform has screen keyboard support.
 *
 * @returns true if the platform has some screen keyboard support or false if
 *          not.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StartTextInput
 * @sa SDL_ScreenKeyboardShown
 *
 * @from SDL_keyboard.h:586 bool SDL_HasScreenKeyboardSupport(void);
 */
  hasScreenKeyboardSupport: lib.symbols.SDL_HasScreenKeyboardSupport,

/**
 * Check whether the screen keyboard is shown for given window.
 *
 * @param window the window for which screen keyboard should be queried.
 * @returns true if screen keyboard is shown or false if not.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasScreenKeyboardSupport
 *
 * @from SDL_keyboard.h:600 bool SDL_ScreenKeyboardShown(SDL_Window *window);
 */
  screenKeyboardShown: lib.symbols.SDL_ScreenKeyboardShown,



/*--- SDL_keycode ---*/

/**
 * @from SDL_keycode:56 SDLK_
 */
  SDLK: SDL_keycode_enums.SDLK,

/**
 * @from SDL_keycode:323 SDL_KMOD_
 */
  KMOD: SDL_keycode_enums.KMOD,





/*--- SDL_loadso ---*/

/**
 * Dynamically load a shared object.
 *
 * @param sofile a system-dependent name of the object file.
 * @returns an opaque pointer to the object handle or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LoadFunction
 * @sa SDL_UnloadObject
 *
 * @from SDL_loadso.h:92 SDL_SharedObject * SDL_LoadObject(const char *sofile);
 */
  loadObject: lib.symbols.SDL_LoadObject,

/**
 * Look up the address of the named function in a shared object.
 *
 * This function pointer is no longer valid after calling SDL_UnloadObject().
 *
 * This function can only look up C function names. Other languages may have
 * name mangling and intrinsic language support that varies from compiler to
 * compiler.
 *
 * Make sure you declare your function pointers with the same calling
 * convention as the actual library function. Your code will crash
 * mysteriously if you do not do this.
 *
 * If the requested function doesn't exist, NULL is returned.
 *
 * @param handle a valid shared object handle returned by SDL_LoadObject().
 * @param name the name of the function to look up.
 * @returns a pointer to the function or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LoadObject
 *
 * @from SDL_loadso.h:120 SDL_FunctionPointer SDL_LoadFunction(SDL_SharedObject *handle, const char *name);
 */
  loadFunction: lib.symbols.SDL_LoadFunction,

/**
 * Unload a shared object from memory.
 *
 * Note that any pointers from this object looked up through
 * SDL_LoadFunction() will no longer be valid.
 *
 * @param handle a valid shared object handle returned by SDL_LoadObject().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LoadObject
 *
 * @from SDL_loadso.h:136 void SDL_UnloadObject(SDL_SharedObject *handle);
 */
  unloadObject: lib.symbols.SDL_UnloadObject,



/*--- SDL_locale ---*/

/**
 * Report the user's preferred locale.
 *
 * Returned language strings are in the format xx, where 'xx' is an ISO-639
 * language specifier (such as "en" for English, "de" for German, etc).
 * Country strings are in the format YY, where "YY" is an ISO-3166 country
 * code (such as "US" for the United States, "CA" for Canada, etc). Country
 * might be NULL if there's no specific guidance on them (so you might get {
 * "en", "US" } for American English, but { "en", NULL } means "English
 * language, generically"). Language strings are never NULL, except to
 * terminate the array.
 *
 * Please note that not all of these strings are 2 characters; some are three
 * or more.
 *
 * The returned list of locales are in the order of the user's preference. For
 * example, a German citizen that is fluent in US English and knows enough
 * Japanese to navigate around Tokyo might have a list like: { "de", "en_US",
 * "jp", NULL }. Someone from England might prefer British English (where
 * "color" is spelled "colour", etc), but will settle for anything like it: {
 * "en_GB", "en", NULL }.
 *
 * This function returns NULL on error, including when the platform does not
 * supply this information at all.
 *
 * This might be a "slow" call that has to query the operating system. It's
 * best to ask for this once and save the results. However, this list can
 * change, usually because the user has changed a system preference outside of
 * your program; SDL will send an SDL_EVENT_LOCALE_CHANGED event in this case,
 * if possible, and you can call this function again to get an updated copy of
 * preferred locales.
 *
 * @param count a pointer filled in with the number of locales returned, may
 *              be NULL.
 * @returns a NULL terminated array of locale pointers, or NULL on failure;
 *          call SDL_GetError() for more information. This is a single
 *          allocation that should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_locale.h:106 SDL_Locale ** SDL_GetPreferredLocales(int *count);
 */
  getPreferredLocales: lib.symbols.SDL_GetPreferredLocales,



/*--- SDL_log ---*/

/**
 * The predefined log categories
 *
 * By default the application and gpu categories are enabled at the INFO
 * level, the assert category is enabled at the WARN level, test is enabled at
 * the VERBOSE level and all other categories are enabled at the ERROR level.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_log.h:89 SDL_LOG_CATEGORY_
 */
  LOG_CATEGORY: SDL_log_enums.SDL_LogCategory,

/**
 * The predefined log priorities
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_log.h:129 SDL_LOG_PRIORITY_
 */
  LOG_PRIORITY: SDL_log_enums.SDL_LogPriority,



/**
 * Set the priority of all log categories.
 *
 * @param priority the SDL_LogPriority to assign.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ResetLogPriorities
 * @sa SDL_SetLogPriority
 *
 * @from SDL_log.h:155 void SDL_SetLogPriorities(SDL_LogPriority priority);
 */
  setLogPriorities: lib.symbols.SDL_SetLogPriorities,

/**
 * Set the priority of a particular log category.
 *
 * @param category the category to assign a priority to.
 * @param priority the SDL_LogPriority to assign.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetLogPriority
 * @sa SDL_ResetLogPriorities
 * @sa SDL_SetLogPriorities
 *
 * @from SDL_log.h:171 void SDL_SetLogPriority(int category, SDL_LogPriority priority);
 */
  setLogPriority: lib.symbols.SDL_SetLogPriority,

/**
 * Get the priority of a particular log category.
 *
 * @param category the category to query.
 * @returns the SDL_LogPriority for the requested category.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetLogPriority
 *
 * @from SDL_log.h:185 SDL_LogPriority SDL_GetLogPriority(int category);
 */
  getLogPriority: lib.symbols.SDL_GetLogPriority,

/**
 * Reset all priorities to default.
 *
 * This is called by SDL_Quit().
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetLogPriorities
 * @sa SDL_SetLogPriority
 *
 * @from SDL_log.h:199 void SDL_ResetLogPriorities(void);
 */
  resetLogPriorities: lib.symbols.SDL_ResetLogPriorities,

/**
 * Set the text prepended to log messages of a given priority.
 *
 * By default SDL_LOG_PRIORITY_INFO and below have no prefix, and
 * SDL_LOG_PRIORITY_WARN and higher have a prefix showing their priority, e.g.
 * "WARNING: ".
 *
 * @param priority the SDL_LogPriority to modify.
 * @param prefix the prefix to use for that log priority, or NULL to use no
 *               prefix.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetLogPriorities
 * @sa SDL_SetLogPriority
 *
 * @from SDL_log.h:221 bool SDL_SetLogPriorityPrefix(SDL_LogPriority priority, const char *prefix);
 */
  setLogPriorityPrefix: lib.symbols.SDL_SetLogPriorityPrefix,

/**
 * Get the default log output function.
 *
 * @returns the default log output callback.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetLogOutputFunction
 * @sa SDL_GetLogOutputFunction
 *
 * @from SDL_log.h:496 SDL_LogOutputFunction SDL_GetDefaultLogOutputFunction(void);
 */
  getDefaultLogOutputFunction: lib.symbols.SDL_GetDefaultLogOutputFunction,

/**
 * Get the current log output function.
 *
 * @param callback an SDL_LogOutputFunction filled in with the current log
 *                 callback.
 * @param userdata a pointer filled in with the pointer that is passed to
 *                 `callback`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDefaultLogOutputFunction
 * @sa SDL_SetLogOutputFunction
 *
 * @from SDL_log.h:513 void SDL_GetLogOutputFunction(SDL_LogOutputFunction *callback, void **userdata);
 */
  getLogOutputFunction: lib.symbols.SDL_GetLogOutputFunction,

/**
 * Replace the default log output function with one of your own.
 *
 * @param callback an SDL_LogOutputFunction to call instead of the default.
 * @param userdata a pointer that is passed to `callback`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDefaultLogOutputFunction
 * @sa SDL_GetLogOutputFunction
 *
 * @from SDL_log.h:528 void SDL_SetLogOutputFunction(SDL_LogOutputFunction callback, void *userdata);
 */
  setLogOutputFunction: lib.symbols.SDL_SetLogOutputFunction,



/*--- SDL_main ---*/

/**
 * Circumvent failure of SDL_Init() when not using SDL_main() as an entry
 * point.
 *
 * This function is defined in SDL_main.h, along with the preprocessor rule to
 * redefine main() as SDL_main(). Thus to ensure that your main() function
 * will not be changed it is necessary to define SDL_MAIN_HANDLED before
 * including SDL.h.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Init
 *
 * @from SDL_main.h:543 void SDL_SetMainReady(void);
 */
  setMainReady: lib.symbols.SDL_SetMainReady,

/**
 * Initializes and launches an SDL application, by doing platform-specific
 * initialization before calling your mainFunction and cleanups after it
 * returns, if that is needed for a specific platform, otherwise it just calls
 * mainFunction.
 *
 * You can use this if you want to use your own main() implementation without
 * using SDL_main (like when using SDL_MAIN_HANDLED). When using this, you do
 * *not* need SDL_SetMainReady().
 *
 * @param argc the argc parameter from the application's main() function, or 0
 *             if the platform's main-equivalent has no argc.
 * @param argv the argv parameter from the application's main() function, or
 *             NULL if the platform's main-equivalent has no argv.
 * @param mainFunction your SDL app's C-style main(). NOT the function you're
 *                     calling this from! Its name doesn't matter; it doesn't
 *                     literally have to be `main`.
 * @param reserved should be NULL (reserved for future use, will probably be
 *                 platform-specific then).
 * @returns the return value from mainFunction: 0 on success, otherwise
 *          failure; SDL_GetError() might have more information on the
 *          failure.
 *
 * @threadsafety Generally this is called once, near startup, from the
 *               process's initial thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_main.h:573 int SDL_RunApp(int argc, char *argv[], SDL_main_func mainFunction, void *reserved);
 */
  runApp: lib.symbols.SDL_RunApp,

/**
 * An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.
 *
 * Generally, you should not call this function directly. This only exists to
 * hand off work into SDL as soon as possible, where it has a lot more control
 * and functionality available, and make the inline code in SDL_main.h as
 * small as possible.
 *
 * Not all platforms use this, it's actual use is hidden in a magic
 * header-only library, and you should not call this directly unless you
 * _really_ know what you're doing.
 *
 * @param argc standard Unix main argc.
 * @param argv standard Unix main argv.
 * @param appinit the application's SDL_AppInit function.
 * @param appiter the application's SDL_AppIterate function.
 * @param appevent the application's SDL_AppEvent function.
 * @param appquit the application's SDL_AppQuit function.
 * @returns standard Unix main return value.
 *
 * @threadsafety It is not safe to call this anywhere except as the only
 *               function call in SDL_main.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_main.h:600 int SDL_EnterAppMainCallbacks(int argc, char *argv[], SDL_AppInit_func appinit, SDL_AppIterate_func appiter, SDL_AppEvent_func appevent, SDL_AppQuit_func appquit);
 */
  enterAppMainCallbacks: lib.symbols.SDL_EnterAppMainCallbacks,

/**
 * Register a win32 window class for SDL's use.
 *
 * This can be called to set the application window class at startup. It is
 * safe to call this multiple times, as long as every call is eventually
 * paired with a call to SDL_UnregisterApp, but a second registration attempt
 * while a previous registration is still active will be ignored, other than
 * to increment a counter.
 *
 * Most applications do not need to, and should not, call this directly; SDL
 * will call it when initializing the video subsystem.
 *
 * @param name the window class name, in UTF-8 encoding. If NULL, SDL
 *             currently uses "SDL_app" but this isn't guaranteed.
 * @param style the value to use in WNDCLASSEX::style. If `name` is NULL, SDL
 *              currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` regardless of
 *              what is specified here.
 * @param hInst the HINSTANCE to use in WNDCLASSEX::hInstance. If zero, SDL
 *              will use `GetModuleHandle(NULL)` instead.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_main.h:629 bool SDL_RegisterApp(const char *name, Uint32 style, void *hInst);
 */
  registerApp: lib.symbols.SDL_RegisterApp,

/**
 * Deregister the win32 window class from an SDL_RegisterApp call.
 *
 * This can be called to undo the effects of SDL_RegisterApp.
 *
 * Most applications do not need to, and should not, call this directly; SDL
 * will call it when deinitializing the video subsystem.
 *
 * It is safe to call this multiple times, as long as every call is eventually
 * paired with a prior call to SDL_RegisterApp. The window class will only be
 * deregistered when the registration counter in SDL_RegisterApp decrements to
 * zero through calls to this function.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_main.h:646 void SDL_UnregisterApp(void);
 */
  unregisterApp: lib.symbols.SDL_UnregisterApp,

/**
 * Callback from the application to let the suspend continue.
 *
 * This function is only needed for Xbox GDK support; all other platforms will
 * do nothing and set an "unsupported" error message.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_main.h:658 void SDL_GDKSuspendComplete(void);
 */
  gdkSuspendComplete: lib.symbols.SDL_GDKSuspendComplete,



/*--- SDL_messagebox ---*/

/**
 * @from SDL_messagebox:60 SDL_MESSAGEBOX_
 */
  MESSAGEBOX: SDL_messagebox_enums.MESSAGEBOX,

/**
 * @from SDL_messagebox:73 SDL_MESSAGEBOX_BUTTON_
 */
  MESSAGEBOX_BUTTON: SDL_messagebox_enums.MESSAGEBOX_BUTTON,

/**
 * An enumeration of indices inside the colors array of
 * SDL_MessageBoxColorScheme.
 *
 * @from SDL_messagebox.h:102 SDL_MESSAGEBOX_COLOR_
 */
  MESSAGEBOX_COLOR: SDL_messagebox_enums.SDL_MessageBoxColorType,



/**
 * Create a modal message box.
 *
 * If your needs aren't complex, it might be easier to use
 * SDL_ShowSimpleMessageBox.
 *
 * This function should be called on the thread that created the parent
 * window, or on the main thread if the messagebox has no parent. It will
 * block execution of that thread until the user clicks a button or closes the
 * messagebox.
 *
 * This function may be called at any time, even before SDL_Init(). This makes
 * it useful for reporting errors like a failure to create a renderer or
 * OpenGL context.
 *
 * On X11, SDL rolls its own dialog box with X11 primitives instead of a
 * formal toolkit like GTK+ or Qt.
 *
 * Note that if SDL_Init() would fail because there isn't any available video
 * target, this function is likely to fail for the same reasons. If this is a
 * concern, check the return value from this function and fall back to writing
 * to stderr if you can.
 *
 * @param messageboxdata the SDL_MessageBoxData structure with title, text and
 *                       other options.
 * @param buttonid the pointer to which user id of hit button should be
 *                 copied.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ShowSimpleMessageBox
 *
 * @from SDL_messagebox.h:174 bool SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
 */
  showMessageBox: lib.symbols.SDL_ShowMessageBox,

/**
 * Display a simple modal message box.
 *
 * If your needs aren't complex, this function is preferred over
 * SDL_ShowMessageBox.
 *
 * `flags` may be any of the following:
 *
 * - `SDL_MESSAGEBOX_ERROR`: error dialog
 * - `SDL_MESSAGEBOX_WARNING`: warning dialog
 * - `SDL_MESSAGEBOX_INFORMATION`: informational dialog
 *
 * This function should be called on the thread that created the parent
 * window, or on the main thread if the messagebox has no parent. It will
 * block execution of that thread until the user clicks a button or closes the
 * messagebox.
 *
 * This function may be called at any time, even before SDL_Init(). This makes
 * it useful for reporting errors like a failure to create a renderer or
 * OpenGL context.
 *
 * On X11, SDL rolls its own dialog box with X11 primitives instead of a
 * formal toolkit like GTK+ or Qt.
 *
 * Note that if SDL_Init() would fail because there isn't any available video
 * target, this function is likely to fail for the same reasons. If this is a
 * concern, check the return value from this function and fall back to writing
 * to stderr if you can.
 *
 * @param flags an SDL_MessageBoxFlags value.
 * @param title UTF-8 title text.
 * @param message UTF-8 message text.
 * @param window the parent window, or NULL for no parent.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ShowMessageBox
 *
 * @from SDL_messagebox.h:216 bool SDL_ShowSimpleMessageBox(SDL_MessageBoxFlags flags, const char *title, const char *message, SDL_Window *window);
 */
  showSimpleMessageBox: lib.symbols.SDL_ShowSimpleMessageBox,



/*--- SDL_misc ---*/

/**
 * Open a URL/URI in the browser or other appropriate external application.
 *
 * Open a URL in a separate, system-provided application. How this works will
 * vary wildly depending on the platform. This will likely launch what makes
 * sense to handle a specific URL's protocol (a web browser for `http://`,
 * etc), but it might also be able to launch file managers for directories and
 * other things.
 *
 * What happens when you open a URL varies wildly as well: your game window
 * may lose focus (and may or may not lose focus if your game was fullscreen
 * or grabbing input at the time). On mobile devices, your app will likely
 * move to the background or your process might be paused. Any given platform
 * may or may not handle a given URL.
 *
 * If this is unimplemented (or simply unavailable) for a platform, this will
 * fail with an error. A successful result does not mean the URL loaded, just
 * that we launched _something_ to handle it (or at least believe we did).
 *
 * All this to say: this function can be useful, but you should definitely
 * test it on every platform you target.
 *
 * @param url a valid URL/URI to open. Use `file:///full/path/to/file` for
 *            local files, if supported.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_misc.h:69 bool SDL_OpenURL(const char *url);
 */
  openUrl: lib.symbols.SDL_OpenURL,



/*--- SDL_mouse ---*/

/**
 * @from SDL_mouse:149 SDL_BUTTON_
 */
  BUTTON: SDL_mouse_enums.BUTTON,

/**
 * Cursor types for SDL_CreateSystemCursor().
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_mouse.h:96 SDL_SYSTEM_CURSOR_
 */
  SYSTEM_CURSOR: SDL_mouse_enums.SDL_SystemCursor,

/**
 * Scroll direction types for the Scroll event
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_mouse.h:126 SDL_MOUSEWHEEL_
 */
  MOUSEWHEEL: SDL_mouse_enums.SDL_MouseWheelDirection,



/**
 * Return whether a mouse is currently connected.
 *
 * @returns true if a mouse is connected, false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetMice
 *
 * @from SDL_mouse.h:176 bool SDL_HasMouse(void);
 */
  hasMouse: lib.symbols.SDL_HasMouse,

/**
 * Get a list of currently connected mice.
 *
 * Note that this will include any device or virtual driver that includes
 * mouse functionality, including some game controllers, KVM switches, etc.
 * You should wait for input from a device before you consider it actively in
 * use.
 *
 * @param count a pointer filled in with the number of mice returned, may be
 *              NULL.
 * @returns a 0 terminated array of mouse instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetMouseNameForID
 * @sa SDL_HasMouse
 *
 * @from SDL_mouse.h:199 SDL_MouseID * SDL_GetMice(int *count);
 */
  getMice: lib.symbols.SDL_GetMice,

/**
 * Get the name of a mouse.
 *
 * This function returns "" if the mouse doesn't have a name.
 *
 * @param instance_id the mouse instance ID.
 * @returns the name of the selected mouse, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetMice
 *
 * @from SDL_mouse.h:216 const char * SDL_GetMouseNameForID(SDL_MouseID instance_id);
 */
  getMouseNameForId: lib.symbols.SDL_GetMouseNameForID,

/**
 * Get the window which currently has mouse focus.
 *
 * @returns the window with mouse focus.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_mouse.h:227 SDL_Window * SDL_GetMouseFocus(void);
 */
  getMouseFocus: lib.symbols.SDL_GetMouseFocus,

/**
 * Query SDL's cache for the synchronous mouse button state and the
 * window-relative SDL-cursor position.
 *
 * This function returns the cached synchronous state as SDL understands it
 * from the last pump of the event queue.
 *
 * To query the platform for immediate asynchronous state, use
 * SDL_GetGlobalMouseState.
 *
 * Passing non-NULL pointers to `x` or `y` will write the destination with
 * respective x or y coordinates relative to the focused window.
 *
 * In Relative Mode, the SDL-cursor's position usually contradicts the
 * platform-cursor's position as manually calculated from
 * SDL_GetGlobalMouseState() and SDL_GetWindowPosition.
 *
 * @param x a pointer to receive the SDL-cursor's x-position from the focused
 *          window's top left corner, can be NULL if unused.
 * @param y a pointer to receive the SDL-cursor's y-position from the focused
 *          window's top left corner, can be NULL if unused.
 * @returns a 32-bit bitmask of the button state that can be bitwise-compared
 *          against the SDL_BUTTON_MASK(X) macro.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGlobalMouseState
 * @sa SDL_GetRelativeMouseState
 *
 * @from SDL_mouse.h:260 SDL_MouseButtonFlags SDL_GetMouseState(float *x, float *y);
 */
  getMouseState: lib.symbols.SDL_GetMouseState,

/**
 * Query the platform for the asynchronous mouse button state and the
 * desktop-relative platform-cursor position.
 *
 * This function immediately queries the platform for the most recent
 * asynchronous state, more costly than retrieving SDL's cached state in
 * SDL_GetMouseState().
 *
 * Passing non-NULL pointers to `x` or `y` will write the destination with
 * respective x or y coordinates relative to the desktop.
 *
 * In Relative Mode, the platform-cursor's position usually contradicts the
 * SDL-cursor's position as manually calculated from SDL_GetMouseState() and
 * SDL_GetWindowPosition.
 *
 * This function can be useful if you need to track the mouse outside of a
 * specific window and SDL_CaptureMouse() doesn't fit your needs. For example,
 * it could be useful if you need to track the mouse while dragging a window,
 * where coordinates relative to a window might not be in sync at all times.
 *
 * @param x a pointer to receive the platform-cursor's x-position from the
 *          desktop's top left corner, can be NULL if unused.
 * @param y a pointer to receive the platform-cursor's y-position from the
 *          desktop's top left corner, can be NULL if unused.
 * @returns a 32-bit bitmask of the button state that can be bitwise-compared
 *          against the SDL_BUTTON_MASK(X) macro.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CaptureMouse
 * @sa SDL_GetMouseState
 * @sa SDL_GetGlobalMouseState
 *
 * @from SDL_mouse.h:297 SDL_MouseButtonFlags SDL_GetGlobalMouseState(float *x, float *y);
 */
  getGlobalMouseState: lib.symbols.SDL_GetGlobalMouseState,

/**
 * Query SDL's cache for the synchronous mouse button state and accumulated
 * mouse delta since last call.
 *
 * This function returns the cached synchronous state as SDL understands it
 * from the last pump of the event queue.
 *
 * To query the platform for immediate asynchronous state, use
 * SDL_GetGlobalMouseState.
 *
 * Passing non-NULL pointers to `x` or `y` will write the destination with
 * respective x or y deltas accumulated since the last call to this function
 * (or since event initialization).
 *
 * This function is useful for reducing overhead by processing relative mouse
 * inputs in one go per-frame instead of individually per-event, at the
 * expense of losing the order between events within the frame (e.g. quickly
 * pressing and releasing a button within the same frame).
 *
 * @param x a pointer to receive the x mouse delta accumulated since last
 *          call, can be NULL if unused.
 * @param y a pointer to receive the y mouse delta accumulated since last
 *          call, can be NULL if unused.
 * @returns a 32-bit bitmask of the button state that can be bitwise-compared
 *          against the SDL_BUTTON_MASK(X) macro.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetMouseState
 * @sa SDL_GetGlobalMouseState
 *
 * @from SDL_mouse.h:332 SDL_MouseButtonFlags SDL_GetRelativeMouseState(float *x, float *y);
 */
  getRelativeMouseState: lib.symbols.SDL_GetRelativeMouseState,

/**
 * Move the mouse cursor to the given position within the window.
 *
 * This function generates a mouse motion event if relative mode is not
 * enabled. If relative mode is enabled, you can force mouse events for the
 * warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.
 *
 * Note that this function will appear to succeed, but not actually move the
 * mouse when used over Microsoft Remote Desktop.
 *
 * @param window the window to move the mouse into, or NULL for the current
 *               mouse focus.
 * @param x the x coordinate within the window.
 * @param y the y coordinate within the window.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WarpMouseGlobal
 *
 * @from SDL_mouse.h:355 void SDL_WarpMouseInWindow(SDL_Window *window,                                                   float x, float y);
 */
  warpMouseInWindow: lib.symbols.SDL_WarpMouseInWindow,

/**
 * Move the mouse to the given position in global screen space.
 *
 * This function generates a mouse motion event.
 *
 * A failure of this function usually means that it is unsupported by a
 * platform.
 *
 * Note that this function will appear to succeed, but not actually move the
 * mouse when used over Microsoft Remote Desktop.
 *
 * @param x the x coordinate.
 * @param y the y coordinate.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WarpMouseInWindow
 *
 * @from SDL_mouse.h:380 bool SDL_WarpMouseGlobal(float x, float y);
 */
  warpMouseGlobal: lib.symbols.SDL_WarpMouseGlobal,

/**
 * Set relative mouse mode for a window.
 *
 * While the window has focus and relative mouse mode is enabled, the cursor
 * is hidden, the mouse position is constrained to the window, and SDL will
 * report continuous relative mouse motion even if the mouse is at the edge of
 * the window.
 *
 * If you'd like to keep the mouse position fixed while in relative mode you
 * can use SDL_SetWindowMouseRect(). If you'd like the cursor to be at a
 * specific location when relative mode ends, you should use
 * SDL_WarpMouseInWindow() before disabling relative mode.
 *
 * This function will flush any pending mouse motion for this window.
 *
 * @param window the window to change.
 * @param enabled true to enable relative mode, false to disable.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowRelativeMouseMode
 *
 * @from SDL_mouse.h:408 bool SDL_SetWindowRelativeMouseMode(SDL_Window *window, bool enabled);
 */
  setWindowRelativeMouseMode: lib.symbols.SDL_SetWindowRelativeMouseMode,

/**
 * Query whether relative mouse mode is enabled for a window.
 *
 * @param window the window to query.
 * @returns true if relative mode is enabled for a window or false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowRelativeMouseMode
 *
 * @from SDL_mouse.h:422 bool SDL_GetWindowRelativeMouseMode(SDL_Window *window);
 */
  getWindowRelativeMouseMode: lib.symbols.SDL_GetWindowRelativeMouseMode,

/**
 * Capture the mouse and to track input outside an SDL window.
 *
 * Capturing enables your app to obtain mouse events globally, instead of just
 * within your window. Not all video targets support this function. When
 * capturing is enabled, the current window will get all mouse events, but
 * unlike relative mode, no change is made to the cursor and it is not
 * restrained to your window.
 *
 * This function may also deny mouse input to other windows--both those in
 * your application and others on the system--so you should use this function
 * sparingly, and in small bursts. For example, you might want to track the
 * mouse while the user is dragging something, until the user releases a mouse
 * button. It is not recommended that you capture the mouse for long periods
 * of time, such as the entire time your app is running. For that, you should
 * probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),
 * depending on your goals.
 *
 * While captured, mouse events still report coordinates relative to the
 * current (foreground) window, but those coordinates may be outside the
 * bounds of the window (including negative values). Capturing is only allowed
 * for the foreground window. If the window loses focus while capturing, the
 * capture will be disabled automatically.
 *
 * While capturing is enabled, the current window will have the
 * `SDL_WINDOW_MOUSE_CAPTURE` flag set.
 *
 * Please note that SDL will attempt to "auto capture" the mouse while the
 * user is pressing a button; this is to try and make mouse behavior more
 * consistent between platforms, and deal with the common case of a user
 * dragging the mouse outside of the window. This means that if you are
 * calling SDL_CaptureMouse() only to deal with this situation, you do not
 * have to (although it is safe to do so). If this causes problems for your
 * app, you can disable auto capture by setting the
 * `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.
 *
 * @param enabled true to enable capturing, false to disable.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetGlobalMouseState
 *
 * @from SDL_mouse.h:470 bool SDL_CaptureMouse(bool enabled);
 */
  captureMouse: lib.symbols.SDL_CaptureMouse,

/**
 * Create a cursor using the specified bitmap data and mask (in MSB format).
 *
 * `mask` has to be in MSB (Most Significant Bit) format.
 *
 * The cursor width (`w`) must be a multiple of 8 bits.
 *
 * The cursor is created in black and white according to the following:
 *
 * - data=0, mask=1: white
 * - data=1, mask=1: black
 * - data=0, mask=0: transparent
 * - data=1, mask=0: inverted color if possible, black if not.
 *
 * Cursors created with this function must be freed with SDL_DestroyCursor().
 *
 * If you want to have a color cursor, or create your cursor from an
 * SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can
 * hide the cursor and draw your own as part of your game's rendering, but it
 * will be bound to the framerate.
 *
 * Also, SDL_CreateSystemCursor() is available, which provides several
 * readily-available system cursors to pick from.
 *
 * @param data the color value for each pixel of the cursor.
 * @param mask the mask value for each pixel of the cursor.
 * @param w the width of the cursor.
 * @param h the height of the cursor.
 * @param hot_x the x-axis offset from the left of the cursor image to the
 *              mouse x position, in the range of 0 to `w` - 1.
 * @param hot_y the y-axis offset from the top of the cursor image to the
 *              mouse y position, in the range of 0 to `h` - 1.
 * @returns a new cursor with the specified parameters on success or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateColorCursor
 * @sa SDL_CreateSystemCursor
 * @sa SDL_DestroyCursor
 * @sa SDL_SetCursor
 *
 * @from SDL_mouse.h:516 SDL_Cursor * SDL_CreateCursor(const Uint8 *data,                                                     const Uint8 *mask,                                                     int w, int h, int hot_x,                                                     int hot_y);
 */
  createCursor: lib.symbols.SDL_CreateCursor,

/**
 * Create a color cursor.
 *
 * If this function is passed a surface with alternate representations, the
 * surface will be interpreted as the content to be used for 100% display
 * scale, and the alternate representations will be used for high DPI
 * situations. For example, if the original surface is 32x32, then on a 2x
 * macOS display or 200% display scale on Windows, a 64x64 version of the
 * image will be used, if available. If a matching version of the image isn't
 * available, the closest larger size image will be downscaled to the
 * appropriate size and be used instead, if available. Otherwise, the closest
 * smaller image will be upscaled and be used instead.
 *
 * @param surface an SDL_Surface structure representing the cursor image.
 * @param hot_x the x position of the cursor hot spot.
 * @param hot_y the y position of the cursor hot spot.
 * @returns the new cursor on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateCursor
 * @sa SDL_CreateSystemCursor
 * @sa SDL_DestroyCursor
 * @sa SDL_SetCursor
 *
 * @from SDL_mouse.h:549 SDL_Cursor * SDL_CreateColorCursor(SDL_Surface *surface,                                                          int hot_x,                                                          int hot_y);
 */
  createColorCursor: lib.symbols.SDL_CreateColorCursor,

/**
 * Create a system cursor.
 *
 * @param id an SDL_SystemCursor enum value.
 * @returns a cursor on success or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyCursor
 *
 * @from SDL_mouse.h:566 SDL_Cursor * SDL_CreateSystemCursor(SDL_SystemCursor id);
 */
  createSystemCursor: lib.symbols.SDL_CreateSystemCursor,

/**
 * Set the active cursor.
 *
 * This function sets the currently active cursor to the specified one. If the
 * cursor is currently visible, the change will be immediately represented on
 * the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if
 * this is desired for any reason.
 *
 * @param cursor a cursor to make active.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCursor
 *
 * @from SDL_mouse.h:586 bool SDL_SetCursor(SDL_Cursor *cursor);
 */
  setCursor: lib.symbols.SDL_SetCursor,

/**
 * Get the active cursor.
 *
 * This function returns a pointer to the current cursor which is owned by the
 * library. It is not necessary to free the cursor with SDL_DestroyCursor().
 *
 * @returns the active cursor or NULL if there is no mouse.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetCursor
 *
 * @from SDL_mouse.h:602 SDL_Cursor * SDL_GetCursor(void);
 */
  getCursor: lib.symbols.SDL_GetCursor,

/**
 * Get the default cursor.
 *
 * You do not have to call SDL_DestroyCursor() on the return value, but it is
 * safe to do so.
 *
 * @returns the default cursor on success or NULL on failuree; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_mouse.h:617 SDL_Cursor * SDL_GetDefaultCursor(void);
 */
  getDefaultCursor: lib.symbols.SDL_GetDefaultCursor,

/**
 * Free a previously-created cursor.
 *
 * Use this function to free cursor resources created with SDL_CreateCursor(),
 * SDL_CreateColorCursor() or SDL_CreateSystemCursor().
 *
 * @param cursor the cursor to free.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateColorCursor
 * @sa SDL_CreateCursor
 * @sa SDL_CreateSystemCursor
 *
 * @from SDL_mouse.h:635 void SDL_DestroyCursor(SDL_Cursor *cursor);
 */
  destroyCursor: lib.symbols.SDL_DestroyCursor,

/**
 * Show the cursor.
 *
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CursorVisible
 * @sa SDL_HideCursor
 *
 * @from SDL_mouse.h:650 bool SDL_ShowCursor(void);
 */
  showCursor: lib.symbols.SDL_ShowCursor,

/**
 * Hide the cursor.
 *
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CursorVisible
 * @sa SDL_ShowCursor
 *
 * @from SDL_mouse.h:665 bool SDL_HideCursor(void);
 */
  hideCursor: lib.symbols.SDL_HideCursor,

/**
 * Return whether the cursor is currently being shown.
 *
 * @returns `true` if the cursor is being shown, or `false` if the cursor is
 *          hidden.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HideCursor
 * @sa SDL_ShowCursor
 *
 * @from SDL_mouse.h:680 bool SDL_CursorVisible(void);
 */
  cursorVisible: lib.symbols.SDL_CursorVisible,



/*--- SDL_mutex ---*/

/**
 * The current status of an SDL_InitState structure.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_mutex.h:930 SDL_INIT_STATUS_
 */
  INIT_STATUS: SDL_mutex_enums.SDL_InitStatus,



/**
 * Create a new mutex.
 *
 * All newly-created mutexes begin in the _unlocked_ state.
 *
 * Calls to SDL_LockMutex() will not return while the mutex is locked by
 * another thread. See SDL_TryLockMutex() to attempt to lock without blocking.
 *
 * SDL mutexes are reentrant.
 *
 * @returns the initialized and unlocked mutex or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyMutex
 * @sa SDL_LockMutex
 * @sa SDL_TryLockMutex
 * @sa SDL_UnlockMutex
 *
 * @from SDL_mutex.h:317 SDL_Mutex * SDL_CreateMutex(void);
 */
  createMutex: lib.symbols.SDL_CreateMutex,

/**
 * Lock the mutex.
 *
 * This will block until the mutex is available, which is to say it is in the
 * unlocked state and the OS has chosen the caller as the next thread to lock
 * it. Of all threads waiting to lock the mutex, only one may do so at a time.
 *
 * It is legal for the owning thread to lock an already-locked mutex. It must
 * unlock it the same number of times before it is actually made available for
 * other threads in the system (this is known as a "recursive mutex").
 *
 * This function does not fail; if mutex is NULL, it will return immediately
 * having locked nothing. If the mutex is valid, this function will always
 * block until it can lock the mutex, and return with it locked.
 *
 * @param mutex the mutex to lock.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_TryLockMutex
 * @sa SDL_UnlockMutex
 *
 * @from SDL_mutex.h:341 void SDL_LockMutex(SDL_Mutex *mutex) SDL_ACQUIRE(mutex);
 */
  lockMutex: lib.symbols.SDL_LockMutex,

/**
 * Try to lock a mutex without blocking.
 *
 * This works just like SDL_LockMutex(), but if the mutex is not available,
 * this function returns false immediately.
 *
 * This technique is useful if you need exclusive access to a resource but
 * don't want to wait for it, and will return to it to try again later.
 *
 * This function returns true if passed a NULL mutex.
 *
 * @param mutex the mutex to try to lock.
 * @returns true on success, false if the mutex would block.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockMutex
 * @sa SDL_UnlockMutex
 *
 * @from SDL_mutex.h:362 bool SDL_TryLockMutex(SDL_Mutex *mutex) SDL_TRY_ACQUIRE(0, mutex);
 */
  tryLockMutex: lib.symbols.SDL_TryLockMutex,

/**
 * Unlock the mutex.
 *
 * It is legal for the owning thread to lock an already-locked mutex. It must
 * unlock it the same number of times before it is actually made available for
 * other threads in the system (this is known as a "recursive mutex").
 *
 * It is illegal to unlock a mutex that has not been locked by the current
 * thread, and doing so results in undefined behavior.
 *
 * @param mutex the mutex to unlock.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockMutex
 * @sa SDL_TryLockMutex
 *
 * @from SDL_mutex.h:381 void SDL_UnlockMutex(SDL_Mutex *mutex) SDL_RELEASE(mutex);
 */
  unlockMutex: lib.symbols.SDL_UnlockMutex,

/**
 * Destroy a mutex created with SDL_CreateMutex().
 *
 * This function must be called on any mutex that is no longer needed. Failure
 * to destroy a mutex will result in a system memory or resource leak. While
 * it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt
 * to destroy a locked mutex, and may result in undefined behavior depending
 * on the platform.
 *
 * @param mutex the mutex to destroy.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateMutex
 *
 * @from SDL_mutex.h:398 void SDL_DestroyMutex(SDL_Mutex *mutex);
 */
  destroyMutex: lib.symbols.SDL_DestroyMutex,

/**
 * Create a new read/write lock.
 *
 * A read/write lock is useful for situations where you have multiple threads
 * trying to access a resource that is rarely updated. All threads requesting
 * a read-only lock will be allowed to run in parallel; if a thread requests a
 * write lock, it will be provided exclusive access. This makes it safe for
 * multiple threads to use a resource at the same time if they promise not to
 * change it, and when it has to be changed, the rwlock will serve as a
 * gateway to make sure those changes can be made safely.
 *
 * In the right situation, a rwlock can be more efficient than a mutex, which
 * only lets a single thread proceed at a time, even if it won't be modifying
 * the data.
 *
 * All newly-created read/write locks begin in the _unlocked_ state.
 *
 * Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not
 * return while the rwlock is locked _for writing_ by another thread. See
 * SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt
 * to lock without blocking.
 *
 * SDL read/write locks are only recursive for read-only locks! They are not
 * guaranteed to be fair, or provide access in a FIFO manner! They are not
 * guaranteed to favor writers. You may not lock a rwlock for both read-only
 * and write access at the same time from the same thread (so you can't
 * promote your read-only lock to a write lock without unlocking first).
 *
 * @returns the initialized and unlocked read/write lock or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyRWLock
 * @sa SDL_LockRWLockForReading
 * @sa SDL_LockRWLockForWriting
 * @sa SDL_TryLockRWLockForReading
 * @sa SDL_TryLockRWLockForWriting
 * @sa SDL_UnlockRWLock
 *
 * @from SDL_mutex.h:468 SDL_RWLock * SDL_CreateRWLock(void);
 */
  createRwLock: lib.symbols.SDL_CreateRWLock,

/**
 * Lock the read/write lock for _write_ operations.
 *
 * This will block until the rwlock is available, which is to say it is not
 * locked for reading or writing by any other thread. Only one thread may hold
 * the lock when it requests write access; all other threads, whether they
 * also want to write or only want read-only access, must wait until the
 * writer thread has released the lock.
 *
 * It is illegal for the owning thread to lock an already-locked rwlock for
 * writing (read-only may be locked recursively, writing can not). Doing so
 * results in undefined behavior.
 *
 * It is illegal to request a write lock from a thread that already holds a
 * read-only lock. Doing so results in undefined behavior. Unlock the
 * read-only lock before requesting a write lock.
 *
 * This function does not fail; if rwlock is NULL, it will return immediately
 * having locked nothing. If the rwlock is valid, this function will always
 * block until it can lock the mutex, and return with it locked.
 *
 * @param rwlock the read/write lock to lock.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockRWLockForReading
 * @sa SDL_TryLockRWLockForWriting
 * @sa SDL_UnlockRWLock
 *
 * @from SDL_mutex.h:536 void SDL_LockRWLockForWriting(SDL_RWLock *rwlock) SDL_ACQUIRE(rwlock);
 */
  lockRwLockForWriting: lib.symbols.SDL_LockRWLockForWriting,

/**
 * Try to lock a read/write lock _for writing_ without blocking.
 *
 * This works just like SDL_LockRWLockForWriting(), but if the rwlock is not
 * available, then this function returns false immediately.
 *
 * This technique is useful if you need exclusive access to a resource but
 * don't want to wait for it, and will return to it to try again later.
 *
 * It is illegal for the owning thread to lock an already-locked rwlock for
 * writing (read-only may be locked recursively, writing can not). Doing so
 * results in undefined behavior.
 *
 * It is illegal to request a write lock from a thread that already holds a
 * read-only lock. Doing so results in undefined behavior. Unlock the
 * read-only lock before requesting a write lock.
 *
 * This function returns true if passed a NULL rwlock.
 *
 * @param rwlock the rwlock to try to lock.
 * @returns true on success, false if the lock would block.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockRWLockForWriting
 * @sa SDL_TryLockRWLockForReading
 * @sa SDL_UnlockRWLock
 *
 * @from SDL_mutex.h:591 bool SDL_TryLockRWLockForWriting(SDL_RWLock *rwlock) SDL_TRY_ACQUIRE(0, rwlock);
 */
  tryLockRwLockForWriting: lib.symbols.SDL_TryLockRWLockForWriting,

/**
 * Destroy a read/write lock created with SDL_CreateRWLock().
 *
 * This function must be called on any read/write lock that is no longer
 * needed. Failure to destroy a rwlock will result in a system memory or
 * resource leak. While it is safe to destroy a rwlock that is _unlocked_, it
 * is not safe to attempt to destroy a locked rwlock, and may result in
 * undefined behavior depending on the platform.
 *
 * @param rwlock the rwlock to destroy.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateRWLock
 *
 * @from SDL_mutex.h:633 void SDL_DestroyRWLock(SDL_RWLock *rwlock);
 */
  destroyRwLock: lib.symbols.SDL_DestroyRWLock,

/**
 * Create a semaphore.
 *
 * This function creates a new semaphore and initializes it with the value
 * `initial_value`. Each wait operation on the semaphore will atomically
 * decrement the semaphore value and potentially block if the semaphore value
 * is 0. Each post operation will atomically increment the semaphore value and
 * wake waiting threads and allow them to retry the wait operation.
 *
 * @param initial_value the starting value of the semaphore.
 * @returns a new semaphore or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroySemaphore
 * @sa SDL_SignalSemaphore
 * @sa SDL_TryWaitSemaphore
 * @sa SDL_GetSemaphoreValue
 * @sa SDL_WaitSemaphore
 * @sa SDL_WaitSemaphoreTimeout
 *
 * @from SDL_mutex.h:681 SDL_Semaphore * SDL_CreateSemaphore(Uint32 initial_value);
 */
  createSemaphore: lib.symbols.SDL_CreateSemaphore,

/**
 * Destroy a semaphore.
 *
 * It is not safe to destroy a semaphore if there are threads currently
 * waiting on it.
 *
 * @param sem the semaphore to destroy.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateSemaphore
 *
 * @from SDL_mutex.h:695 void SDL_DestroySemaphore(SDL_Semaphore *sem);
 */
  destroySemaphore: lib.symbols.SDL_DestroySemaphore,

/**
 * Wait until a semaphore has a positive value and then decrements it.
 *
 * This function suspends the calling thread until the semaphore pointed to by
 * `sem` has a positive value, and then atomically decrement the semaphore
 * value.
 *
 * This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with
 * a time length of -1.
 *
 * @param sem the semaphore wait on.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SignalSemaphore
 * @sa SDL_TryWaitSemaphore
 * @sa SDL_WaitSemaphoreTimeout
 *
 * @from SDL_mutex.h:715 void SDL_WaitSemaphore(SDL_Semaphore *sem);
 */
  waitSemaphore: lib.symbols.SDL_WaitSemaphore,

/**
 * See if a semaphore has a positive value and decrement it if it does.
 *
 * This function checks to see if the semaphore pointed to by `sem` has a
 * positive value and atomically decrements the semaphore value if it does. If
 * the semaphore doesn't have a positive value, the function immediately
 * returns false.
 *
 * @param sem the semaphore to wait on.
 * @returns true if the wait succeeds, false if the wait would block.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SignalSemaphore
 * @sa SDL_WaitSemaphore
 * @sa SDL_WaitSemaphoreTimeout
 *
 * @from SDL_mutex.h:734 bool SDL_TryWaitSemaphore(SDL_Semaphore *sem);
 */
  tryWaitSemaphore: lib.symbols.SDL_TryWaitSemaphore,

/**
 * Wait until a semaphore has a positive value and then decrements it.
 *
 * This function suspends the calling thread until either the semaphore
 * pointed to by `sem` has a positive value or the specified time has elapsed.
 * If the call is successful it will atomically decrement the semaphore value.
 *
 * @param sem the semaphore to wait on.
 * @param timeoutMS the length of the timeout, in milliseconds, or -1 to wait
 *                  indefinitely.
 * @returns true if the wait succeeds or false if the wait times out.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SignalSemaphore
 * @sa SDL_TryWaitSemaphore
 * @sa SDL_WaitSemaphore
 *
 * @from SDL_mutex.h:754 bool SDL_WaitSemaphoreTimeout(SDL_Semaphore *sem, Sint32 timeoutMS);
 */
  waitSemaphoreTimeout: lib.symbols.SDL_WaitSemaphoreTimeout,

/**
 * Atomically increment a semaphore's value and wake waiting threads.
 *
 * @param sem the semaphore to increment.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_TryWaitSemaphore
 * @sa SDL_WaitSemaphore
 * @sa SDL_WaitSemaphoreTimeout
 *
 * @from SDL_mutex.h:767 void SDL_SignalSemaphore(SDL_Semaphore *sem);
 */
  signalSemaphore: lib.symbols.SDL_SignalSemaphore,

/**
 * Get the current value of a semaphore.
 *
 * @param sem the semaphore to query.
 * @returns the current value of the semaphore.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_mutex.h:777 Uint32 SDL_GetSemaphoreValue(SDL_Semaphore *sem);
 */
  getSemaphoreValue: lib.symbols.SDL_GetSemaphoreValue,

/**
 * Create a condition variable.
 *
 * @returns a new condition variable or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BroadcastCondition
 * @sa SDL_SignalCondition
 * @sa SDL_WaitCondition
 * @sa SDL_WaitConditionTimeout
 * @sa SDL_DestroyCondition
 *
 * @from SDL_mutex.h:816 SDL_Condition * SDL_CreateCondition(void);
 */
  createCondition: lib.symbols.SDL_CreateCondition,

/**
 * Destroy a condition variable.
 *
 * @param cond the condition variable to destroy.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateCondition
 *
 * @from SDL_mutex.h:827 void SDL_DestroyCondition(SDL_Condition *cond);
 */
  destroyCondition: lib.symbols.SDL_DestroyCondition,

/**
 * Restart one of the threads that are waiting on the condition variable.
 *
 * @param cond the condition variable to signal.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BroadcastCondition
 * @sa SDL_WaitCondition
 * @sa SDL_WaitConditionTimeout
 *
 * @from SDL_mutex.h:842 void SDL_SignalCondition(SDL_Condition *cond);
 */
  signalCondition: lib.symbols.SDL_SignalCondition,

/**
 * Restart all threads that are waiting on the condition variable.
 *
 * @param cond the condition variable to signal.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SignalCondition
 * @sa SDL_WaitCondition
 * @sa SDL_WaitConditionTimeout
 *
 * @from SDL_mutex.h:857 void SDL_BroadcastCondition(SDL_Condition *cond);
 */
  broadcastCondition: lib.symbols.SDL_BroadcastCondition,

/**
 * Wait until a condition variable is signaled.
 *
 * This function unlocks the specified `mutex` and waits for another thread to
 * call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition
 * variable `cond`. Once the condition variable is signaled, the mutex is
 * re-locked and the function returns.
 *
 * The mutex must be locked before calling this function. Locking the mutex
 * recursively (more than once) is not supported and leads to undefined
 * behavior.
 *
 * This function is the equivalent of calling SDL_WaitConditionTimeout() with
 * a time length of -1.
 *
 * @param cond the condition variable to wait on.
 * @param mutex the mutex used to coordinate thread access.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BroadcastCondition
 * @sa SDL_SignalCondition
 * @sa SDL_WaitConditionTimeout
 *
 * @from SDL_mutex.h:885 void SDL_WaitCondition(SDL_Condition *cond, SDL_Mutex *mutex);
 */
  waitCondition: lib.symbols.SDL_WaitCondition,

/**
 * Wait until a condition variable is signaled or a certain time has passed.
 *
 * This function unlocks the specified `mutex` and waits for another thread to
 * call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition
 * variable `cond`, or for the specified time to elapse. Once the condition
 * variable is signaled or the time elapsed, the mutex is re-locked and the
 * function returns.
 *
 * The mutex must be locked before calling this function. Locking the mutex
 * recursively (more than once) is not supported and leads to undefined
 * behavior.
 *
 * @param cond the condition variable to wait on.
 * @param mutex the mutex used to coordinate thread access.
 * @param timeoutMS the maximum time to wait, in milliseconds, or -1 to wait
 *                  indefinitely.
 * @returns true if the condition variable is signaled, false if the condition
 *          is not signaled in the allotted time.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BroadcastCondition
 * @sa SDL_SignalCondition
 * @sa SDL_WaitCondition
 *
 * @from SDL_mutex.h:915 bool SDL_WaitConditionTimeout(SDL_Condition *cond,                                                SDL_Mutex *mutex, Sint32 timeoutMS);
 */
  waitConditionTimeout: lib.symbols.SDL_WaitConditionTimeout,

/**
 * Return whether initialization should be done.
 *
 * This function checks the passed in state and if initialization should be
 * done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.
 * If another thread is already modifying this state, it will wait until
 * that's done before returning.
 *
 * If this function returns true, the calling code must call
 * SDL_SetInitialized() to complete the initialization.
 *
 * @param state the initialization state to check.
 * @returns true if initialization needs to be done, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetInitialized
 * @sa SDL_ShouldQuit
 *
 * @from SDL_mutex.h:1022 bool SDL_ShouldInit(SDL_InitState *state);
 */
  shouldInit: lib.symbols.SDL_ShouldInit,

/**
 * Return whether cleanup should be done.
 *
 * This function checks the passed in state and if cleanup should be done,
 * sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.
 *
 * If this function returns true, the calling code must call
 * SDL_SetInitialized() to complete the cleanup.
 *
 * @param state the initialization state to check.
 * @returns true if cleanup needs to be done, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetInitialized
 * @sa SDL_ShouldInit
 *
 * @from SDL_mutex.h:1043 bool SDL_ShouldQuit(SDL_InitState *state);
 */
  shouldQuit: lib.symbols.SDL_ShouldQuit,

/**
 * Finish an initialization state transition.
 *
 * This function sets the status of the passed in state to
 * `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows
 * any threads waiting for the status to proceed.
 *
 * @param state the initialization state to check.
 * @param initialized the new initialization state.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ShouldInit
 * @sa SDL_ShouldQuit
 *
 * @from SDL_mutex.h:1062 void SDL_SetInitialized(SDL_InitState *state, bool initialized);
 */
  setInitialized: lib.symbols.SDL_SetInitialized,



/*--- SDL_pen ---*/

/**
 * @from SDL_pen:85 SDL_PEN_INPUT_
 */
  PEN_INPUT: SDL_pen_enums.PEN_INPUT,

/**
 * Pen axis indices.
 *
 * These are the valid values for the `axis` field in SDL_PenAxisEvent. All
 * axes are either normalised to 0..1 or report a (positive or negative) angle
 * in degrees, with 0.0 representing the centre. Not all pens/backends support
 * all axes: unsupported axes are always zero.
 *
 * To convert angles for tilt and rotation into vector representation, use
 * SDL_sinf on the XTILT, YTILT, or ROTATION component, for example:
 *
 * `SDL_sinf(xtilt * SDL_PI_F / 180.0)`.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pen.h:108 SDL_PEN_AXIS_
 */
  PEN_AXIS: SDL_pen_enums.SDL_PenAxis,





/*--- SDL_pixels ---*/

/**
 * Pixel type.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:133 SDL_PIXELTYPE_
 */
  PIXELTYPE: SDL_pixels_enums.SDL_PixelType,

/**
 * Bitmap pixel order, high bit -> low bit.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:156 SDL_BITMAPORDER_
 */
  BITMAPORDER: SDL_pixels_enums.SDL_BitmapOrder,

/**
 * Packed component order, high bit -> low bit.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:168 SDL_PACKEDORDER_
 */
  PACKEDORDER: SDL_pixels_enums.SDL_PackedOrder,

/**
 * Array component order, low byte -> high byte.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:186 SDL_ARRAYORDER_
 */
  ARRAYORDER: SDL_pixels_enums.SDL_ArrayOrder,

/**
 * Packed component layout.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:202 SDL_PACKEDLAYOUT_
 */
  PACKEDLAYOUT: SDL_pixels_enums.SDL_PackedLayout,

/**
 * Pixel format.
 *
 * SDL's pixel formats have the following naming convention:
 *
 * - Names with a list of components and a single bit count, such as RGB24 and
 *   ABGR32, define a platform-independent encoding into bytes in the order
 *   specified. For example, in RGB24 data, each pixel is encoded in 3 bytes
 *   (red, green, blue) in that order, and in ABGR32 data, each pixel is
 *   encoded in 4 bytes alpha, blue, green, red) in that order. Use these
 *   names if the property of a format that is important to you is the order
 *   of the bytes in memory or on disk.
 * - Names with a bit count per component, such as ARGB8888 and XRGB1555, are
 *   "packed" into an appropriately-sized integer in the platform's native
 *   endianness. For example, ARGB8888 is a sequence of 32-bit integers; in
 *   each integer, the most significant bits are alpha, and the least
 *   significant bits are blue. On a little-endian CPU such as x86, the least
 *   significant bits of each integer are arranged first in memory, but on a
 *   big-endian CPU such as s390x, the most significant bits are arranged
 *   first. Use these names if the property of a format that is important to
 *   you is the meaning of each bit position within a native-endianness
 *   integer.
 * - In indexed formats such as INDEX4LSB, each pixel is represented by
 *   encoding an index into the palette into the indicated number of bits,
 *   with multiple pixels packed into each byte if appropriate. In LSB
 *   formats, the first (leftmost) pixel is stored in the least-significant
 *   bits of the byte; in MSB formats, it's stored in the most-significant
 *   bits. INDEX8 does not need LSB/MSB variants, because each pixel exactly
 *   fills one byte.
 *
 * The 32-bit byte-array encodings such as RGBA32 are aliases for the
 * appropriate 8888 encoding for the current platform. For example, RGBA32 is
 * an alias for ABGR8888 on little-endian CPUs like x86, or an alias for
 * RGBA8888 on big-endian CPUs.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:547 SDL_PIXELFORMAT_
 */
  PIXELFORMAT: SDL_pixels_enums.SDL_PixelFormat,

/**
 * Colorspace color type.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:708 SDL_COLOR_TYPE_
 */
  COLOR_TYPE: SDL_pixels_enums.SDL_ColorType,

/**
 * Colorspace color range, as described by
 * https://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:721 SDL_COLOR_RANGE_
 */
  COLOR_RANGE: SDL_pixels_enums.SDL_ColorRange,

/**
 * Colorspace color primaries, as described by
 * https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:734 SDL_COLOR_PRIMARIES_
 */
  COLOR_PRIMARIES: SDL_pixels_enums.SDL_ColorPrimaries,

/**
 * Colorspace transfer characteristics.
 *
 * These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:759 SDL_TRANSFER_CHARACTERISTICS_
 */
  TRANSFER_CHARACTERISTICS: SDL_pixels_enums.SDL_TransferCharacteristics,

/**
 * Colorspace matrix coefficients.
 *
 * These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:789 SDL_MATRIX_COEFFICIENTS_
 */
  MATRIX_COEFFICIENTS: SDL_pixels_enums.SDL_MatrixCoefficients,

/**
 * Colorspace chroma sample location.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:813 SDL_CHROMA_LOCATION_
 */
  CHROMA_LOCATION: SDL_pixels_enums.SDL_ChromaLocation,

/**
 * Colorspace definitions.
 *
 * Since similar colorspaces may vary in their details (matrix, transfer
 * function, etc.), this is not an exhaustive list, but rather a
 * representative sample of the kinds of colorspaces supported in SDL.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_ColorPrimaries
 * @sa SDL_ColorRange
 * @sa SDL_ColorType
 * @sa SDL_MatrixCoefficients
 * @sa SDL_TransferCharacteristics
 *
 * @from SDL_pixels.h:1010 SDL_COLORSPACE_
 */
  COLORSPACE: SDL_pixels_enums.SDL_Colorspace,



/**
 * Get the human readable name of a pixel format.
 *
 * @param format the pixel format to query.
 * @returns the human readable name of the specified pixel format or
 *          "SDL_PIXELFORMAT_UNKNOWN" if the format isn't recognized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:1184 const char * SDL_GetPixelFormatName(SDL_PixelFormat format);
 */
  getPixelFormatName: lib.symbols.SDL_GetPixelFormatName,

/**
 * Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
 *
 * @param format one of the SDL_PixelFormat values.
 * @param bpp a bits per pixel value; usually 15, 16, or 32.
 * @param Rmask a pointer filled in with the red mask for the format.
 * @param Gmask a pointer filled in with the green mask for the format.
 * @param Bmask a pointer filled in with the blue mask for the format.
 * @param Amask a pointer filled in with the alpha mask for the format.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPixelFormatForMasks
 *
 * @from SDL_pixels.h:1204 bool SDL_GetMasksForPixelFormat(SDL_PixelFormat format, int *bpp, Uint32 *Rmask, Uint32 *Gmask, Uint32 *Bmask, Uint32 *Amask);
 */
  getMasksForPixelFormat: lib.symbols.SDL_GetMasksForPixelFormat,

/**
 * Convert a bpp value and RGBA masks to an enumerated pixel format.
 *
 * This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
 * possible.
 *
 * @param bpp a bits per pixel value; usually 15, 16, or 32.
 * @param Rmask the red mask for the format.
 * @param Gmask the green mask for the format.
 * @param Bmask the blue mask for the format.
 * @param Amask the alpha mask for the format.
 * @returns the SDL_PixelFormat value corresponding to the format masks, or
 *          SDL_PIXELFORMAT_UNKNOWN if there isn't a match.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetMasksForPixelFormat
 *
 * @from SDL_pixels.h:1226 SDL_PixelFormat SDL_GetPixelFormatForMasks(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
 */
  getPixelFormatForMasks: lib.symbols.SDL_GetPixelFormatForMasks,

/**
 * Create an SDL_PixelFormatDetails structure corresponding to a pixel format.
 *
 * Returned structure may come from a shared global cache (i.e. not newly
 * allocated), and hence should not be modified, especially the palette. Weird
 * errors such as `Blit combination not supported` may occur.
 *
 * @param format one of the SDL_PixelFormat values.
 * @returns a pointer to a SDL_PixelFormatDetails structure or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:1243 const SDL_PixelFormatDetails * SDL_GetPixelFormatDetails(SDL_PixelFormat format);
 */
  getPixelFormatDetails: lib.symbols.SDL_GetPixelFormatDetails,

/**
 * Create a palette structure with the specified number of color entries.
 *
 * The palette entries are initialized to white.
 *
 * @param ncolors represents the number of color entries in the color palette.
 * @returns a new SDL_Palette structure on success or NULL on failure (e.g. if
 *          there wasn't enough memory); call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyPalette
 * @sa SDL_SetPaletteColors
 * @sa SDL_SetSurfacePalette
 *
 * @from SDL_pixels.h:1263 SDL_Palette * SDL_CreatePalette(int ncolors);
 */
  createPalette: lib.symbols.SDL_CreatePalette,

/**
 * Set a range of colors in a palette.
 *
 * @param palette the SDL_Palette structure to modify.
 * @param colors an array of SDL_Color structures to copy into the palette.
 * @param firstcolor the index of the first palette entry to modify.
 * @param ncolors the number of entries to modify.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified or destroyed in another thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_pixels.h:1280 bool SDL_SetPaletteColors(SDL_Palette *palette, const SDL_Color *colors, int firstcolor, int ncolors);
 */
  setPaletteColors: lib.symbols.SDL_SetPaletteColors,

/**
 * Free a palette created with SDL_CreatePalette().
 *
 * @param palette the SDL_Palette structure to be freed.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified or destroyed in another thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreatePalette
 *
 * @from SDL_pixels.h:1294 void SDL_DestroyPalette(SDL_Palette *palette);
 */
  destroyPalette: lib.symbols.SDL_DestroyPalette,

/**
 * Map an RGB triple to an opaque pixel value for a given pixel format.
 *
 * This function maps the RGB color value to the specified pixel format and
 * returns the pixel value best approximating the given RGB color value for
 * the given pixel format.
 *
 * If the format has a palette (8-bit) the index of the closest matching color
 * in the palette will be returned.
 *
 * If the specified pixel format has an alpha component it will be returned as
 * all 1 bits (fully opaque).
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * @param format a pointer to SDL_PixelFormatDetails describing the pixel
 *               format.
 * @param palette an optional palette for indexed formats, may be NULL.
 * @param r the red component of the pixel in the range 0-255.
 * @param g the green component of the pixel in the range 0-255.
 * @param b the blue component of the pixel in the range 0-255.
 * @returns a pixel value.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPixelFormatDetails
 * @sa SDL_GetRGB
 * @sa SDL_MapRGBA
 * @sa SDL_MapSurfaceRGB
 *
 * @from SDL_pixels.h:1332 Uint32 SDL_MapRGB(const SDL_PixelFormatDetails *format, const SDL_Palette *palette, Uint8 r, Uint8 g, Uint8 b);
 */
  mapRgb: lib.symbols.SDL_MapRGB,

/**
 * Map an RGBA quadruple to a pixel value for a given pixel format.
 *
 * This function maps the RGBA color value to the specified pixel format and
 * returns the pixel value best approximating the given RGBA color value for
 * the given pixel format.
 *
 * If the specified pixel format has no alpha component the alpha value will
 * be ignored (as it will be in formats with a palette).
 *
 * If the format has a palette (8-bit) the index of the closest matching color
 * in the palette will be returned.
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * @param format a pointer to SDL_PixelFormatDetails describing the pixel
 *               format.
 * @param palette an optional palette for indexed formats, may be NULL.
 * @param r the red component of the pixel in the range 0-255.
 * @param g the green component of the pixel in the range 0-255.
 * @param b the blue component of the pixel in the range 0-255.
 * @param a the alpha component of the pixel in the range 0-255.
 * @returns a pixel value.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPixelFormatDetails
 * @sa SDL_GetRGBA
 * @sa SDL_MapRGB
 * @sa SDL_MapSurfaceRGBA
 *
 * @from SDL_pixels.h:1371 Uint32 SDL_MapRGBA(const SDL_PixelFormatDetails *format, const SDL_Palette *palette, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
 */
  mapRgba: lib.symbols.SDL_MapRGBA,

/**
 * Get RGB values from a pixel in the specified format.
 *
 * This function uses the entire 8-bit [0..255] range when converting color
 * components from pixel formats with less than 8-bits per RGB component
 * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
 *
 * @param pixel a pixel value.
 * @param format a pointer to SDL_PixelFormatDetails describing the pixel
 *               format.
 * @param palette an optional palette for indexed formats, may be NULL.
 * @param r a pointer filled in with the red component, may be NULL.
 * @param g a pointer filled in with the green component, may be NULL.
 * @param b a pointer filled in with the blue component, may be NULL.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPixelFormatDetails
 * @sa SDL_GetRGBA
 * @sa SDL_MapRGB
 * @sa SDL_MapRGBA
 *
 * @from SDL_pixels.h:1399 void SDL_GetRGB(Uint32 pixel, const SDL_PixelFormatDetails *format, const SDL_Palette *palette, Uint8 *r, Uint8 *g, Uint8 *b);
 */
  getRgb: lib.symbols.SDL_GetRGB,

/**
 * Get RGBA values from a pixel in the specified format.
 *
 * This function uses the entire 8-bit [0..255] range when converting color
 * components from pixel formats with less than 8-bits per RGB component
 * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
 *
 * If the surface has no alpha component, the alpha will be returned as 0xff
 * (100% opaque).
 *
 * @param pixel a pixel value.
 * @param format a pointer to SDL_PixelFormatDetails describing the pixel
 *               format.
 * @param palette an optional palette for indexed formats, may be NULL.
 * @param r a pointer filled in with the red component, may be NULL.
 * @param g a pointer filled in with the green component, may be NULL.
 * @param b a pointer filled in with the blue component, may be NULL.
 * @param a a pointer filled in with the alpha component, may be NULL.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the palette is not modified.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPixelFormatDetails
 * @sa SDL_GetRGB
 * @sa SDL_MapRGB
 * @sa SDL_MapRGBA
 *
 * @from SDL_pixels.h:1431 void SDL_GetRGBA(Uint32 pixel, const SDL_PixelFormatDetails *format, const SDL_Palette *palette, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
 */
  getRgba: lib.symbols.SDL_GetRGBA,



/*--- SDL_platform ---*/

/**
 * Get the name of the platform.
 *
 * Here are the names returned for some (but not all) supported platforms:
 *
 * - "Windows"
 * - "macOS"
 * - "Linux"
 * - "iOS"
 * - "Android"
 *
 * @returns the name of the platform. If the correct platform name is not
 *          available, returns a string beginning with the text "Unknown".
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_platform.h:55 const char * SDL_GetPlatform(void);
 */
  getPlatform: lib.symbols.SDL_GetPlatform,



/*--- SDL_power ---*/

/**
 * The basic state for the system's power supply.
 *
 * These are results returned by SDL_GetPowerInfo().
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_power.h:55 SDL_POWERSTATE_
 */
  POWERSTATE: SDL_power_enums.SDL_PowerState,



/**
 * Get the current power supply details.
 *
 * You should never take a battery status as absolute truth. Batteries
 * (especially failing batteries) are delicate hardware, and the values
 * reported here are best estimates based on what that hardware reports. It's
 * not uncommon for older batteries to lose stored power much faster than it
 * reports, or completely drain when reporting it has 20 percent left, etc.
 *
 * Battery status can change at any time; if you are concerned with power
 * state, you should call this function frequently, and perhaps ignore changes
 * until they seem to be stable for a few seconds.
 *
 * It's possible a platform can only report battery percentage or time left
 * but not both.
 *
 * On some platforms, retrieving power supply details might be expensive. If
 * you want to display continuous status you could call this function every
 * minute or so.
 *
 * @param seconds a pointer filled in with the seconds of battery life left,
 *                or NULL to ignore. This will be filled in with -1 if we
 *                can't determine a value or there is no battery.
 * @param percent a pointer filled in with the percentage of battery life
 *                left, between 0 and 100, or NULL to ignore. This will be
 *                filled in with -1 we can't determine a value or there is no
 *                battery.
 * @returns the current battery state or `SDL_POWERSTATE_ERROR` on failure;
 *          call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_power.h:97 SDL_PowerState SDL_GetPowerInfo(int *seconds, int *percent);
 */
  getPowerInfo: lib.symbols.SDL_GetPowerInfo,



/*--- SDL_process ---*/

/**
 * @from SDL_process:219 SDL_PROP_PROCESS_CREATE_
 */
  PROP_PROCESS_CREATE: SDL_process_enums.PROP_PROCESS_CREATE,

/**
 * @from SDL_process:261 SDL_PROP_PROCESS_
 */
  PROP_PROCESS: SDL_process_enums.PROP_PROCESS,

/**
 * Description of where standard I/O should be directed when creating a
 * process.
 *
 * If a standard I/O stream is set to SDL_PROCESS_STDIO_INHERITED, it will go
 * to the same place as the application's I/O stream. This is the default for
 * standard output and standard error.
 *
 * If a standard I/O stream is set to SDL_PROCESS_STDIO_NULL, it is connected
 * to `NUL:` on Windows and `/dev/null` on POSIX systems. This is the default
 * for standard input.
 *
 * If a standard I/O stream is set to SDL_PROCESS_STDIO_APP, it is connected
 * to a new SDL_IOStream that is available to the application. Standard input
 * will be available as `SDL_PROP_PROCESS_STDIN_POINTER` and allows
 * SDL_GetProcessInput(), standard output will be available as
 * `SDL_PROP_PROCESS_STDOUT_POINTER` and allows SDL_ReadProcess() and
 * SDL_GetProcessOutput(), and standard error will be available as
 * `SDL_PROP_PROCESS_STDERR_POINTER` in the properties for the created
 * process.
 *
 * If a standard I/O stream is set to SDL_PROCESS_STDIO_REDIRECT, it is
 * connected to an existing SDL_IOStream provided by the application. Standard
 * input is provided using `SDL_PROP_PROCESS_CREATE_STDIN_POINTER`, standard
 * output is provided using `SDL_PROP_PROCESS_CREATE_STDOUT_POINTER`, and
 * standard error is provided using `SDL_PROP_PROCESS_CREATE_STDERR_POINTER`
 * in the creation properties. These existing streams should be closed by the
 * application once the new process is created.
 *
 * In order to use an SDL_IOStream with SDL_PROCESS_STDIO_REDIRECT, it must
 * have `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER` or
 * `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER` set. This is true for streams
 * representing files and process I/O.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcessWithProperties
 * @sa SDL_GetProcessProperties
 * @sa SDL_ReadProcess
 * @sa SDL_GetProcessInput
 * @sa SDL_GetProcessOutput
 *
 * @from SDL_process.h:149 SDL_PROCESS_STDIO_
 */
  PROCESS_STDIO: SDL_process_enums.SDL_ProcessIO,



/**
 * Create a new process.
 *
 * The path to the executable is supplied in args[0]. args[1..N] are
 * additional arguments passed on the command line of the new process, and the
 * argument list should be terminated with a NULL, e.g.:
 *
 * ```c
 * const char *args[] = { "myprogram", "argument", NULL };
 * ```
 *
 * Setting pipe_stdio to true is equivalent to setting
 * `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` and
 * `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` to `SDL_PROCESS_STDIO_APP`, and
 * will allow the use of SDL_ReadProcess() or SDL_GetProcessInput() and
 * SDL_GetProcessOutput().
 *
 * See SDL_CreateProcessWithProperties() for more details.
 *
 * @param args the path and arguments for the new process.
 * @param pipe_stdio true to create pipes to the process's standard input and
 *                   from the process's standard output, false for the process
 *                   to have no input and inherit the application's standard
 *                   output.
 * @returns the newly created and running process, or NULL if the process
 *          couldn't be created.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcessWithProperties
 * @sa SDL_GetProcessProperties
 * @sa SDL_ReadProcess
 * @sa SDL_GetProcessInput
 * @sa SDL_GetProcessOutput
 * @sa SDL_KillProcess
 * @sa SDL_WaitProcess
 * @sa SDL_DestroyProcess
 *
 * @from SDL_process.h:105 SDL_Process * SDL_CreateProcess(const char * const *args, bool pipe_stdio);
 */
  createProcess: lib.symbols.SDL_CreateProcess,

/**
 * Create a new process with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_PROCESS_CREATE_ARGS_POINTER`: an array of strings containing
 *   the program to run, any arguments, and a NULL pointer, e.g. const char
 *   *args[] = { "myprogram", "argument", NULL }. This is a required property.
 * - `SDL_PROP_PROCESS_CREATE_ENVIRONMENT_POINTER`: an SDL_Environment
 *   pointer. If this property is set, it will be the entire environment for
 *   the process, otherwise the current environment is used.
 * - `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER`: an SDL_ProcessIO value describing
 *   where standard input for the process comes from, defaults to
 *   `SDL_PROCESS_STDIO_NULL`.
 * - `SDL_PROP_PROCESS_CREATE_STDIN_POINTER`: an SDL_IOStream pointer used for
 *   standard input when `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` is set to
 *   `SDL_PROCESS_STDIO_REDIRECT`.
 * - `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER`: an SDL_ProcessIO value
 *   describing where standard output for the process goes to, defaults to
 *   `SDL_PROCESS_STDIO_INHERITED`.
 * - `SDL_PROP_PROCESS_CREATE_STDOUT_POINTER`: an SDL_IOStream pointer used
 *   for standard output when `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` is set
 *   to `SDL_PROCESS_STDIO_REDIRECT`.
 * - `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER`: an SDL_ProcessIO value
 *   describing where standard error for the process goes to, defaults to
 *   `SDL_PROCESS_STDIO_INHERITED`.
 * - `SDL_PROP_PROCESS_CREATE_STDERR_POINTER`: an SDL_IOStream pointer used
 *   for standard error when `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` is set to
 *   `SDL_PROCESS_STDIO_REDIRECT`.
 * - `SDL_PROP_PROCESS_CREATE_STDERR_TO_STDOUT_BOOLEAN`: true if the error
 *   output of the process should be redirected into the standard output of
 *   the process. This property has no effect if
 *   `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` is set.
 * - `SDL_PROP_PROCESS_CREATE_BACKGROUND_BOOLEAN`: true if the process should
 *   run in the background. In this case the default input and output is
 *   `SDL_PROCESS_STDIO_NULL` and the exitcode of the process is not
 *   available, and will always be 0.
 *
 * On POSIX platforms, wait() and waitpid(-1, ...) should not be called, and
 * SIGCHLD should not be ignored or handled because those would prevent SDL
 * from properly tracking the lifetime of the underlying process. You should
 * use SDL_WaitProcess() instead.
 *
 * @param props the properties to use.
 * @returns the newly created and running process, or NULL if the process
 *          couldn't be created.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcess
 * @sa SDL_GetProcessProperties
 * @sa SDL_ReadProcess
 * @sa SDL_GetProcessInput
 * @sa SDL_GetProcessOutput
 * @sa SDL_KillProcess
 * @sa SDL_WaitProcess
 * @sa SDL_DestroyProcess
 *
 * @from SDL_process.h:217 SDL_Process * SDL_CreateProcessWithProperties(SDL_PropertiesID props);
 */
  createProcessWithProperties: lib.symbols.SDL_CreateProcessWithProperties,

/**
 * Get the properties associated with a process.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_PROCESS_PID_NUMBER`: the process ID of the process.
 * - `SDL_PROP_PROCESS_STDIN_POINTER`: an SDL_IOStream that can be used to
 *   write input to the process, if it was created with
 *   `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 * - `SDL_PROP_PROCESS_STDOUT_POINTER`: a non-blocking SDL_IOStream that can
 *   be used to read output from the process, if it was created with
 *   `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 * - `SDL_PROP_PROCESS_STDERR_POINTER`: a non-blocking SDL_IOStream that can
 *   be used to read error output from the process, if it was created with
 *   `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 * - `SDL_PROP_PROCESS_BACKGROUND_BOOLEAN`: true if the process is running in
 *   the background.
 *
 * @param process the process to query.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcess
 * @sa SDL_CreateProcessWithProperties
 *
 * @from SDL_process.h:259 SDL_PropertiesID SDL_GetProcessProperties(SDL_Process *process);
 */
  getProcessProperties: lib.symbols.SDL_GetProcessProperties,

/**
 * Read all the output from a process.
 *
 * If a process was created with I/O enabled, you can use this function to
 * read the output. This function blocks until the process is complete,
 * capturing all output, and providing the process exit code.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported via
 * `datasize`.
 *
 * The data should be freed with SDL_free().
 *
 * @param process The process to read.
 * @param datasize a pointer filled in with the number of bytes read, may be
 *                 NULL.
 * @param exitcode a pointer filled in with the process exit code if the
 *                 process has exited, may be NULL.
 * @returns the data or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcess
 * @sa SDL_CreateProcessWithProperties
 * @sa SDL_DestroyProcess
 *
 * @from SDL_process.h:296 void * SDL_ReadProcess(SDL_Process *process, size_t *datasize, int *exitcode);
 */
  readProcess: lib.symbols.SDL_ReadProcess,

/**
 * Get the SDL_IOStream associated with process standard input.
 *
 * The process must have been created with SDL_CreateProcess() and pipe_stdio
 * set to true, or with SDL_CreateProcessWithProperties() and
 * `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 *
 * Writing to this stream can return less data than expected if the process
 * hasn't read its input. It may be blocked waiting for its output to be read,
 * if so you may need to call SDL_GetProcessOutput() and read the output in
 * parallel with writing input.
 *
 * @param process The process to get the input stream for.
 * @returns the input stream or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcess
 * @sa SDL_CreateProcessWithProperties
 * @sa SDL_GetProcessOutput
 *
 * @from SDL_process.h:322 SDL_IOStream * SDL_GetProcessInput(SDL_Process *process);
 */
  getProcessInput: lib.symbols.SDL_GetProcessInput,

/**
 * Get the SDL_IOStream associated with process standard output.
 *
 * The process must have been created with SDL_CreateProcess() and pipe_stdio
 * set to true, or with SDL_CreateProcessWithProperties() and
 * `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` set to `SDL_PROCESS_STDIO_APP`.
 *
 * Reading from this stream can return 0 with SDL_GetIOStatus() returning
 * SDL_IO_STATUS_NOT_READY if no output is available yet.
 *
 * @param process The process to get the output stream for.
 * @returns the output stream or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcess
 * @sa SDL_CreateProcessWithProperties
 * @sa SDL_GetProcessInput
 *
 * @from SDL_process.h:346 SDL_IOStream * SDL_GetProcessOutput(SDL_Process *process);
 */
  getProcessOutput: lib.symbols.SDL_GetProcessOutput,

/**
 * Stop a process.
 *
 * @param process The process to stop.
 * @param force true to terminate the process immediately, false to try to
 *              stop the process gracefully. In general you should try to stop
 *              the process gracefully first as terminating a process may
 *              leave it with half-written data or in some other unstable
 *              state.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcess
 * @sa SDL_CreateProcessWithProperties
 * @sa SDL_WaitProcess
 * @sa SDL_DestroyProcess
 *
 * @from SDL_process.h:369 bool SDL_KillProcess(SDL_Process *process, bool force);
 */
  killProcess: lib.symbols.SDL_KillProcess,

/**
 * Wait for a process to finish.
 *
 * This can be called multiple times to get the status of a process.
 *
 * The exit code will be the exit code of the process if it terminates
 * normally, a negative signal if it terminated due to a signal, or -255
 * otherwise. It will not be changed if the process is still running.
 *
 * If you create a process with standard output piped to the application
 * (`pipe_stdio` being true) then you should read all of the process output
 * before calling SDL_WaitProcess(). If you don't do this the process might be
 * blocked indefinitely waiting for output to be read and SDL_WaitProcess()
 * will never return true;
 *
 * @param process The process to wait for.
 * @param block If true, block until the process finishes; otherwise, report
 *              on the process' status.
 * @param exitcode a pointer filled in with the process exit code if the
 *                 process has exited, may be NULL.
 * @returns true if the process exited, false otherwise.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcess
 * @sa SDL_CreateProcessWithProperties
 * @sa SDL_KillProcess
 * @sa SDL_DestroyProcess
 *
 * @from SDL_process.h:402 bool SDL_WaitProcess(SDL_Process *process, bool block, int *exitcode);
 */
  waitProcess: lib.symbols.SDL_WaitProcess,

/**
 * Destroy a previously created process object.
 *
 * Note that this does not stop the process, just destroys the SDL object used
 * to track it. If you want to stop the process you should use
 * SDL_KillProcess().
 *
 * @param process The process object to destroy.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProcess
 * @sa SDL_CreateProcessWithProperties
 * @sa SDL_KillProcess
 *
 * @from SDL_process.h:421 void SDL_DestroyProcess(SDL_Process *process);
 */
  destroyProcess: lib.symbols.SDL_DestroyProcess,



/*--- SDL_properties ---*/

/**
 * SDL property type
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_properties.h:72 SDL_PROPERTY_TYPE_
 */
  PROPERTY_TYPE: SDL_properties_enums.SDL_PropertyType,



/**
 * Get the global SDL properties.
 *
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_properties.h:90 SDL_PropertiesID SDL_GetGlobalProperties(void);
 */
  getGlobalProperties: lib.symbols.SDL_GetGlobalProperties,

/**
 * Create a group of properties.
 *
 * All properties are automatically destroyed when SDL_Quit() is called.
 *
 * @returns an ID for a new group of properties, or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyProperties
 *
 * @from SDL_properties.h:106 SDL_PropertiesID SDL_CreateProperties(void);
 */
  createProperties: lib.symbols.SDL_CreateProperties,

/**
 * Copy a group of properties.
 *
 * Copy all the properties from one group of properties to another, with the
 * exception of properties requiring cleanup (set using
 * SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any
 * property that already exists on `dst` will be overwritten.
 *
 * @param src the properties to copy.
 * @param dst the destination properties.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_properties.h:125 bool SDL_CopyProperties(SDL_PropertiesID src, SDL_PropertiesID dst);
 */
  copyProperties: lib.symbols.SDL_CopyProperties,

/**
 * Lock a group of properties.
 *
 * Obtain a multi-threaded lock for these properties. Other threads will wait
 * while trying to lock these properties until they are unlocked. Properties
 * must be unlocked before they are destroyed.
 *
 * The lock is automatically taken when setting individual properties, this
 * function is only needed when you want to set several properties atomically
 * or want to guarantee that properties being queried aren't freed in another
 * thread.
 *
 * @param props the properties to lock.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UnlockProperties
 *
 * @from SDL_properties.h:149 bool SDL_LockProperties(SDL_PropertiesID props);
 */
  lockProperties: lib.symbols.SDL_LockProperties,

/**
 * Unlock a group of properties.
 *
 * @param props the properties to unlock.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockProperties
 *
 * @from SDL_properties.h:162 void SDL_UnlockProperties(SDL_PropertiesID props);
 */
  unlockProperties: lib.symbols.SDL_UnlockProperties,

/**
 * Set a pointer property in a group of properties with a cleanup function
 * that is called when the property is deleted.
 *
 * The cleanup function is also called if setting the property fails for any
 * reason.
 *
 * For simply setting basic data types, like numbers, bools, or strings, use
 * SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty
 * instead, as those functions will handle cleanup on your behalf. This
 * function is only for more complex, custom data.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property, or NULL to delete the property.
 * @param cleanup the function to call when this property is deleted, or NULL
 *                if no cleanup is necessary.
 * @param userdata a pointer that is passed to the cleanup function.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPointerProperty
 * @sa SDL_SetPointerProperty
 * @sa SDL_CleanupPropertyCallback
 *
 * @from SDL_properties.h:217 bool SDL_SetPointerPropertyWithCleanup(SDL_PropertiesID props, const char *name, void *value, SDL_CleanupPropertyCallback cleanup, void *userdata);
 */
  setPointerPropertyWithCleanup: lib.symbols.SDL_SetPointerPropertyWithCleanup,

/**
 * Set a pointer property in a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property, or NULL to delete the property.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPointerProperty
 * @sa SDL_HasProperty
 * @sa SDL_SetBooleanProperty
 * @sa SDL_SetFloatProperty
 * @sa SDL_SetNumberProperty
 * @sa SDL_SetPointerPropertyWithCleanup
 * @sa SDL_SetStringProperty
 *
 * @from SDL_properties.h:240 bool SDL_SetPointerProperty(SDL_PropertiesID props, const char *name, void *value);
 */
  setPointerProperty: lib.symbols.SDL_SetPointerProperty,

/**
 * Set a string property in a group of properties.
 *
 * This function makes a copy of the string; the caller does not have to
 * preserve the data after this call completes.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property, or NULL to delete the property.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetStringProperty
 *
 * @from SDL_properties.h:260 bool SDL_SetStringProperty(SDL_PropertiesID props, const char *name, const char *value);
 */
  setStringProperty: lib.symbols.SDL_SetStringProperty,

/**
 * Set an integer property in a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumberProperty
 *
 * @from SDL_properties.h:277 bool SDL_SetNumberProperty(SDL_PropertiesID props, const char *name, Sint64 value);
 */
  setNumberProperty: lib.symbols.SDL_SetNumberProperty,

/**
 * Set a floating point property in a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetFloatProperty
 *
 * @from SDL_properties.h:294 bool SDL_SetFloatProperty(SDL_PropertiesID props, const char *name, float value);
 */
  setFloatProperty: lib.symbols.SDL_SetFloatProperty,

/**
 * Set a boolean property in a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to modify.
 * @param value the new value of the property.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetBooleanProperty
 *
 * @from SDL_properties.h:311 bool SDL_SetBooleanProperty(SDL_PropertiesID props, const char *name, bool value);
 */
  setBooleanProperty: lib.symbols.SDL_SetBooleanProperty,

/**
 * Return whether a property exists in a group of properties.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @returns true if the property exists, or false if it doesn't.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPropertyType
 *
 * @from SDL_properties.h:326 bool SDL_HasProperty(SDL_PropertiesID props, const char *name);
 */
  hasProperty: lib.symbols.SDL_HasProperty,

/**
 * Get the type of a property in a group of properties.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @returns the type of the property, or SDL_PROPERTY_TYPE_INVALID if it is
 *          not set.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasProperty
 *
 * @from SDL_properties.h:342 SDL_PropertyType SDL_GetPropertyType(SDL_PropertiesID props, const char *name);
 */
  getPropertyType: lib.symbols.SDL_GetPropertyType,

/**
 * Get a pointer property from a group of properties.
 *
 * By convention, the names of properties that SDL exposes on objects will
 * start with "SDL.", and properties that SDL uses internally will start with
 * "SDL.internal.". These should be considered read-only and should not be
 * modified by applications.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a pointer property.
 *
 * @threadsafety It is safe to call this function from any thread, although
 *               the data returned is not protected and could potentially be
 *               freed if you call SDL_SetPointerProperty() or
 *               SDL_ClearProperty() on these properties from another thread.
 *               If you need to avoid this, use SDL_LockProperties() and
 *               SDL_UnlockProperties().
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetBooleanProperty
 * @sa SDL_GetFloatProperty
 * @sa SDL_GetNumberProperty
 * @sa SDL_GetPropertyType
 * @sa SDL_GetStringProperty
 * @sa SDL_HasProperty
 * @sa SDL_SetPointerProperty
 *
 * @from SDL_properties.h:375 void * SDL_GetPointerProperty(SDL_PropertiesID props, const char *name, void *default_value);
 */
  getPointerProperty: lib.symbols.SDL_GetPointerProperty,

/**
 * Get a string property from a group of properties.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a string property.
 *
 * @threadsafety It is safe to call this function from any thread, although
 *               the data returned is not protected and could potentially be
 *               freed if you call SDL_SetStringProperty() or
 *               SDL_ClearProperty() on these properties from another thread.
 *               If you need to avoid this, use SDL_LockProperties() and
 *               SDL_UnlockProperties().
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPropertyType
 * @sa SDL_HasProperty
 * @sa SDL_SetStringProperty
 *
 * @from SDL_properties.h:399 const char * SDL_GetStringProperty(SDL_PropertiesID props, const char *name, const char *default_value);
 */
  getStringProperty: lib.symbols.SDL_GetStringProperty,

/**
 * Get a number property from a group of properties.
 *
 * You can use SDL_GetPropertyType() to query whether the property exists and
 * is a number property.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a number property.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPropertyType
 * @sa SDL_HasProperty
 * @sa SDL_SetNumberProperty
 *
 * @from SDL_properties.h:421 Sint64 SDL_GetNumberProperty(SDL_PropertiesID props, const char *name, Sint64 default_value);
 */
  getNumberProperty: lib.symbols.SDL_GetNumberProperty,

/**
 * Get a floating point property from a group of properties.
 *
 * You can use SDL_GetPropertyType() to query whether the property exists and
 * is a floating point property.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a float property.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPropertyType
 * @sa SDL_HasProperty
 * @sa SDL_SetFloatProperty
 *
 * @from SDL_properties.h:443 float SDL_GetFloatProperty(SDL_PropertiesID props, const char *name, float default_value);
 */
  getFloatProperty: lib.symbols.SDL_GetFloatProperty,

/**
 * Get a boolean property from a group of properties.
 *
 * You can use SDL_GetPropertyType() to query whether the property exists and
 * is a boolean property.
 *
 * @param props the properties to query.
 * @param name the name of the property to query.
 * @param default_value the default value of the property.
 * @returns the value of the property, or `default_value` if it is not set or
 *          not a boolean property.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPropertyType
 * @sa SDL_HasProperty
 * @sa SDL_SetBooleanProperty
 *
 * @from SDL_properties.h:465 bool SDL_GetBooleanProperty(SDL_PropertiesID props, const char *name, bool default_value);
 */
  getBooleanProperty: lib.symbols.SDL_GetBooleanProperty,

/**
 * Clear a property from a group of properties.
 *
 * @param props the properties to modify.
 * @param name the name of the property to clear.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_properties.h:479 bool SDL_ClearProperty(SDL_PropertiesID props, const char *name);
 */
  clearProperty: lib.symbols.SDL_ClearProperty,

/**
 * Enumerate the properties contained in a group of properties.
 *
 * The callback function is called for each property in the group of
 * properties. The properties are locked during enumeration.
 *
 * @param props the properties to query.
 * @param callback the function to call for each property.
 * @param userdata a pointer that is passed to `callback`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_properties.h:516 bool SDL_EnumerateProperties(SDL_PropertiesID props, SDL_EnumeratePropertiesCallback callback, void *userdata);
 */
  enumerateProperties: lib.symbols.SDL_EnumerateProperties,

/**
 * Destroy a group of properties.
 *
 * All properties are deleted and their cleanup functions will be called, if
 * any.
 *
 * @param props the properties to destroy.
 *
 * @threadsafety This function should not be called while these properties are
 *               locked or other threads might be setting or getting values
 *               from these properties.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProperties
 *
 * @from SDL_properties.h:534 void SDL_DestroyProperties(SDL_PropertiesID props);
 */
  destroyProperties: lib.symbols.SDL_DestroyProperties,



/*--- SDL_rect ---*/

/**
 * Determine whether two rectangles intersect.
 *
 * If either pointer is NULL the function will return false.
 *
 * @param A an SDL_Rect structure representing the first rectangle.
 * @param B an SDL_Rect structure representing the second rectangle.
 * @returns true if there is an intersection, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRectIntersection
 *
 * @from SDL_rect.h:223 bool SDL_HasRectIntersection(const SDL_Rect *A, const SDL_Rect *B);
 */
  hasRectIntersection: lib.symbols.SDL_HasRectIntersection,

/**
 * Calculate the intersection of two rectangles.
 *
 * If `result` is NULL then this function will return false.
 *
 * @param A an SDL_Rect structure representing the first rectangle.
 * @param B an SDL_Rect structure representing the second rectangle.
 * @param result an SDL_Rect structure filled in with the intersection of
 *               rectangles `A` and `B`.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasRectIntersection
 *
 * @from SDL_rect.h:240 bool SDL_GetRectIntersection(const SDL_Rect *A, const SDL_Rect *B, SDL_Rect *result);
 */
  getRectIntersection: lib.symbols.SDL_GetRectIntersection,

/**
 * Calculate the union of two rectangles.
 *
 * @param A an SDL_Rect structure representing the first rectangle.
 * @param B an SDL_Rect structure representing the second rectangle.
 * @param result an SDL_Rect structure filled in with the union of rectangles
 *               `A` and `B`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_rect.h:254 bool SDL_GetRectUnion(const SDL_Rect *A, const SDL_Rect *B, SDL_Rect *result);
 */
  getRectUnion: lib.symbols.SDL_GetRectUnion,

/**
 * Calculate a minimal rectangle enclosing a set of points.
 *
 * If `clip` is not NULL then only points inside of the clipping rectangle are
 * considered.
 *
 * @param points an array of SDL_Point structures representing points to be
 *               enclosed.
 * @param count the number of structures in the `points` array.
 * @param clip an SDL_Rect used for clipping or NULL to enclose all points.
 * @param result an SDL_Rect structure filled in with the minimal enclosing
 *               rectangle.
 * @returns true if any points were enclosed or false if all the points were
 *          outside of the clipping rectangle.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_rect.h:273 bool SDL_GetRectEnclosingPoints(const SDL_Point *points, int count, const SDL_Rect *clip, SDL_Rect *result);
 */
  getRectEnclosingPoints: lib.symbols.SDL_GetRectEnclosingPoints,

/**
 * Calculate the intersection of a rectangle and line segment.
 *
 * This function is used to clip a line segment to a rectangle. A line segment
 * contained entirely within the rectangle or that does not intersect will
 * remain unchanged. A line segment that crosses the rectangle at either or
 * both ends will be clipped to the boundary of the rectangle and the new
 * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
 *
 * @param rect an SDL_Rect structure representing the rectangle to intersect.
 * @param X1 a pointer to the starting X-coordinate of the line.
 * @param Y1 a pointer to the starting Y-coordinate of the line.
 * @param X2 a pointer to the ending X-coordinate of the line.
 * @param Y2 a pointer to the ending Y-coordinate of the line.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_rect.h:293 bool SDL_GetRectAndLineIntersection(const SDL_Rect *rect, int *X1, int *Y1, int *X2, int *Y2);
 */
  getRectAndLineIntersection: lib.symbols.SDL_GetRectAndLineIntersection,

/**
 * Determine whether two rectangles intersect with float precision.
 *
 * If either pointer is NULL the function will return false.
 *
 * @param A an SDL_FRect structure representing the first rectangle.
 * @param B an SDL_FRect structure representing the second rectangle.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRectIntersection
 *
 * @from SDL_rect.h:426 bool SDL_HasRectIntersectionFloat(const SDL_FRect *A, const SDL_FRect *B);
 */
  hasRectIntersectionFloat: lib.symbols.SDL_HasRectIntersectionFloat,

/**
 * Calculate the intersection of two rectangles with float precision.
 *
 * If `result` is NULL then this function will return false.
 *
 * @param A an SDL_FRect structure representing the first rectangle.
 * @param B an SDL_FRect structure representing the second rectangle.
 * @param result an SDL_FRect structure filled in with the intersection of
 *               rectangles `A` and `B`.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HasRectIntersectionFloat
 *
 * @from SDL_rect.h:443 bool SDL_GetRectIntersectionFloat(const SDL_FRect *A, const SDL_FRect *B, SDL_FRect *result);
 */
  getRectIntersectionFloat: lib.symbols.SDL_GetRectIntersectionFloat,

/**
 * Calculate the union of two rectangles with float precision.
 *
 * @param A an SDL_FRect structure representing the first rectangle.
 * @param B an SDL_FRect structure representing the second rectangle.
 * @param result an SDL_FRect structure filled in with the union of rectangles
 *               `A` and `B`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_rect.h:457 bool SDL_GetRectUnionFloat(const SDL_FRect *A, const SDL_FRect *B, SDL_FRect *result);
 */
  getRectUnionFloat: lib.symbols.SDL_GetRectUnionFloat,

/**
 * Calculate a minimal rectangle enclosing a set of points with float
 * precision.
 *
 * If `clip` is not NULL then only points inside of the clipping rectangle are
 * considered.
 *
 * @param points an array of SDL_FPoint structures representing points to be
 *               enclosed.
 * @param count the number of structures in the `points` array.
 * @param clip an SDL_FRect used for clipping or NULL to enclose all points.
 * @param result an SDL_FRect structure filled in with the minimal enclosing
 *               rectangle.
 * @returns true if any points were enclosed or false if all the points were
 *          outside of the clipping rectangle.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_rect.h:477 bool SDL_GetRectEnclosingPointsFloat(const SDL_FPoint *points, int count, const SDL_FRect *clip, SDL_FRect *result);
 */
  getRectEnclosingPointsFloat: lib.symbols.SDL_GetRectEnclosingPointsFloat,

/**
 * Calculate the intersection of a rectangle and line segment with float
 * precision.
 *
 * This function is used to clip a line segment to a rectangle. A line segment
 * contained entirely within the rectangle or that does not intersect will
 * remain unchanged. A line segment that crosses the rectangle at either or
 * both ends will be clipped to the boundary of the rectangle and the new
 * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
 *
 * @param rect an SDL_FRect structure representing the rectangle to intersect.
 * @param X1 a pointer to the starting X-coordinate of the line.
 * @param Y1 a pointer to the starting Y-coordinate of the line.
 * @param X2 a pointer to the ending X-coordinate of the line.
 * @param Y2 a pointer to the ending Y-coordinate of the line.
 * @returns true if there is an intersection, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_rect.h:498 bool SDL_GetRectAndLineIntersectionFloat(const SDL_FRect *rect, float *X1, float *Y1, float *X2, float *Y2);
 */
  getRectAndLineIntersectionFloat: lib.symbols.SDL_GetRectAndLineIntersectionFloat,



/*--- SDL_render ---*/

/**
 * @from SDL_render:300 SDL_PROP_RENDERER_CREATE_
 */
  PROP_RENDERER_CREATE: SDL_render_enums.PROP_RENDERER_CREATE,

/**
 * @from SDL_render:461 SDL_PROP_RENDERER_
 */
  PROP_RENDERER: SDL_render_enums.PROP_RENDERER,

/**
 * @from SDL_render:697 SDL_PROP_TEXTURE_CREATE_
 */
  PROP_TEXTURE_CREATE: SDL_render_enums.PROP_TEXTURE_CREATE,

/**
 * @from SDL_render:809 SDL_PROP_TEXTURE_
 */
  PROP_TEXTURE: SDL_render_enums.PROP_TEXTURE,

/**
 * @from SDL_render:2539 SDL_RENDERER_VSYNC_
 */
  RENDERER_VSYNC: SDL_render_enums.RENDERER_VSYNC,

/**
 * The access pattern allowed for a texture.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_render.h:92 SDL_TEXTUREACCESS_
 */
  TEXTUREACCESS: SDL_render_enums.SDL_TextureAccess,

/**
 * How the logical size is mapped to the output.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_render.h:104 SDL_LOGICAL_PRESENTATION_
 */
  LOGICAL_PRESENTATION: SDL_render_enums.SDL_RendererLogicalPresentation,



/**
 * Get the number of 2D rendering drivers available for the current display.
 *
 * A render driver is a set of code that handles rendering and texture
 * management on a particular display. Normally there is only one, but some
 * drivers may have several available with different capabilities.
 *
 * There may be none if SDL was compiled without render support.
 *
 * @returns the number of built in render drivers.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateRenderer
 * @sa SDL_GetRenderDriver
 *
 * @from SDL_render.h:164 int SDL_GetNumRenderDrivers(void);
 */
  getNumRenderDrivers: lib.symbols.SDL_GetNumRenderDrivers,

/**
 * Use this function to get the name of a built in 2D rendering driver.
 *
 * The list of rendering drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "opengl",
 * "direct3d12" or "metal". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * @param index the index of the rendering driver; the value ranges from 0 to
 *              SDL_GetNumRenderDrivers() - 1.
 * @returns the name of the rendering driver at the requested index, or NULL
 *          if an invalid index was specified.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumRenderDrivers
 *
 * @from SDL_render.h:188 const char * SDL_GetRenderDriver(int index);
 */
  getRenderDriver: lib.symbols.SDL_GetRenderDriver,

/**
 * Create a window and default renderer.
 *
 * @param title the title of the window, in UTF-8 encoding.
 * @param width the width of the window.
 * @param height the height of the window.
 * @param window_flags the flags used to create the window (see
 *                     SDL_CreateWindow()).
 * @param window a pointer filled with the window, or NULL on error.
 * @param renderer a pointer filled with the renderer, or NULL on error.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateRenderer
 * @sa SDL_CreateWindow
 *
 * @from SDL_render.h:210 bool SDL_CreateWindowAndRenderer(const char *title, int width, int height, SDL_WindowFlags window_flags, SDL_Window **window, SDL_Renderer **renderer);
 */
  createWindowAndRenderer: lib.symbols.SDL_CreateWindowAndRenderer,

/**
 * Create a 2D rendering context for a window.
 *
 * If you want a specific renderer, you can specify its name here. A list of
 * available renderers can be obtained by calling SDL_GetRenderDriver()
 * multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you
 * don't need a specific renderer, specify NULL and SDL will attempt to choose
 * the best option for you, based on what is available on the user's system.
 *
 * If `name` is a comma-separated list, SDL will try each name, in the order
 * listed, until one succeeds or all of them fail.
 *
 * By default the rendering size matches the window size in pixels, but you
 * can call SDL_SetRenderLogicalPresentation() to change the content size and
 * scaling options.
 *
 * @param window the window where rendering is displayed.
 * @param name the name of the rendering driver to initialize, or NULL to let
 *             SDL choose one.
 * @returns a valid rendering context or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateRendererWithProperties
 * @sa SDL_CreateSoftwareRenderer
 * @sa SDL_DestroyRenderer
 * @sa SDL_GetNumRenderDrivers
 * @sa SDL_GetRenderDriver
 * @sa SDL_GetRendererName
 *
 * @from SDL_render.h:245 SDL_Renderer * SDL_CreateRenderer(SDL_Window *window, const char *name);
 */
  createRenderer: lib.symbols.SDL_CreateRenderer,

/**
 * Create a 2D rendering context for a window, with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver
 *   to use, if a specific one is desired
 * - `SDL_PROP_RENDERER_CREATE_WINDOW_POINTER`: the window where rendering is
 *   displayed, required if this isn't a software renderer using a surface
 * - `SDL_PROP_RENDERER_CREATE_SURFACE_POINTER`: the surface where rendering
 *   is displayed, if you want a software renderer without a window
 * - `SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace
 *   value describing the colorspace for output to the display, defaults to
 *   SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers
 *   support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and
 *   supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing
 *   still uses the sRGB colorspace, but values can go beyond 1.0 and float
 *   (linear) format textures can be used for HDR content.
 * - `SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want
 *   present synchronized with the refresh rate. This property can take any
 *   value that is supported by SDL_SetRenderVSync() for the renderer.
 *
 * With the vulkan renderer:
 *
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use
 *   with the renderer, optional.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use
 *   with the renderer, optional.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the
 *   VkPhysicalDevice to use with the renderer, optional.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use
 *   with the renderer, optional.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the
 *   queue family index used for rendering.
 * - `SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the
 *   queue family index used for presentation.
 *
 * @param props the properties to use.
 * @returns a valid rendering context or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProperties
 * @sa SDL_CreateRenderer
 * @sa SDL_CreateSoftwareRenderer
 * @sa SDL_DestroyRenderer
 * @sa SDL_GetRendererName
 *
 * @from SDL_render.h:298 SDL_Renderer * SDL_CreateRendererWithProperties(SDL_PropertiesID props);
 */
  createRendererWithProperties: lib.symbols.SDL_CreateRendererWithProperties,

/**
 * Create a 2D software rendering context for a surface.
 *
 * Two other API which can be used to create SDL_Renderer:
 * SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_
 * create a software renderer, but they are intended to be used with an
 * SDL_Window as the final destination and not an SDL_Surface.
 *
 * @param surface the SDL_Surface structure representing the surface where
 *                rendering is done.
 * @returns a valid rendering context or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyRenderer
 *
 * @from SDL_render.h:331 SDL_Renderer * SDL_CreateSoftwareRenderer(SDL_Surface *surface);
 */
  createSoftwareRenderer: lib.symbols.SDL_CreateSoftwareRenderer,

/**
 * Get the renderer associated with a window.
 *
 * @param window the window to query.
 * @returns the rendering context on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:344 SDL_Renderer * SDL_GetRenderer(SDL_Window *window);
 */
  getRenderer: lib.symbols.SDL_GetRenderer,

/**
 * Get the window associated with a renderer.
 *
 * @param renderer the renderer to query.
 * @returns the window on success or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:357 SDL_Window * SDL_GetRenderWindow(SDL_Renderer *renderer);
 */
  getRenderWindow: lib.symbols.SDL_GetRenderWindow,

/**
 * Get the name of a renderer.
 *
 * @param renderer the rendering context.
 * @returns the name of the selected renderer, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateRenderer
 * @sa SDL_CreateRendererWithProperties
 *
 * @from SDL_render.h:373 const char * SDL_GetRendererName(SDL_Renderer *renderer);
 */
  getRendererName: lib.symbols.SDL_GetRendererName,

/**
 * Get the properties associated with a renderer.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver
 * - `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is
 *   displayed, if any
 * - `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is
 *   displayed, if this is a software renderer without a window
 * - `SDL_PROP_RENDERER_VSYNC_NUMBER`: the current vsync setting
 * - `SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width
 *   and height
 * - `SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER`: a (const SDL_PixelFormat *)
 *   array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN,
 *   representing the available texture formats for this renderer.
 * - `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace value
 *   describing the colorspace for output to the display, defaults to
 *   SDL_COLORSPACE_SRGB.
 * - `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is
 *   SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with
 *   HDR enabled. This property can change dynamically when
 *   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the
 *   SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is
 *   automatically multiplied into the color scale. This property can change
 *   dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range
 *   that can be displayed, in terms of the SDR white point. When HDR is not
 *   enabled, this will be 1.0. This property can change dynamically when
 *   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 *
 * With the direct3d renderer:
 *
 * - `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated
 *   with the renderer
 *
 * With the direct3d11 renderer:
 *
 * - `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated
 *   with the renderer
 * - `SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1
 *   associated with the renderer. This may change when the window is resized.
 *
 * With the direct3d12 renderer:
 *
 * - `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated
 *   with the renderer
 * - `SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4
 *   associated with the renderer.
 * - `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue
 *   associated with the renderer
 *
 * With the vulkan renderer:
 *
 * - `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated
 *   with the renderer
 * - `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated
 *   with the renderer
 * - `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice
 *   associated with the renderer
 * - `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with
 *   the renderer
 * - `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue
 *   family index used for rendering
 * - `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue
 *   family index used for presentation
 * - `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of
 *   swapchain images, or potential frames in flight, used by the Vulkan
 *   renderer
 *
 * With the gpu renderer:
 *
 * - `SDL_PROP_RENDERER_GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with
 *   the renderer
 *
 * @param renderer the rendering context.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:459 SDL_PropertiesID SDL_GetRendererProperties(SDL_Renderer *renderer);
 */
  getRendererProperties: lib.symbols.SDL_GetRendererProperties,

/**
 * Get the output size in pixels of a rendering context.
 *
 * This returns the true output size in pixels, ignoring any render targets or
 * logical size and presentation.
 *
 * For the output size of the current rendering target, with logical size
 * adjustments, use SDL_GetCurrentRenderOutputSize() instead.
 *
 * @param renderer the rendering context.
 * @param w a pointer filled in with the width in pixels.
 * @param h a pointer filled in with the height in pixels.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCurrentRenderOutputSize
 *
 * @from SDL_render.h:507 bool SDL_GetRenderOutputSize(SDL_Renderer *renderer, int *w, int *h);
 */
  getRenderOutputSize: lib.symbols.SDL_GetRenderOutputSize,

/**
 * Get the current output size in pixels of a rendering context.
 *
 * If a rendering target is active, this will return the size of the rendering
 * target in pixels, otherwise return the value of SDL_GetRenderOutputSize().
 *
 * Rendering target or not, the output will be adjusted by the current logical
 * presentation state, dictated by SDL_SetRenderLogicalPresentation().
 *
 * @param renderer the rendering context.
 * @param w a pointer filled in with the current width.
 * @param h a pointer filled in with the current height.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderOutputSize
 *
 * @from SDL_render.h:530 bool SDL_GetCurrentRenderOutputSize(SDL_Renderer *renderer, int *w, int *h);
 */
  getCurrentRenderOutputSize: lib.symbols.SDL_GetCurrentRenderOutputSize,

/**
 * Create a texture for a rendering context.
 *
 * The contents of a texture when first created are not defined.
 *
 * @param renderer the rendering context.
 * @param format one of the enumerated values in SDL_PixelFormat.
 * @param access one of the enumerated values in SDL_TextureAccess.
 * @param w the width of the texture in pixels.
 * @param h the height of the texture in pixels.
 * @returns the created texture or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTextureFromSurface
 * @sa SDL_CreateTextureWithProperties
 * @sa SDL_DestroyTexture
 * @sa SDL_GetTextureSize
 * @sa SDL_UpdateTexture
 *
 * @from SDL_render.h:555 SDL_Texture * SDL_CreateTexture(SDL_Renderer *renderer, SDL_PixelFormat format, SDL_TextureAccess access, int w, int h);
 */
  createTexture: lib.symbols.SDL_CreateTexture,

/**
 * Create a texture from an existing surface.
 *
 * The surface is not modified or freed by this function.
 *
 * The SDL_TextureAccess hint for the created texture is
 * `SDL_TEXTUREACCESS_STATIC`.
 *
 * The pixel format of the created texture may be different from the pixel
 * format of the surface, and can be queried using the
 * SDL_PROP_TEXTURE_FORMAT_NUMBER property.
 *
 * @param renderer the rendering context.
 * @param surface the SDL_Surface structure containing pixel data used to fill
 *                the texture.
 * @returns the created texture or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTexture
 * @sa SDL_CreateTextureWithProperties
 * @sa SDL_DestroyTexture
 *
 * @from SDL_render.h:583 SDL_Texture * SDL_CreateTextureFromSurface(SDL_Renderer *renderer, SDL_Surface *surface);
 */
  createTextureFromSurface: lib.symbols.SDL_CreateTextureFromSurface,

/**
 * Create a texture for a rendering context with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_Colorspace value
 *   describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR
 *   for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,
 *   SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for
 *   YUV textures.
 * - `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in
 *   SDL_PixelFormat, defaults to the best RGBA format for the renderer
 * - `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in
 *   SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC
 * - `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in
 *   pixels, required
 * - `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in
 *   pixels, required
 * - `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating
 *   point textures, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 100 for HDR10 textures and 1.0 for floating point textures.
 * - `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating
 *   point textures, this defines the maximum dynamic range used by the
 *   content, in terms of the SDR white point. This would be equivalent to
 *   maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.
 *   If this is defined, any values outside the range supported by the display
 *   will be scaled into the available HDR headroom, otherwise they are
 *   clipped.
 *
 * With the direct3d11 renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the direct3d12 renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the metal renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef
 *   associated with the texture, if you want to create a texture from an
 *   existing pixel buffer.
 *
 * With the opengl renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the opengles2 renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture, if you want to wrap an existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture, if you want to wrap an
 *   existing texture.
 * - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture, if you want to wrap an
 *   existing texture.
 *
 * With the vulkan renderer:
 *
 * - `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout
 *   VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if
 *   you want to wrap an existing texture.
 *
 * @param renderer the rendering context.
 * @param props the properties to use.
 * @returns the created texture or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProperties
 * @sa SDL_CreateTexture
 * @sa SDL_CreateTextureFromSurface
 * @sa SDL_DestroyTexture
 * @sa SDL_GetTextureSize
 * @sa SDL_UpdateTexture
 *
 * @from SDL_render.h:695 SDL_Texture * SDL_CreateTextureWithProperties(SDL_Renderer *renderer, SDL_PropertiesID props);
 */
  createTextureWithProperties: lib.symbols.SDL_CreateTextureWithProperties,

/**
 * Get the properties associated with a texture.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_Colorspace value describing
 *   the texture colorspace.
 * - `SDL_PROP_TEXTURE_FORMAT_NUMBER`: one of the enumerated values in
 *   SDL_PixelFormat.
 * - `SDL_PROP_TEXTURE_ACCESS_NUMBER`: one of the enumerated values in
 *   SDL_TextureAccess.
 * - `SDL_PROP_TEXTURE_WIDTH_NUMBER`: the width of the texture in pixels.
 * - `SDL_PROP_TEXTURE_HEIGHT_NUMBER`: the height of the texture in pixels.
 * - `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
 *   textures, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 100 for HDR10 textures and 1.0 for other textures.
 * - `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point
 *   textures, this defines the maximum dynamic range used by the content, in
 *   terms of the SDR white point. If this is defined, any values outside the
 *   range supported by the display will be scaled into the available HDR
 *   headroom, otherwise they are clipped. This defaults to 1.0 for SDR
 *   textures, 4.0 for HDR10 textures, and no default for floating point
 *   textures.
 *
 * With the direct3d11 renderer:
 *
 * - `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated
 *   with the texture
 * - `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
 *   associated with the U plane of a YUV texture
 * - `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
 *   associated with the V plane of a YUV texture
 *
 * With the direct3d12 renderer:
 *
 * - `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated
 *   with the texture
 * - `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated
 *   with the U plane of a YUV texture
 * - `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated
 *   with the V plane of a YUV texture
 *
 * With the vulkan renderer:
 *
 * - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the
 *   texture
 *
 * With the opengl renderer:
 *
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated
 *   with the texture
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated
 *   with the U plane of a YUV texture
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated
 *   with the V plane of a YUV texture
 * - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the
 *   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)
 * - `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of
 *   the texture (0.0 - 1.0)
 * - `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of
 *   the texture (0.0 - 1.0)
 *
 * With the opengles2 renderer:
 *
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
 *   associated with the texture
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
 *   associated with the UV plane of an NV12 texture
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
 *   associated with the U plane of a YUV texture
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
 *   associated with the V plane of a YUV texture
 * - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the
 *   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)
 *
 * @param texture the texture to query.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:807 SDL_PropertiesID SDL_GetTextureProperties(SDL_Texture *texture);
 */
  getTextureProperties: lib.symbols.SDL_GetTextureProperties,

/**
 * Get the renderer that created an SDL_Texture.
 *
 * @param texture the texture to query.
 * @returns a pointer to the SDL_Renderer that created the texture, or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:847 SDL_Renderer * SDL_GetRendererFromTexture(SDL_Texture *texture);
 */
  getRendererFromTexture: lib.symbols.SDL_GetRendererFromTexture,

/**
 * Get the size of a texture, as floating point values.
 *
 * @param texture the texture to query.
 * @param w a pointer filled in with the width of the texture in pixels. This
 *          argument can be NULL if you don't need this information.
 * @param h a pointer filled in with the height of the texture in pixels. This
 *          argument can be NULL if you don't need this information.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:864 bool SDL_GetTextureSize(SDL_Texture *texture, float *w, float *h);
 */
  getTextureSize: lib.symbols.SDL_GetTextureSize,

/**
 * Set an additional color value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * (color / 255)`
 *
 * Color modulation is not always supported by the renderer; it will return
 * false if color modulation is not supported.
 *
 * @param texture the texture to update.
 * @param r the red color value multiplied into copy operations.
 * @param g the green color value multiplied into copy operations.
 * @param b the blue color value multiplied into copy operations.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureColorMod
 * @sa SDL_SetTextureAlphaMod
 * @sa SDL_SetTextureColorModFloat
 *
 * @from SDL_render.h:893 bool SDL_SetTextureColorMod(SDL_Texture *texture, Uint8 r, Uint8 g, Uint8 b);
 */
  setTextureColorMod: lib.symbols.SDL_SetTextureColorMod,

/**
 * Set an additional color value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * color`
 *
 * Color modulation is not always supported by the renderer; it will return
 * false if color modulation is not supported.
 *
 * @param texture the texture to update.
 * @param r the red color value multiplied into copy operations.
 * @param g the green color value multiplied into copy operations.
 * @param b the blue color value multiplied into copy operations.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureColorModFloat
 * @sa SDL_SetTextureAlphaModFloat
 * @sa SDL_SetTextureColorMod
 *
 * @from SDL_render.h:923 bool SDL_SetTextureColorModFloat(SDL_Texture *texture, float r, float g, float b);
 */
  setTextureColorModFloat: lib.symbols.SDL_SetTextureColorModFloat,

/**
 * Get the additional color value multiplied into render copy operations.
 *
 * @param texture the texture to query.
 * @param r a pointer filled in with the current red color value.
 * @param g a pointer filled in with the current green color value.
 * @param b a pointer filled in with the current blue color value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureAlphaMod
 * @sa SDL_GetTextureColorModFloat
 * @sa SDL_SetTextureColorMod
 *
 * @from SDL_render.h:944 bool SDL_GetTextureColorMod(SDL_Texture *texture, Uint8 *r, Uint8 *g, Uint8 *b);
 */
  getTextureColorMod: lib.symbols.SDL_GetTextureColorMod,

/**
 * Get the additional color value multiplied into render copy operations.
 *
 * @param texture the texture to query.
 * @param r a pointer filled in with the current red color value.
 * @param g a pointer filled in with the current green color value.
 * @param b a pointer filled in with the current blue color value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureAlphaModFloat
 * @sa SDL_GetTextureColorMod
 * @sa SDL_SetTextureColorModFloat
 *
 * @from SDL_render.h:964 bool SDL_GetTextureColorModFloat(SDL_Texture *texture, float *r, float *g, float *b);
 */
  getTextureColorModFloat: lib.symbols.SDL_GetTextureColorModFloat,

/**
 * Set an additional alpha value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * (alpha / 255)`
 *
 * Alpha modulation is not always supported by the renderer; it will return
 * false if alpha modulation is not supported.
 *
 * @param texture the texture to update.
 * @param alpha the source alpha value multiplied into copy operations.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureAlphaMod
 * @sa SDL_SetTextureAlphaModFloat
 * @sa SDL_SetTextureColorMod
 *
 * @from SDL_render.h:990 bool SDL_SetTextureAlphaMod(SDL_Texture *texture, Uint8 alpha);
 */
  setTextureAlphaMod: lib.symbols.SDL_SetTextureAlphaMod,

/**
 * Set an additional alpha value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * alpha`
 *
 * Alpha modulation is not always supported by the renderer; it will return
 * false if alpha modulation is not supported.
 *
 * @param texture the texture to update.
 * @param alpha the source alpha value multiplied into copy operations.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureAlphaModFloat
 * @sa SDL_SetTextureAlphaMod
 * @sa SDL_SetTextureColorModFloat
 *
 * @from SDL_render.h:1016 bool SDL_SetTextureAlphaModFloat(SDL_Texture *texture, float alpha);
 */
  setTextureAlphaModFloat: lib.symbols.SDL_SetTextureAlphaModFloat,

/**
 * Get the additional alpha value multiplied into render copy operations.
 *
 * @param texture the texture to query.
 * @param alpha a pointer filled in with the current alpha value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureAlphaModFloat
 * @sa SDL_GetTextureColorMod
 * @sa SDL_SetTextureAlphaMod
 *
 * @from SDL_render.h:1034 bool SDL_GetTextureAlphaMod(SDL_Texture *texture, Uint8 *alpha);
 */
  getTextureAlphaMod: lib.symbols.SDL_GetTextureAlphaMod,

/**
 * Get the additional alpha value multiplied into render copy operations.
 *
 * @param texture the texture to query.
 * @param alpha a pointer filled in with the current alpha value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureAlphaMod
 * @sa SDL_GetTextureColorModFloat
 * @sa SDL_SetTextureAlphaModFloat
 *
 * @from SDL_render.h:1052 bool SDL_GetTextureAlphaModFloat(SDL_Texture *texture, float *alpha);
 */
  getTextureAlphaModFloat: lib.symbols.SDL_GetTextureAlphaModFloat,

/**
 * Set the blend mode for a texture, used by SDL_RenderTexture().
 *
 * If the blend mode is not supported, the closest supported mode is chosen
 * and this function returns false.
 *
 * @param texture the texture to update.
 * @param blendMode the SDL_BlendMode to use for texture blending.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureBlendMode
 *
 * @from SDL_render.h:1071 bool SDL_SetTextureBlendMode(SDL_Texture *texture, SDL_BlendMode blendMode);
 */
  setTextureBlendMode: lib.symbols.SDL_SetTextureBlendMode,

/**
 * Get the blend mode used for texture copy operations.
 *
 * @param texture the texture to query.
 * @param blendMode a pointer filled in with the current SDL_BlendMode.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetTextureBlendMode
 *
 * @from SDL_render.h:1087 bool SDL_GetTextureBlendMode(SDL_Texture *texture, SDL_BlendMode *blendMode);
 */
  getTextureBlendMode: lib.symbols.SDL_GetTextureBlendMode,

/**
 * Set the scale mode used for texture scale operations.
 *
 * The default texture scale mode is SDL_SCALEMODE_LINEAR.
 *
 * If the scale mode is not supported, the closest supported mode is chosen.
 *
 * @param texture the texture to update.
 * @param scaleMode the SDL_ScaleMode to use for texture scaling.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTextureScaleMode
 *
 * @from SDL_render.h:1107 bool SDL_SetTextureScaleMode(SDL_Texture *texture, SDL_ScaleMode scaleMode);
 */
  setTextureScaleMode: lib.symbols.SDL_SetTextureScaleMode,

/**
 * Get the scale mode used for texture scale operations.
 *
 * @param texture the texture to query.
 * @param scaleMode a pointer filled in with the current scale mode.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetTextureScaleMode
 *
 * @from SDL_render.h:1123 bool SDL_GetTextureScaleMode(SDL_Texture *texture, SDL_ScaleMode *scaleMode);
 */
  getTextureScaleMode: lib.symbols.SDL_GetTextureScaleMode,

/**
 * Update the given texture rectangle with new pixel data.
 *
 * The pixel data must be in the pixel format of the texture, which can be
 * queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.
 *
 * This is a fairly slow function, intended for use with static textures that
 * do not change often.
 *
 * If the texture is intended to be updated often, it is preferred to create
 * the texture as streaming and use the locking functions referenced below.
 * While this function will work with streaming textures, for optimization
 * reasons you may not get the pixels back if you lock the texture afterward.
 *
 * @param texture the texture to update.
 * @param rect an SDL_Rect structure representing the area to update, or NULL
 *             to update the entire texture.
 * @param pixels the raw pixel data in the format of the texture.
 * @param pitch the number of bytes in a row of pixel data, including padding
 *              between lines.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockTexture
 * @sa SDL_UnlockTexture
 * @sa SDL_UpdateNVTexture
 * @sa SDL_UpdateYUVTexture
 *
 * @from SDL_render.h:1157 bool SDL_UpdateTexture(SDL_Texture *texture, const SDL_Rect *rect, const void *pixels, int pitch);
 */
  updateTexture: lib.symbols.SDL_UpdateTexture,

/**
 * Update a rectangle within a planar YV12 or IYUV texture with new pixel
 * data.
 *
 * You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
 * block of Y and U/V planes in the proper order, but this function is
 * available if your pixel data is not contiguous.
 *
 * @param texture the texture to update.
 * @param rect a pointer to the rectangle of pixels to update, or NULL to
 *             update the entire texture.
 * @param Yplane the raw pixel data for the Y plane.
 * @param Ypitch the number of bytes between rows of pixel data for the Y
 *               plane.
 * @param Uplane the raw pixel data for the U plane.
 * @param Upitch the number of bytes between rows of pixel data for the U
 *               plane.
 * @param Vplane the raw pixel data for the V plane.
 * @param Vpitch the number of bytes between rows of pixel data for the V
 *               plane.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UpdateNVTexture
 * @sa SDL_UpdateTexture
 *
 * @from SDL_render.h:1189 bool SDL_UpdateYUVTexture(SDL_Texture *texture,                                                 const SDL_Rect *rect,                                                 const Uint8 *Yplane, int Ypitch,                                                 const Uint8 *Uplane, int Upitch,                                                 const Uint8 *Vplane, int Vpitch);
 */
  updateYuvTexture: lib.symbols.SDL_UpdateYUVTexture,

/**
 * Update a rectangle within a planar NV12 or NV21 texture with new pixels.
 *
 * You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
 * block of NV12/21 planes in the proper order, but this function is available
 * if your pixel data is not contiguous.
 *
 * @param texture the texture to update.
 * @param rect a pointer to the rectangle of pixels to update, or NULL to
 *             update the entire texture.
 * @param Yplane the raw pixel data for the Y plane.
 * @param Ypitch the number of bytes between rows of pixel data for the Y
 *               plane.
 * @param UVplane the raw pixel data for the UV plane.
 * @param UVpitch the number of bytes between rows of pixel data for the UV
 *                plane.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UpdateTexture
 * @sa SDL_UpdateYUVTexture
 *
 * @from SDL_render.h:1221 bool SDL_UpdateNVTexture(SDL_Texture *texture,                                                 const SDL_Rect *rect,                                                 const Uint8 *Yplane, int Ypitch,                                                 const Uint8 *UVplane, int UVpitch);
 */
  updateNvTexture: lib.symbols.SDL_UpdateNVTexture,

/**
 * Lock a portion of the texture for **write-only** pixel access.
 *
 * As an optimization, the pixels made available for editing don't necessarily
 * contain the old texture data. This is a write-only operation, and if you
 * need to keep a copy of the texture data you should do that at the
 * application level.
 *
 * You must use SDL_UnlockTexture() to unlock the pixels and apply any
 * changes.
 *
 * @param texture the texture to lock for access, which was created with
 *                `SDL_TEXTUREACCESS_STREAMING`.
 * @param rect an SDL_Rect structure representing the area to lock for access;
 *             NULL to lock the entire texture.
 * @param pixels this is filled in with a pointer to the locked pixels,
 *               appropriately offset by the locked area.
 * @param pitch this is filled in with the pitch of the locked pixels; the
 *              pitch is the length of one row in bytes.
 * @returns true on success or false if the texture is not valid or was not
 *          created with `SDL_TEXTUREACCESS_STREAMING`; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockTextureToSurface
 * @sa SDL_UnlockTexture
 *
 * @from SDL_render.h:1256 bool SDL_LockTexture(SDL_Texture *texture,                                            const SDL_Rect *rect,                                            void **pixels, int *pitch);
 */
  lockTexture: lib.symbols.SDL_LockTexture,

/**
 * Lock a portion of the texture for **write-only** pixel access, and expose
 * it as a SDL surface.
 *
 * Besides providing an SDL_Surface instead of raw pixel data, this function
 * operates like SDL_LockTexture.
 *
 * As an optimization, the pixels made available for editing don't necessarily
 * contain the old texture data. This is a write-only operation, and if you
 * need to keep a copy of the texture data you should do that at the
 * application level.
 *
 * You must use SDL_UnlockTexture() to unlock the pixels and apply any
 * changes.
 *
 * The returned surface is freed internally after calling SDL_UnlockTexture()
 * or SDL_DestroyTexture(). The caller should not free it.
 *
 * @param texture the texture to lock for access, which must be created with
 *                `SDL_TEXTUREACCESS_STREAMING`.
 * @param rect a pointer to the rectangle to lock for access. If the rect is
 *             NULL, the entire texture will be locked.
 * @param surface a pointer to an SDL surface of size **rect**. Don't assume
 *                any specific pixel content.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockTexture
 * @sa SDL_UnlockTexture
 *
 * @from SDL_render.h:1294 bool SDL_LockTextureToSurface(SDL_Texture *texture, const SDL_Rect *rect, SDL_Surface **surface);
 */
  lockTextureToSurface: lib.symbols.SDL_LockTextureToSurface,

/**
 * Unlock a texture, uploading the changes to video memory, if needed.
 *
 * **Warning**: Please note that SDL_LockTexture() is intended to be
 * write-only; it will not guarantee the previous contents of the texture will
 * be provided. You must fully initialize any area of a texture that you lock
 * before unlocking it, as the pixels might otherwise be uninitialized memory.
 *
 * Which is to say: locking and immediately unlocking a texture can result in
 * corrupted textures, depending on the renderer in use.
 *
 * @param texture a texture locked by SDL_LockTexture().
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockTexture
 *
 * @from SDL_render.h:1315 void SDL_UnlockTexture(SDL_Texture *texture);
 */
  unlockTexture: lib.symbols.SDL_UnlockTexture,

/**
 * Set a texture as the current rendering target.
 *
 * The default render target is the window for which the renderer was created.
 * To stop rendering to a texture and render to the window again, call this
 * function with a NULL `texture`.
 *
 * Viewport, cliprect, scale, and logical presentation are unique to each
 * render target. Get and set functions for these states apply to the current
 * render target set by this function, and those states persist on each target
 * when the current render target changes.
 *
 * @param renderer the rendering context.
 * @param texture the targeted texture, which must be created with the
 *                `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the
 *                window instead of a texture.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderTarget
 *
 * @from SDL_render.h:1342 bool SDL_SetRenderTarget(SDL_Renderer *renderer, SDL_Texture *texture);
 */
  setRenderTarget: lib.symbols.SDL_SetRenderTarget,

/**
 * Get the current render target.
 *
 * The default render target is the window for which the renderer was created,
 * and is reported a NULL here.
 *
 * @param renderer the rendering context.
 * @returns the current render target or NULL for the default render target.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderTarget
 *
 * @from SDL_render.h:1359 SDL_Texture * SDL_GetRenderTarget(SDL_Renderer *renderer);
 */
  getRenderTarget: lib.symbols.SDL_GetRenderTarget,

/**
 * Set a device-independent resolution and presentation mode for rendering.
 *
 * This function sets the width and height of the logical rendering output.
 * The renderer will act as if the current render target is always the
 * requested dimensions, scaling to the actual resolution as necessary.
 *
 * This can be useful for games that expect a fixed size, but would like to
 * scale the output to whatever is available, regardless of how a user resizes
 * a window, or if the display is high DPI.
 *
 * Logical presentation can be used with both render target textures and the
 * renderer's window; the state is unique to each render target, and this
 * function sets the state for the current render target. It might be useful
 * to draw to a texture that matches the window dimensions with logical
 * presentation enabled, and then draw that texture across the entire window
 * with logical presentation disabled. Be careful not to render both with
 * logical presentation enabled, however, as this could produce
 * double-letterboxing, etc.
 *
 * You can disable logical coordinates by setting the mode to
 * SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel
 * resolution of the render target; it is safe to toggle logical presentation
 * during the rendering of a frame: perhaps most of the rendering is done to
 * specific dimensions but to make fonts look sharp, the app turns off logical
 * presentation while drawing text, for example.
 *
 * For the renderer's window, letterboxing is drawn into the framebuffer if
 * logical presentation is enabled during SDL_RenderPresent; be sure to
 * reenable it before presenting if you were toggling it, otherwise the
 * letterbox areas might have artifacts from previous frames (or artifacts
 * from external overlays, etc). Letterboxing is never drawn into texture
 * render targets; be sure to call SDL_RenderClear() before drawing into the
 * texture so the letterboxing areas are cleared, if appropriate.
 *
 * You can convert coordinates in an event into rendering coordinates using
 * SDL_ConvertEventToRenderCoordinates().
 *
 * @param renderer the rendering context.
 * @param w the width of the logical resolution.
 * @param h the height of the logical resolution.
 * @param mode the presentation mode used.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ConvertEventToRenderCoordinates
 * @sa SDL_GetRenderLogicalPresentation
 * @sa SDL_GetRenderLogicalPresentationRect
 *
 * @from SDL_render.h:1414 bool SDL_SetRenderLogicalPresentation(SDL_Renderer *renderer, int w, int h, SDL_RendererLogicalPresentation mode);
 */
  setRenderLogicalPresentation: lib.symbols.SDL_SetRenderLogicalPresentation,

/**
 * Get device independent resolution and presentation mode for rendering.
 *
 * This function gets the width and height of the logical rendering output, or
 * the output size in pixels if a logical resolution is not enabled.
 *
 * Each render target has its own logical presentation state. This function
 * gets the state for the current render target.
 *
 * @param renderer the rendering context.
 * @param w an int to be filled with the width.
 * @param h an int to be filled with the height.
 * @param mode the presentation mode used.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderLogicalPresentation
 *
 * @from SDL_render.h:1438 bool SDL_GetRenderLogicalPresentation(SDL_Renderer *renderer, int *w, int *h, SDL_RendererLogicalPresentation *mode);
 */
  getRenderLogicalPresentation: lib.symbols.SDL_GetRenderLogicalPresentation,

/**
 * Get the final presentation rectangle for rendering.
 *
 * This function returns the calculated rectangle used for logical
 * presentation, based on the presentation mode and output size. If logical
 * presentation is disabled, it will fill the rectangle with the output size,
 * in pixels.
 *
 * Each render target has its own logical presentation state. This function
 * gets the rectangle for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect a pointer filled in with the final presentation rectangle, may
 *             be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderLogicalPresentation
 *
 * @from SDL_render.h:1463 bool SDL_GetRenderLogicalPresentationRect(SDL_Renderer *renderer, SDL_FRect *rect);
 */
  getRenderLogicalPresentationRect: lib.symbols.SDL_GetRenderLogicalPresentationRect,

/**
 * Get a point in render coordinates when given a point in window coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 * - The scale (SDL_SetRenderScale)
 * - The viewport (SDL_SetRenderViewport)
 *
 * @param renderer the rendering context.
 * @param window_x the x coordinate in window coordinates.
 * @param window_y the y coordinate in window coordinates.
 * @param x a pointer filled with the x coordinate in render coordinates.
 * @param y a pointer filled with the y coordinate in render coordinates.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderLogicalPresentation
 * @sa SDL_SetRenderScale
 *
 * @from SDL_render.h:1490 bool SDL_RenderCoordinatesFromWindow(SDL_Renderer *renderer, float window_x, float window_y, float *x, float *y);
 */
  renderCoordinatesFromWindow: lib.symbols.SDL_RenderCoordinatesFromWindow,

/**
 * Get a point in window coordinates when given a point in render coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 * - The scale (SDL_SetRenderScale)
 * - The viewport (SDL_SetRenderViewport)
 *
 * @param renderer the rendering context.
 * @param x the x coordinate in render coordinates.
 * @param y the y coordinate in render coordinates.
 * @param window_x a pointer filled with the x coordinate in window
 *                 coordinates.
 * @param window_y a pointer filled with the y coordinate in window
 *                 coordinates.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderLogicalPresentation
 * @sa SDL_SetRenderScale
 * @sa SDL_SetRenderViewport
 *
 * @from SDL_render.h:1520 bool SDL_RenderCoordinatesToWindow(SDL_Renderer *renderer, float x, float y, float *window_x, float *window_y);
 */
  renderCoordinatesToWindow: lib.symbols.SDL_RenderCoordinatesToWindow,

/**
 * Convert the coordinates in an event to render coordinates.
 *
 * This takes into account several states:
 *
 * - The window dimensions.
 * - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 * - The scale (SDL_SetRenderScale)
 * - The viewport (SDL_SetRenderViewport)
 *
 * Various event types are converted with this function: mouse, touch, pen,
 * etc.
 *
 * Touch coordinates are converted from normalized coordinates in the window
 * to non-normalized rendering coordinates.
 *
 * Relative mouse coordinates (xrel and yrel event fields) are _also_
 * converted. Applications that do not want these fields converted should use
 * SDL_RenderCoordinatesFromWindow() on the specific event fields instead of
 * converting the entire event structure.
 *
 * Once converted, coordinates may be outside the rendering area.
 *
 * @param renderer the rendering context.
 * @param event the event to modify.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderCoordinatesFromWindow
 *
 * @from SDL_render.h:1556 bool SDL_ConvertEventToRenderCoordinates(SDL_Renderer *renderer, SDL_Event *event);
 */
  convertEventToRenderCoordinates: lib.symbols.SDL_ConvertEventToRenderCoordinates,

/**
 * Set the drawing area for rendering on the current target.
 *
 * Drawing will clip to this area (separately from any clipping done with
 * SDL_SetRenderClipRect), and the top left of the area will become coordinate
 * (0, 0) for future drawing commands.
 *
 * The area's width and height must be >= 0.
 *
 * Each render target has its own viewport. This function sets the viewport
 * for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect the SDL_Rect structure representing the drawing area, or NULL
 *             to set the viewport to the entire target.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderViewport
 * @sa SDL_RenderViewportSet
 *
 * @from SDL_render.h:1583 bool SDL_SetRenderViewport(SDL_Renderer *renderer, const SDL_Rect *rect);
 */
  setRenderViewport: lib.symbols.SDL_SetRenderViewport,

/**
 * Get the drawing area for the current target.
 *
 * Each render target has its own viewport. This function gets the viewport
 * for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect an SDL_Rect structure filled in with the current drawing area.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderViewportSet
 * @sa SDL_SetRenderViewport
 *
 * @from SDL_render.h:1603 bool SDL_GetRenderViewport(SDL_Renderer *renderer, SDL_Rect *rect);
 */
  getRenderViewport: lib.symbols.SDL_GetRenderViewport,

/**
 * Return whether an explicit rectangle was set as the viewport.
 *
 * This is useful if you're saving and restoring the viewport and want to know
 * whether you should restore a specific rectangle or NULL. Note that the
 * viewport is always reset when changing rendering targets.
 *
 * Each render target has its own viewport. This function checks the viewport
 * for the current render target.
 *
 * @param renderer the rendering context.
 * @returns true if the viewport was set to a specific rectangle, or false if
 *          it was set to NULL (the entire target).
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderViewport
 * @sa SDL_SetRenderViewport
 *
 * @from SDL_render.h:1626 bool SDL_RenderViewportSet(SDL_Renderer *renderer);
 */
  renderViewportSet: lib.symbols.SDL_RenderViewportSet,

/**
 * Get the safe area for rendering within the current viewport.
 *
 * Some devices have portions of the screen which are partially obscured or
 * not interactive, possibly due to on-screen controls, curved edges, camera
 * notches, TV overscan, etc. This function provides the area of the current
 * viewport which is safe to have interactible content. You should continue
 * rendering into the rest of the render target, but it should not contain
 * visually important or interactible content.
 *
 * @param renderer the rendering context.
 * @param rect a pointer filled in with the area that is safe for interactive
 *             content.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:1648 bool SDL_GetRenderSafeArea(SDL_Renderer *renderer, SDL_Rect *rect);
 */
  getRenderSafeArea: lib.symbols.SDL_GetRenderSafeArea,

/**
 * Set the clip rectangle for rendering on the specified target.
 *
 * Each render target has its own clip rectangle. This function sets the
 * cliprect for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect an SDL_Rect structure representing the clip area, relative to
 *             the viewport, or NULL to disable clipping.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderClipRect
 * @sa SDL_RenderClipEnabled
 *
 * @from SDL_render.h:1669 bool SDL_SetRenderClipRect(SDL_Renderer *renderer, const SDL_Rect *rect);
 */
  setRenderClipRect: lib.symbols.SDL_SetRenderClipRect,

/**
 * Get the clip rectangle for the current target.
 *
 * Each render target has its own clip rectangle. This function gets the
 * cliprect for the current render target.
 *
 * @param renderer the rendering context.
 * @param rect an SDL_Rect structure filled in with the current clipping area
 *             or an empty rectangle if clipping is disabled.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderClipEnabled
 * @sa SDL_SetRenderClipRect
 *
 * @from SDL_render.h:1690 bool SDL_GetRenderClipRect(SDL_Renderer *renderer, SDL_Rect *rect);
 */
  getRenderClipRect: lib.symbols.SDL_GetRenderClipRect,

/**
 * Get whether clipping is enabled on the given render target.
 *
 * Each render target has its own clip rectangle. This function checks the
 * cliprect for the current render target.
 *
 * @param renderer the rendering context.
 * @returns true if clipping is enabled or false if not; call SDL_GetError()
 *          for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderClipRect
 * @sa SDL_SetRenderClipRect
 *
 * @from SDL_render.h:1709 bool SDL_RenderClipEnabled(SDL_Renderer *renderer);
 */
  renderClipEnabled: lib.symbols.SDL_RenderClipEnabled,

/**
 * Set the drawing scale for rendering on the current target.
 *
 * The drawing coordinates are scaled by the x/y scaling factors before they
 * are used by the renderer. This allows resolution independent drawing with a
 * single coordinate system.
 *
 * If this results in scaling or subpixel drawing by the rendering backend, it
 * will be handled using the appropriate quality hints. For best results use
 * integer scaling factors.
 *
 * Each render target has its own scale. This function sets the scale for the
 * current render target.
 *
 * @param renderer the rendering context.
 * @param scaleX the horizontal scaling factor.
 * @param scaleY the vertical scaling factor.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderScale
 *
 * @from SDL_render.h:1737 bool SDL_SetRenderScale(SDL_Renderer *renderer, float scaleX, float scaleY);
 */
  setRenderScale: lib.symbols.SDL_SetRenderScale,

/**
 * Get the drawing scale for the current target.
 *
 * Each render target has its own scale. This function gets the scale for the
 * current render target.
 *
 * @param renderer the rendering context.
 * @param scaleX a pointer filled in with the horizontal scaling factor.
 * @param scaleY a pointer filled in with the vertical scaling factor.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderScale
 *
 * @from SDL_render.h:1757 bool SDL_GetRenderScale(SDL_Renderer *renderer, float *scaleX, float *scaleY);
 */
  getRenderScale: lib.symbols.SDL_GetRenderScale,

/**
 * Set the color used for drawing operations.
 *
 * Set the color for drawing or filling rectangles, lines, and points, and for
 * SDL_RenderClear().
 *
 * @param renderer the rendering context.
 * @param r the red value used to draw on the rendering target.
 * @param g the green value used to draw on the rendering target.
 * @param b the blue value used to draw on the rendering target.
 * @param a the alpha value used to draw on the rendering target; usually
 *          `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to
 *          specify how the alpha channel is used.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderDrawColor
 * @sa SDL_SetRenderDrawColorFloat
 *
 * @from SDL_render.h:1782 bool SDL_SetRenderDrawColor(SDL_Renderer *renderer, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
 */
  setRenderDrawColor: lib.symbols.SDL_SetRenderDrawColor,

/**
 * Set the color used for drawing operations (Rect, Line and Clear).
 *
 * Set the color for drawing or filling rectangles, lines, and points, and for
 * SDL_RenderClear().
 *
 * @param renderer the rendering context.
 * @param r the red value used to draw on the rendering target.
 * @param g the green value used to draw on the rendering target.
 * @param b the blue value used to draw on the rendering target.
 * @param a the alpha value used to draw on the rendering target. Use
 *          SDL_SetRenderDrawBlendMode to specify how the alpha channel is
 *          used.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderDrawColorFloat
 * @sa SDL_SetRenderDrawColor
 *
 * @from SDL_render.h:1807 bool SDL_SetRenderDrawColorFloat(SDL_Renderer *renderer, float r, float g, float b, float a);
 */
  setRenderDrawColorFloat: lib.symbols.SDL_SetRenderDrawColorFloat,

/**
 * Get the color used for drawing operations (Rect, Line and Clear).
 *
 * @param renderer the rendering context.
 * @param r a pointer filled in with the red value used to draw on the
 *          rendering target.
 * @param g a pointer filled in with the green value used to draw on the
 *          rendering target.
 * @param b a pointer filled in with the blue value used to draw on the
 *          rendering target.
 * @param a a pointer filled in with the alpha value used to draw on the
 *          rendering target; usually `SDL_ALPHA_OPAQUE` (255).
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderDrawColorFloat
 * @sa SDL_SetRenderDrawColor
 *
 * @from SDL_render.h:1831 bool SDL_GetRenderDrawColor(SDL_Renderer *renderer, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
 */
  getRenderDrawColor: lib.symbols.SDL_GetRenderDrawColor,

/**
 * Get the color used for drawing operations (Rect, Line and Clear).
 *
 * @param renderer the rendering context.
 * @param r a pointer filled in with the red value used to draw on the
 *          rendering target.
 * @param g a pointer filled in with the green value used to draw on the
 *          rendering target.
 * @param b a pointer filled in with the blue value used to draw on the
 *          rendering target.
 * @param a a pointer filled in with the alpha value used to draw on the
 *          rendering target.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderDrawColorFloat
 * @sa SDL_GetRenderDrawColor
 *
 * @from SDL_render.h:1855 bool SDL_GetRenderDrawColorFloat(SDL_Renderer *renderer, float *r, float *g, float *b, float *a);
 */
  getRenderDrawColorFloat: lib.symbols.SDL_GetRenderDrawColorFloat,

/**
 * Set the color scale used for render operations.
 *
 * The color scale is an additional scale multiplied into the pixel color
 * value while rendering. This can be used to adjust the brightness of colors
 * during HDR rendering, or changing HDR video brightness when playing on an
 * SDR display.
 *
 * The color scale does not affect the alpha channel, only the color
 * brightness.
 *
 * @param renderer the rendering context.
 * @param scale the color scale value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderColorScale
 *
 * @from SDL_render.h:1879 bool SDL_SetRenderColorScale(SDL_Renderer *renderer, float scale);
 */
  setRenderColorScale: lib.symbols.SDL_SetRenderColorScale,

/**
 * Get the color scale used for render operations.
 *
 * @param renderer the rendering context.
 * @param scale a pointer filled in with the current color scale value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderColorScale
 *
 * @from SDL_render.h:1895 bool SDL_GetRenderColorScale(SDL_Renderer *renderer, float *scale);
 */
  getRenderColorScale: lib.symbols.SDL_GetRenderColorScale,

/**
 * Set the blend mode used for drawing operations (Fill and Line).
 *
 * If the blend mode is not supported, the closest supported mode is chosen.
 *
 * @param renderer the rendering context.
 * @param blendMode the SDL_BlendMode to use for blending.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderDrawBlendMode
 *
 * @from SDL_render.h:1913 bool SDL_SetRenderDrawBlendMode(SDL_Renderer *renderer, SDL_BlendMode blendMode);
 */
  setRenderDrawBlendMode: lib.symbols.SDL_SetRenderDrawBlendMode,

/**
 * Get the blend mode used for drawing operations.
 *
 * @param renderer the rendering context.
 * @param blendMode a pointer filled in with the current SDL_BlendMode.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderDrawBlendMode
 *
 * @from SDL_render.h:1929 bool SDL_GetRenderDrawBlendMode(SDL_Renderer *renderer, SDL_BlendMode *blendMode);
 */
  getRenderDrawBlendMode: lib.symbols.SDL_GetRenderDrawBlendMode,

/**
 * Clear the current rendering target with the drawing color.
 *
 * This function clears the entire rendering target, ignoring the viewport and
 * the clip rectangle. Note, that clearing will also set/fill all pixels of
 * the rendering target to current renderer draw color, so make sure to invoke
 * SDL_SetRenderDrawColor() when needed.
 *
 * @param renderer the rendering context.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderDrawColor
 *
 * @from SDL_render.h:1949 bool SDL_RenderClear(SDL_Renderer *renderer);
 */
  renderClear: lib.symbols.SDL_RenderClear,

/**
 * Draw a point on the current rendering target at subpixel precision.
 *
 * @param renderer the renderer which should draw a point.
 * @param x the x coordinate of the point.
 * @param y the y coordinate of the point.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderPoints
 *
 * @from SDL_render.h:1966 bool SDL_RenderPoint(SDL_Renderer *renderer, float x, float y);
 */
  renderPoint: lib.symbols.SDL_RenderPoint,

/**
 * Draw multiple points on the current rendering target at subpixel precision.
 *
 * @param renderer the renderer which should draw multiple points.
 * @param points the points to draw.
 * @param count the number of points to draw.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderPoint
 *
 * @from SDL_render.h:1983 bool SDL_RenderPoints(SDL_Renderer *renderer, const SDL_FPoint *points, int count);
 */
  renderPoints: lib.symbols.SDL_RenderPoints,

/**
 * Draw a line on the current rendering target at subpixel precision.
 *
 * @param renderer the renderer which should draw a line.
 * @param x1 the x coordinate of the start point.
 * @param y1 the y coordinate of the start point.
 * @param x2 the x coordinate of the end point.
 * @param y2 the y coordinate of the end point.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderLines
 *
 * @from SDL_render.h:2002 bool SDL_RenderLine(SDL_Renderer *renderer, float x1, float y1, float x2, float y2);
 */
  renderLine: lib.symbols.SDL_RenderLine,

/**
 * Draw a series of connected lines on the current rendering target at
 * subpixel precision.
 *
 * @param renderer the renderer which should draw multiple lines.
 * @param points the points along the lines.
 * @param count the number of points, drawing count-1 lines.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderLine
 *
 * @from SDL_render.h:2020 bool SDL_RenderLines(SDL_Renderer *renderer, const SDL_FPoint *points, int count);
 */
  renderLines: lib.symbols.SDL_RenderLines,

/**
 * Draw a rectangle on the current rendering target at subpixel precision.
 *
 * @param renderer the renderer which should draw a rectangle.
 * @param rect a pointer to the destination rectangle, or NULL to outline the
 *             entire rendering target.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderRects
 *
 * @from SDL_render.h:2037 bool SDL_RenderRect(SDL_Renderer *renderer, const SDL_FRect *rect);
 */
  renderRect: lib.symbols.SDL_RenderRect,

/**
 * Draw some number of rectangles on the current rendering target at subpixel
 * precision.
 *
 * @param renderer the renderer which should draw multiple rectangles.
 * @param rects a pointer to an array of destination rectangles.
 * @param count the number of rectangles.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderRect
 *
 * @from SDL_render.h:2055 bool SDL_RenderRects(SDL_Renderer *renderer, const SDL_FRect *rects, int count);
 */
  renderRects: lib.symbols.SDL_RenderRects,

/**
 * Fill a rectangle on the current rendering target with the drawing color at
 * subpixel precision.
 *
 * @param renderer the renderer which should fill a rectangle.
 * @param rect a pointer to the destination rectangle, or NULL for the entire
 *             rendering target.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderFillRects
 *
 * @from SDL_render.h:2073 bool SDL_RenderFillRect(SDL_Renderer *renderer, const SDL_FRect *rect);
 */
  renderFillRect: lib.symbols.SDL_RenderFillRect,

/**
 * Fill some number of rectangles on the current rendering target with the
 * drawing color at subpixel precision.
 *
 * @param renderer the renderer which should fill multiple rectangles.
 * @param rects a pointer to an array of destination rectangles.
 * @param count the number of rectangles.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderFillRect
 *
 * @from SDL_render.h:2091 bool SDL_RenderFillRects(SDL_Renderer *renderer, const SDL_FRect *rects, int count);
 */
  renderFillRects: lib.symbols.SDL_RenderFillRects,

/**
 * Copy a portion of the texture to the current rendering target at subpixel
 * precision.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect a pointer to the source rectangle, or NULL for the entire
 *                texture.
 * @param dstrect a pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderTextureRotated
 * @sa SDL_RenderTextureTiled
 *
 * @from SDL_render.h:2113 bool SDL_RenderTexture(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_FRect *srcrect, const SDL_FRect *dstrect);
 */
  renderTexture: lib.symbols.SDL_RenderTexture,

/**
 * Copy a portion of the source texture to the current rendering target, with
 * rotation and flipping, at subpixel precision.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect a pointer to the source rectangle, or NULL for the entire
 *                texture.
 * @param dstrect a pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * @param angle an angle in degrees that indicates the rotation that will be
 *              applied to dstrect, rotating it in a clockwise direction.
 * @param center a pointer to a point indicating the point around which
 *               dstrect will be rotated (if NULL, rotation will be done
 *               around dstrect.w/2, dstrect.h/2).
 * @param flip an SDL_FlipMode value stating which flipping actions should be
 *             performed on the texture.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderTexture
 *
 * @from SDL_render.h:2141 bool SDL_RenderTextureRotated(SDL_Renderer *renderer, SDL_Texture *texture,                                                     const SDL_FRect *srcrect, const SDL_FRect *dstrect,                                                     double angle, const SDL_FPoint *center,                                                     SDL_FlipMode flip);
 */
  renderTextureRotated: lib.symbols.SDL_RenderTextureRotated,

/**
 * Copy a portion of the source texture to the current rendering target, with
 * affine transform, at subpixel precision.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect a pointer to the source rectangle, or NULL for the entire
 *                texture.
 * @param origin a pointer to a point indicating where the top-left corner of
 *               srcrect should be mapped to, or NULL for the rendering
 *               target's origin.
 * @param right a pointer to a point indicating where the top-right corner of
 *              srcrect should be mapped to, or NULL for the rendering
 *              target's top-right corner.
 * @param down a pointer to a point indicating where the bottom-left corner of
 *             srcrect should be mapped to, or NULL for the rendering target's
 *             bottom-left corner.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety You may only call this function from the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderTexture
 *
 * @from SDL_render.h:2172 bool SDL_RenderTextureAffine(SDL_Renderer *renderer, SDL_Texture *texture,                                                     const SDL_FRect *srcrect, const SDL_FPoint *origin,                                                     const SDL_FPoint *right, const SDL_FPoint *down);
 */
  renderTextureAffine: lib.symbols.SDL_RenderTextureAffine,

/**
 * Tile a portion of the texture to the current rendering target at subpixel
 * precision.
 *
 * The pixels in `srcrect` will be repeated as many times as needed to
 * completely fill `dstrect`.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect a pointer to the source rectangle, or NULL for the entire
 *                texture.
 * @param scale the scale used to transform srcrect into the destination
 *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
 *              64x64 tiles.
 * @param dstrect a pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderTexture
 *
 * @from SDL_render.h:2201 bool SDL_RenderTextureTiled(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_FRect *srcrect, float scale, const SDL_FRect *dstrect);
 */
  renderTextureTiled: lib.symbols.SDL_RenderTextureTiled,

/**
 * Perform a scaled copy using the 9-grid algorithm to the current rendering
 * target at subpixel precision.
 *
 * The pixels in the texture are split into a 3x3 grid, using the different
 * corner sizes for each corner, and the sides and center making up the
 * remaining pixels. The corners are then scaled using `scale` and fit into
 * the corners of the destination rectangle. The sides and center are then
 * stretched into place to cover the remaining destination rectangle.
 *
 * @param renderer the renderer which should copy parts of a texture.
 * @param texture the source texture.
 * @param srcrect the SDL_Rect structure representing the rectangle to be used
 *                for the 9-grid, or NULL to use the entire texture.
 * @param left_width the width, in pixels, of the left corners in `srcrect`.
 * @param right_width the width, in pixels, of the right corners in `srcrect`.
 * @param top_height the height, in pixels, of the top corners in `srcrect`.
 * @param bottom_height the height, in pixels, of the bottom corners in
 *                      `srcrect`.
 * @param scale the scale used to transform the corner of `srcrect` into the
 *              corner of `dstrect`, or 0.0f for an unscaled copy.
 * @param dstrect a pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderTexture
 *
 * @from SDL_render.h:2235 bool SDL_RenderTexture9Grid(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_FRect *srcrect, float left_width, float right_width, float top_height, float bottom_height, float scale, const SDL_FRect *dstrect);
 */
  renderTexture9Grid: lib.symbols.SDL_RenderTexture9Grid,

/**
 * Render a list of triangles, optionally using a texture and indices into the
 * vertex array Color and alpha modulation is done per vertex
 * (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
 *
 * @param renderer the rendering context.
 * @param texture (optional) The SDL texture to use.
 * @param vertices vertices.
 * @param num_vertices number of vertices.
 * @param indices (optional) An array of integer indices into the 'vertices'
 *                array, if NULL all vertices will be rendered in sequential
 *                order.
 * @param num_indices number of indices.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderGeometryRaw
 *
 * @from SDL_render.h:2259 bool SDL_RenderGeometry(SDL_Renderer *renderer,                                               SDL_Texture *texture,                                               const SDL_Vertex *vertices, int num_vertices,                                               const int *indices, int num_indices);
 */
  renderGeometry: lib.symbols.SDL_RenderGeometry,

/**
 * Render a list of triangles, optionally using a texture and indices into the
 * vertex arrays Color and alpha modulation is done per vertex
 * (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
 *
 * @param renderer the rendering context.
 * @param texture (optional) The SDL texture to use.
 * @param xy vertex positions.
 * @param xy_stride byte size to move from one element to the next element.
 * @param color vertex colors (as SDL_FColor).
 * @param color_stride byte size to move from one element to the next element.
 * @param uv vertex normalized texture coordinates.
 * @param uv_stride byte size to move from one element to the next element.
 * @param num_vertices number of vertices.
 * @param indices (optional) An array of indices into the 'vertices' arrays,
 *                if NULL all vertices will be rendered in sequential order.
 * @param num_indices number of indices.
 * @param size_indices index size: 1 (byte), 2 (short), 4 (int).
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderGeometry
 *
 * @from SDL_render.h:2291 bool SDL_RenderGeometryRaw(SDL_Renderer *renderer,                                               SDL_Texture *texture,                                               const float *xy, int xy_stride,                                               const SDL_FColor *color, int color_stride,                                               const float *uv, int uv_stride,                                               int num_vertices,                                               const void *indices, int num_indices, int size_indices);
 */
  renderGeometryRaw: lib.symbols.SDL_RenderGeometryRaw,

/**
 * Read pixels from the current rendering target.
 *
 * The returned surface contains pixels inside the desired area clipped to the
 * current viewport, and should be freed with SDL_DestroySurface().
 *
 * Note that this returns the actual pixels on the screen, so if you are using
 * logical presentation you should use SDL_GetRenderLogicalPresentationRect()
 * to get the area containing your content.
 *
 * **WARNING**: This is a very slow operation, and should not be used
 * frequently. If you're using this on the main rendering target, it should be
 * called after rendering and before SDL_RenderPresent().
 *
 * @param renderer the rendering context.
 * @param rect an SDL_Rect structure representing the area to read, which will
 *             be clipped to the current viewport, or NULL for the entire
 *             viewport.
 * @returns a new SDL_Surface on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:2324 SDL_Surface * SDL_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect);
 */
  renderReadPixels: lib.symbols.SDL_RenderReadPixels,

/**
 * Update the screen with any rendering performed since the previous call.
 *
 * SDL's rendering functions operate on a backbuffer; that is, calling a
 * rendering function such as SDL_RenderLine() does not directly put a line on
 * the screen, but rather updates the backbuffer. As such, you compose your
 * entire scene and *present* the composed backbuffer to the screen as a
 * complete picture.
 *
 * Therefore, when using SDL's rendering API, one does all drawing intended
 * for the frame, and then calls this function once per frame to present the
 * final drawing to the user.
 *
 * The backbuffer should be considered invalidated after each present; do not
 * assume that previous contents will exist between frames. You are strongly
 * encouraged to call SDL_RenderClear() to initialize the backbuffer before
 * starting each new frame's drawing, even if you plan to overwrite every
 * pixel.
 *
 * Please note, that in case of rendering to a texture - there is **no need**
 * to call `SDL_RenderPresent` after drawing needed objects to a texture, and
 * should not be done; you are only required to change back the rendering
 * target to default via `SDL_SetRenderTarget(renderer, NULL)` afterwards, as
 * textures by themselves do not have a concept of backbuffers. Calling
 * SDL_RenderPresent while rendering to a texture will still update the screen
 * with any current drawing that has been done _to the window itself_.
 *
 * @param renderer the rendering context.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateRenderer
 * @sa SDL_RenderClear
 * @sa SDL_RenderFillRect
 * @sa SDL_RenderFillRects
 * @sa SDL_RenderLine
 * @sa SDL_RenderLines
 * @sa SDL_RenderPoint
 * @sa SDL_RenderPoints
 * @sa SDL_RenderRect
 * @sa SDL_RenderRects
 * @sa SDL_SetRenderDrawBlendMode
 * @sa SDL_SetRenderDrawColor
 *
 * @from SDL_render.h:2374 bool SDL_RenderPresent(SDL_Renderer *renderer);
 */
  renderPresent: lib.symbols.SDL_RenderPresent,

/**
 * Destroy the specified texture.
 *
 * Passing NULL or an otherwise invalid texture will set the SDL error message
 * to "Invalid texture".
 *
 * @param texture the texture to destroy.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTexture
 * @sa SDL_CreateTextureFromSurface
 *
 * @from SDL_render.h:2391 void SDL_DestroyTexture(SDL_Texture *texture);
 */
  destroyTexture: lib.symbols.SDL_DestroyTexture,

/**
 * Destroy the rendering context for a window and free all associated
 * textures.
 *
 * This should be called before destroying the associated window.
 *
 * @param renderer the rendering context.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateRenderer
 *
 * @from SDL_render.h:2407 void SDL_DestroyRenderer(SDL_Renderer *renderer);
 */
  destroyRenderer: lib.symbols.SDL_DestroyRenderer,

/**
 * Force the rendering context to flush any pending commands and state.
 *
 * You do not need to (and in fact, shouldn't) call this function unless you
 * are planning to call into OpenGL/Direct3D/Metal/whatever directly, in
 * addition to using an SDL_Renderer.
 *
 * This is for a very-specific case: if you are using SDL's render API, and
 * you plan to make OpenGL/D3D/whatever calls in addition to SDL render API
 * calls. If this applies, you should call this function between calls to
 * SDL's render API and the low-level API you're using in cooperation.
 *
 * In all other cases, you can ignore this function.
 *
 * This call makes SDL flush any pending rendering work it was queueing up to
 * do later in a single batch, and marks any internal cached state as invalid,
 * so it'll prepare all its state again later, from scratch.
 *
 * This means you do not need to save state in your rendering code to protect
 * the SDL renderer. However, there lots of arbitrary pieces of Direct3D and
 * OpenGL state that can confuse things; you should use your best judgment and
 * be prepared to make changes if specific state needs to be protected.
 *
 * @param renderer the rendering context.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:2440 bool SDL_FlushRenderer(SDL_Renderer *renderer);
 */
  flushRenderer: lib.symbols.SDL_FlushRenderer,

/**
 * Get the CAMetalLayer associated with the given Metal renderer.
 *
 * This function returns `void *`, so SDL doesn't have to include Metal's
 * headers, but it can be safely cast to a `CAMetalLayer *`.
 *
 * @param renderer the renderer to query.
 * @returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a
 *          Metal renderer.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderMetalCommandEncoder
 *
 * @from SDL_render.h:2458 void * SDL_GetRenderMetalLayer(SDL_Renderer *renderer);
 */
  getRenderMetalLayer: lib.symbols.SDL_GetRenderMetalLayer,

/**
 * Get the Metal command encoder for the current frame.
 *
 * This function returns `void *`, so SDL doesn't have to include Metal's
 * headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.
 *
 * This will return NULL if Metal refuses to give SDL a drawable to render to,
 * which might happen if the window is hidden/minimized/offscreen. This
 * doesn't apply to command encoders for render targets, just the window's
 * backbuffer. Check your return values!
 *
 * @param renderer the renderer to query.
 * @returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the
 *          renderer isn't a Metal renderer or there was an error.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderMetalLayer
 *
 * @from SDL_render.h:2481 void * SDL_GetRenderMetalCommandEncoder(SDL_Renderer *renderer);
 */
  getRenderMetalCommandEncoder: lib.symbols.SDL_GetRenderMetalCommandEncoder,

/**
 * Add a set of synchronization semaphores for the current frame.
 *
 * The Vulkan renderer will wait for `wait_semaphore` before submitting
 * rendering commands and signal `signal_semaphore` after rendering commands
 * are complete for this frame.
 *
 * This should be called each frame that you want semaphore synchronization.
 * The Vulkan renderer may have multiple frames in flight on the GPU, so you
 * should have multiple semaphores that are used for synchronization. Querying
 * SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the
 * maximum number of semaphores you'll need.
 *
 * @param renderer the rendering context.
 * @param wait_stage_mask the VkPipelineStageFlags for the wait.
 * @param wait_semaphore a VkSempahore to wait on before rendering the current
 *                       frame, or 0 if not needed.
 * @param signal_semaphore a VkSempahore that SDL will signal when rendering
 *                         for the current frame is complete, or 0 if not
 *                         needed.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is **NOT** safe to call this function from two threads at
 *               once.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_render.h:2512 bool SDL_AddVulkanRenderSemaphores(SDL_Renderer *renderer, Uint32 wait_stage_mask, Sint64 wait_semaphore, Sint64 signal_semaphore);
 */
  addVulkanRenderSemaphores: lib.symbols.SDL_AddVulkanRenderSemaphores,

/**
 * Toggle VSync of the given renderer.
 *
 * When a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.
 *
 * The `vsync` parameter can be 1 to synchronize present with every vertical
 * refresh, 2 to synchronize present with every second vertical refresh, etc.,
 * SDL_RENDERER_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync), or
 * SDL_RENDERER_VSYNC_DISABLED to disable. Not every value is supported by
 * every driver, so you should check the return value to see whether the
 * requested setting is supported.
 *
 * @param renderer the renderer to toggle.
 * @param vsync the vertical refresh sync interval.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderVSync
 *
 * @from SDL_render.h:2537 bool SDL_SetRenderVSync(SDL_Renderer *renderer, int vsync);
 */
  setRenderVSync: lib.symbols.SDL_SetRenderVSync,

/**
 * Get VSync of the given renderer.
 *
 * @param renderer the renderer to toggle.
 * @param vsync an int filled with the current vertical refresh sync interval.
 *              See SDL_SetRenderVSync() for the meaning of the value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetRenderVSync
 *
 * @from SDL_render.h:2557 bool SDL_GetRenderVSync(SDL_Renderer *renderer, int *vsync);
 */
  getRenderVSync: lib.symbols.SDL_GetRenderVSync,

/**
 * Draw debug text to an SDL_Renderer.
 *
 * This function will render a string of text to an SDL_Renderer. Note that
 * this is a convenience function for debugging, with severe limitations, and
 * not intended to be used for production apps and games.
 *
 * Among these limitations:
 *
 * - It accepts UTF-8 strings, but will only renders ASCII characters.
 * - It has a single, tiny size (8x8 pixels). One can use logical presentation
 *   or scaling to adjust it, but it will be blurry.
 * - It uses a simple, hardcoded bitmap font. It does not allow different font
 *   selections and it does not support truetype, for proper scaling.
 * - It does no word-wrapping and does not treat newline characters as a line
 *   break. If the text goes out of the window, it's gone.
 *
 * For serious text rendering, there are several good options, such as
 * SDL_ttf, stb_truetype, or other external libraries.
 *
 * On first use, this will create an internal texture for rendering glyphs.
 * This texture will live until the renderer is destroyed.
 *
 * The text is drawn in the color specified by SDL_SetRenderDrawColor().
 *
 * @param renderer the renderer which should draw a line of text.
 * @param x the x coordinate where the top-left corner of the text will draw.
 * @param y the y coordinate where the top-left corner of the text will draw.
 * @param str the string to render.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RenderDebugTextFormat
 * @sa SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE
 *
 * @from SDL_render.h:2609 bool SDL_RenderDebugText(SDL_Renderer *renderer, float x, float y, const char *str);
 */
  renderDebugText: lib.symbols.SDL_RenderDebugText,



/*--- SDL_scancode ---*/

/**
 * The SDL keyboard scancode representation.
 *
 * An SDL scancode is the physical representation of a key on the keyboard,
 * independent of language and keyboard mapping.
 *
 * Values of this type are used to represent keyboard keys, among other places
 * in the `scancode` field of the SDL_KeyboardEvent structure.
 *
 * The values in this enumeration are based on the USB usage page standard:
 * https://usb.org/sites/default/files/hut1_5.pdf
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_scancode.h:51 SDL_SCANCODE_
 */
  SCANCODE: SDL_scancode_enums.SDL_Scancode,





/*--- SDL_sensor ---*/

/**
 * The different sensors defined by SDL.
 *
 * Additional sensors may be available, using platform dependent semantics.
 *
 * Here are the additional Android sensors:
 *
 * https://developer.android.com/reference/android/hardware/SensorEvent.html#values
 *
 * Accelerometer sensor notes:
 *
 * The accelerometer returns the current acceleration in SI meters per second
 * squared. This measurement includes the force of gravity, so a device at
 * rest will have an value of SDL_STANDARD_GRAVITY away from the center of the
 * earth, which is a positive Y value.
 *
 * - `values[0]`: Acceleration on the x axis
 * - `values[1]`: Acceleration on the y axis
 * - `values[2]`: Acceleration on the z axis
 *
 * For phones and tablets held in natural orientation and game controllers
 * held in front of you, the axes are defined as follows:
 *
 * - -X ... +X : left ... right
 * - -Y ... +Y : bottom ... top
 * - -Z ... +Z : farther ... closer
 *
 * The accelerometer axis data is not changed when the device is rotated.
 *
 * Gyroscope sensor notes:
 *
 * The gyroscope returns the current rate of rotation in radians per second.
 * The rotation is positive in the counter-clockwise direction. That is, an
 * observer looking from a positive location on one of the axes would see
 * positive rotation on that axis when it appeared to be rotating
 * counter-clockwise.
 *
 * - `values[0]`: Angular speed around the x axis (pitch)
 * - `values[1]`: Angular speed around the y axis (yaw)
 * - `values[2]`: Angular speed around the z axis (roll)
 *
 * For phones and tablets held in natural orientation and game controllers
 * held in front of you, the axes are defined as follows:
 *
 * - -X ... +X : left ... right
 * - -Y ... +Y : bottom ... top
 * - -Z ... +Z : farther ... closer
 *
 * The gyroscope axis data is not changed when the device is rotated.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_GetCurrentDisplayOrientation
 *
 * @from SDL_sensor.h:131 SDL_SENSOR_
 */
  SENSOR: SDL_sensor_enums.SDL_SensorType,



/**
 * Get a list of currently connected sensors.
 *
 * @param count a pointer filled in with the number of sensors returned, may
 *              be NULL.
 * @returns a 0 terminated array of sensor instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:157 SDL_SensorID * SDL_GetSensors(int *count);
 */
  getSensors: lib.symbols.SDL_GetSensors,

/**
 * Get the implementation dependent name of a sensor.
 *
 * This can be called before any sensors are opened.
 *
 * @param instance_id the sensor instance ID.
 * @returns the sensor name, or NULL if `instance_id` is not valid.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:169 const char * SDL_GetSensorNameForID(SDL_SensorID instance_id);
 */
  getSensorNameForId: lib.symbols.SDL_GetSensorNameForID,

/**
 * Get the type of a sensor.
 *
 * This can be called before any sensors are opened.
 *
 * @param instance_id the sensor instance ID.
 * @returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `instance_id` is
 *          not valid.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:182 SDL_SensorType SDL_GetSensorTypeForID(SDL_SensorID instance_id);
 */
  getSensorTypeForId: lib.symbols.SDL_GetSensorTypeForID,

/**
 * Get the platform dependent type of a sensor.
 *
 * This can be called before any sensors are opened.
 *
 * @param instance_id the sensor instance ID.
 * @returns the sensor platform dependent type, or -1 if `instance_id` is not
 *          valid.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:195 int SDL_GetSensorNonPortableTypeForID(SDL_SensorID instance_id);
 */
  getSensorNonPortableTypeForId: lib.symbols.SDL_GetSensorNonPortableTypeForID,

/**
 * Open a sensor for use.
 *
 * @param instance_id the sensor instance ID.
 * @returns an SDL_Sensor object or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:206 SDL_Sensor * SDL_OpenSensor(SDL_SensorID instance_id);
 */
  openSensor: lib.symbols.SDL_OpenSensor,

/**
 * Return the SDL_Sensor associated with an instance ID.
 *
 * @param instance_id the sensor instance ID.
 * @returns an SDL_Sensor object or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:217 SDL_Sensor * SDL_GetSensorFromID(SDL_SensorID instance_id);
 */
  getSensorFromId: lib.symbols.SDL_GetSensorFromID,

/**
 * Get the properties associated with a sensor.
 *
 * @param sensor the SDL_Sensor object.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:228 SDL_PropertiesID SDL_GetSensorProperties(SDL_Sensor *sensor);
 */
  getSensorProperties: lib.symbols.SDL_GetSensorProperties,

/**
 * Get the implementation dependent name of a sensor.
 *
 * @param sensor the SDL_Sensor object.
 * @returns the sensor name or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:239 const char * SDL_GetSensorName(SDL_Sensor *sensor);
 */
  getSensorName: lib.symbols.SDL_GetSensorName,

/**
 * Get the type of a sensor.
 *
 * @param sensor the SDL_Sensor object to inspect.
 * @returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is
 *          NULL.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:250 SDL_SensorType SDL_GetSensorType(SDL_Sensor *sensor);
 */
  getSensorType: lib.symbols.SDL_GetSensorType,

/**
 * Get the platform dependent type of a sensor.
 *
 * @param sensor the SDL_Sensor object to inspect.
 * @returns the sensor platform dependent type, or -1 if `sensor` is NULL.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:260 int SDL_GetSensorNonPortableType(SDL_Sensor *sensor);
 */
  getSensorNonPortableType: lib.symbols.SDL_GetSensorNonPortableType,

/**
 * Get the instance ID of a sensor.
 *
 * @param sensor the SDL_Sensor object to inspect.
 * @returns the sensor instance ID, or 0 on failure; call SDL_GetError() for
 *          more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:271 SDL_SensorID SDL_GetSensorID(SDL_Sensor *sensor);
 */
  getSensorId: lib.symbols.SDL_GetSensorID,

/**
 * Get the current state of an opened sensor.
 *
 * The number of values and interpretation of the data is sensor dependent.
 *
 * @param sensor the SDL_Sensor object to query.
 * @param data a pointer filled with the current sensor state.
 * @param num_values the number of values to write to data.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:286 bool SDL_GetSensorData(SDL_Sensor *sensor, float *data, int num_values);
 */
  getSensorData: lib.symbols.SDL_GetSensorData,

/**
 * Close a sensor previously opened with SDL_OpenSensor().
 *
 * @param sensor the SDL_Sensor object to close.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:295 void SDL_CloseSensor(SDL_Sensor *sensor);
 */
  closeSensor: lib.symbols.SDL_CloseSensor,

/**
 * Update the current state of the open sensors.
 *
 * This is called automatically by the event loop if sensor events are
 * enabled.
 *
 * This needs to be called from the thread that initialized the sensor
 * subsystem.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_sensor.h:308 void SDL_UpdateSensors(void);
 */
  updateSensors: lib.symbols.SDL_UpdateSensors,



/*--- SDL_stdinc ---*/

/* TODO: include/SDL_stdinc.h:390: error: size of array 'SDL_dummy_enum' is negative */
  DUMMY_ENUM: SDL_stdinc_enums.SDL_DUMMY_ENUM,



/**
 * Get the original set of SDL memory functions.
 *
 * This is what SDL_malloc and friends will use by default, if there has been
 * no call to SDL_SetMemoryFunctions. This is not necessarily using the C
 * runtime's `malloc` functions behind the scenes! Different platforms and
 * build configurations might do any number of unexpected things.
 *
 * @param malloc_func filled with malloc function.
 * @param calloc_func filled with calloc function.
 * @param realloc_func filled with realloc function.
 * @param free_func filled with free function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:1502 void SDL_GetOriginalMemoryFunctions(SDL_malloc_func *malloc_func,                                                            SDL_calloc_func *calloc_func,                                                            SDL_realloc_func *realloc_func,                                                            SDL_free_func *free_func);
 */
  getOriginalMemoryFunctions: lib.symbols.SDL_GetOriginalMemoryFunctions,

/**
 * Get the current set of SDL memory functions.
 *
 * @param malloc_func filled with malloc function.
 * @param calloc_func filled with calloc function.
 * @param realloc_func filled with realloc function.
 * @param free_func filled with free function.
 *
 * @threadsafety This does not hold a lock, so do not call this in the
 *               unlikely event of a background thread calling
 *               SDL_SetMemoryFunctions simultaneously.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetMemoryFunctions
 * @sa SDL_GetOriginalMemoryFunctions
 *
 * @from SDL_stdinc.h:1524 void SDL_GetMemoryFunctions(SDL_malloc_func *malloc_func,                                                    SDL_calloc_func *calloc_func,                                                    SDL_realloc_func *realloc_func,                                                    SDL_free_func *free_func);
 */
  getMemoryFunctions: lib.symbols.SDL_GetMemoryFunctions,

/**
 * Replace SDL's memory allocation functions with a custom set.
 *
 * It is not safe to call this function once any allocations have been made,
 * as future calls to SDL_free will use the new allocator, even if they came
 * from an SDL_malloc made with the old one!
 *
 * If used, usually this needs to be the first call made into the SDL library,
 * if not the very first thing done at program startup time.
 *
 * @param malloc_func custom malloc function.
 * @param calloc_func custom calloc function.
 * @param realloc_func custom realloc function.
 * @param free_func custom free function.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread, but one
 *               should not replace the memory functions once any allocations
 *               are made!
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetMemoryFunctions
 * @sa SDL_GetOriginalMemoryFunctions
 *
 * @from SDL_stdinc.h:1555 bool SDL_SetMemoryFunctions(SDL_malloc_func malloc_func,                                                            SDL_calloc_func calloc_func,                                                            SDL_realloc_func realloc_func,                                                            SDL_free_func free_func);
 */
  setMemoryFunctions: lib.symbols.SDL_SetMemoryFunctions,

/**
 * Allocate memory aligned to a specific alignment.
 *
 * The memory returned by this function must be freed with SDL_aligned_free(),
 * _not_ SDL_free().
 *
 * If `alignment` is less than the size of `void *`, it will be increased to
 * match that.
 *
 * The returned memory address will be a multiple of the alignment value, and
 * the size of the memory allocated will be a multiple of the alignment value.
 *
 * @param alignment the alignment of the memory.
 * @param size the size to allocate.
 * @returns a pointer to the aligned memory, or NULL if allocation failed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_aligned_free
 *
 * @from SDL_stdinc.h:1582 SDL_MALLOC void * SDL_aligned_alloc(size_t alignment, size_t size);
 */
  alignedAlloc: lib.symbols.SDL_aligned_alloc,

/**
 * Free memory allocated by SDL_aligned_alloc().
 *
 * The pointer is no longer valid after this call and cannot be dereferenced
 * anymore.
 *
 * If `mem` is NULL, this function does nothing.
 *
 * @param mem a pointer previously returned by SDL_aligned_alloc(), or NULL.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_aligned_alloc
 *
 * @from SDL_stdinc.h:1600 void SDL_aligned_free(void *mem);
 */
  alignedFree: lib.symbols.SDL_aligned_free,

/**
 * Get the number of outstanding (unfreed) allocations.
 *
 * @returns the number of allocations or -1 if allocation counting is
 *          disabled.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:1612 int SDL_GetNumAllocations(void);
 */
  getNumAllocations: lib.symbols.SDL_GetNumAllocations,

/**
 * Get the process environment.
 *
 * This is initialized at application start and is not affected by setenv()
 * and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and
 * SDL_UnsetEnvironmentVariable() if you want to modify this environment, or
 * SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist
 * in the C runtime environment after SDL_Quit().
 *
 * @returns a pointer to the environment for the process or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetEnvironmentVariable
 * @sa SDL_GetEnvironmentVariables
 * @sa SDL_SetEnvironmentVariable
 * @sa SDL_UnsetEnvironmentVariable
 *
 * @from SDL_stdinc.h:1650 SDL_Environment * SDL_GetEnvironment(void);
 */
  getEnvironment: lib.symbols.SDL_GetEnvironment,

/**
 * Create a set of environment variables
 *
 * @param populated true to initialize it from the C runtime environment,
 *                  false to create an empty environment.
 * @returns a pointer to the new environment or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety If `populated` is false, it is safe to call this function
 *               from any thread, otherwise it is safe if no other threads are
 *               calling setenv() or unsetenv()
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetEnvironmentVariable
 * @sa SDL_GetEnvironmentVariables
 * @sa SDL_SetEnvironmentVariable
 * @sa SDL_UnsetEnvironmentVariable
 * @sa SDL_DestroyEnvironment
 *
 * @from SDL_stdinc.h:1672 SDL_Environment * SDL_CreateEnvironment(bool populated);
 */
  createEnvironment: lib.symbols.SDL_CreateEnvironment,

/**
 * Get the value of a variable in the environment.
 *
 * @param env the environment to query.
 * @param name the name of the variable to get.
 * @returns a pointer to the value of the variable or NULL if it can't be
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetEnvironment
 * @sa SDL_CreateEnvironment
 * @sa SDL_GetEnvironmentVariables
 * @sa SDL_SetEnvironmentVariable
 * @sa SDL_UnsetEnvironmentVariable
 *
 * @from SDL_stdinc.h:1692 const char * SDL_GetEnvironmentVariable(SDL_Environment *env, const char *name);
 */
  getEnvironmentVariable: lib.symbols.SDL_GetEnvironmentVariable,

/**
 * Get all variables in the environment.
 *
 * @param env the environment to query.
 * @returns a NULL terminated array of pointers to environment variables in
 *          the form "variable=value" or NULL on failure; call SDL_GetError()
 *          for more information. This is a single allocation that should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetEnvironment
 * @sa SDL_CreateEnvironment
 * @sa SDL_GetEnvironmentVariables
 * @sa SDL_SetEnvironmentVariable
 * @sa SDL_UnsetEnvironmentVariable
 *
 * @from SDL_stdinc.h:1713 char ** SDL_GetEnvironmentVariables(SDL_Environment *env);
 */
  getEnvironmentVariables: lib.symbols.SDL_GetEnvironmentVariables,

/**
 * Set the value of a variable in the environment.
 *
 * @param env the environment to modify.
 * @param name the name of the variable to set.
 * @param value the value of the variable to set.
 * @param overwrite true to overwrite the variable if it exists, false to
 *                  return success without setting the variable if it already
 *                  exists.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetEnvironment
 * @sa SDL_CreateEnvironment
 * @sa SDL_GetEnvironmentVariable
 * @sa SDL_GetEnvironmentVariables
 * @sa SDL_UnsetEnvironmentVariable
 *
 * @from SDL_stdinc.h:1737 bool SDL_SetEnvironmentVariable(SDL_Environment *env, const char *name, const char *value, bool overwrite);
 */
  setEnvironmentVariable: lib.symbols.SDL_SetEnvironmentVariable,

/**
 * Clear a variable from the environment.
 *
 * @param env the environment to modify.
 * @param name the name of the variable to unset.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetEnvironment
 * @sa SDL_CreateEnvironment
 * @sa SDL_GetEnvironmentVariable
 * @sa SDL_GetEnvironmentVariables
 * @sa SDL_SetEnvironmentVariable
 * @sa SDL_UnsetEnvironmentVariable
 *
 * @from SDL_stdinc.h:1758 bool SDL_UnsetEnvironmentVariable(SDL_Environment *env, const char *name);
 */
  unsetEnvironmentVariable: lib.symbols.SDL_UnsetEnvironmentVariable,

/**
 * Destroy a set of environment variables.
 *
 * @param env the environment to destroy.
 *
 * @threadsafety It is safe to call this function from any thread, as long as
 *               the environment is no longer in use.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateEnvironment
 *
 * @from SDL_stdinc.h:1772 void SDL_DestroyEnvironment(SDL_Environment *env);
 */
  destroyEnvironment: lib.symbols.SDL_DestroyEnvironment,

/**
 * Get the value of a variable in the environment.
 *
 * This function uses SDL's cached copy of the environment and is thread-safe.
 *
 * @param name the name of the variable to get.
 * @returns a pointer to the value of the variable or NULL if it can't be
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:1787 const char * SDL_getenv(const char *name);
 */
  getenv: lib.symbols.SDL_getenv,

/**
 * Get the value of a variable in the environment.
 *
 * This function bypasses SDL's cached copy of the environment and is not
 * thread-safe.
 *
 * @param name the name of the variable to get.
 * @returns a pointer to the value of the variable or NULL if it can't be
 *          found.
 *
 * @threadsafety This function is not thread safe, consider using SDL_getenv()
 *               instead.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_getenv
 *
 * @from SDL_stdinc.h:1806 const char * SDL_getenv_unsafe(const char *name);
 */
  getenvUnsafe: lib.symbols.SDL_getenv_unsafe,

/**
 * Set the value of a variable in the environment.
 *
 * @param name the name of the variable to set.
 * @param value the value of the variable to set.
 * @param overwrite 1 to overwrite the variable if it exists, 0 to return
 *                  success without setting the variable if it already exists.
 * @returns 0 on success, -1 on error.
 *
 * @threadsafety This function is not thread safe, consider using
 *               SDL_SetEnvironmentVariable() instead.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetEnvironmentVariable
 *
 * @from SDL_stdinc.h:1824 int SDL_setenv_unsafe(const char *name, const char *value, int overwrite);
 */
  setenvUnsafe: lib.symbols.SDL_setenv_unsafe,

/**
 * Clear a variable from the environment.
 *
 * @param name the name of the variable to unset.
 * @returns 0 on success, -1 on error.
 *
 * @threadsafety This function is not thread safe, consider using
 *               SDL_UnsetEnvironmentVariable() instead.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_UnsetEnvironmentVariable
 *
 * @from SDL_stdinc.h:1839 int SDL_unsetenv_unsafe(const char *name);
 */
  unsetenvUnsafe: lib.symbols.SDL_unsetenv_unsafe,

/**
 * Sort an array.
 *
 * For example:
 *
 * ```c
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *a, const void *b)
 * {
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->n < B->n) {
 *         return -1;
 *     } else if (B->n < A->n) {
 *         return 1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 3, "third" }, { 1, "first" }, { 2, "second" }
 * };
 *
 * SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);
 * ```
 *
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_bsearch
 * @sa SDL_qsort_r
 *
 * @from SDL_stdinc.h:1901 void SDL_qsort(void *base, size_t nmemb, size_t size, SDL_CompareCallback compare);
 */
  qsort: lib.symbols.SDL_qsort,

/**
 * Perform a binary search on a previously sorted array.
 *
 * For example:
 *
 * ```c
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *a, const void *b)
 * {
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->n < B->n) {
 *         return -1;
 *     } else if (B->n < A->n) {
 *         return 1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 1, "first" }, { 2, "second" }, { 3, "third" }
 * };
 * data key = { 2, NULL };
 *
 * data *result = SDL_bsearch(&key, values, SDL_arraysize(values), sizeof(values[0]), compare);
 * ```
 *
 * @param key a pointer to a key equal to the element being searched for.
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 * @returns a pointer to the matching element in the array, or NULL if not
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_bsearch_r
 * @sa SDL_qsort
 *
 * @from SDL_stdinc.h:1951 void * SDL_bsearch(const void *key, const void *base, size_t nmemb, size_t size, SDL_CompareCallback compare);
 */
  bsearch: lib.symbols.SDL_bsearch,

/**
 * Sort an array, passing a userdata pointer to the compare function.
 *
 * For example:
 *
 * ```c
 * typedef enum {
 *     sort_increasing,
 *     sort_decreasing,
 * } sort_method;
 *
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *userdata, const void *a, const void *b)
 * {
 *     sort_method method = (sort_method)(uintptr_t)userdata;
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->key < B->key) {
 *         return (method == sort_increasing) ? -1 : 1;
 *     } else if (B->key < A->key) {
 *         return (method == sort_increasing) ? 1 : -1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 3, "third" }, { 1, "first" }, { 2, "second" }
 * };
 *
 * SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);
 * ```
 *
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 * @param userdata a pointer to pass to the compare function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_bsearch_r
 * @sa SDL_qsort
 *
 * @from SDL_stdinc.h:2021 void SDL_qsort_r(void *base, size_t nmemb, size_t size, SDL_CompareCallback_r compare, void *userdata);
 */
  qsortR: lib.symbols.SDL_qsort_r,

/**
 * Perform a binary search on a previously sorted array, passing a userdata
 * pointer to the compare function.
 *
 * For example:
 *
 * ```c
 * typedef enum {
 *     sort_increasing,
 *     sort_decreasing,
 * } sort_method;
 *
 * typedef struct {
 *     int key;
 *     const char *string;
 * } data;
 *
 * int SDLCALL compare(const void *userdata, const void *a, const void *b)
 * {
 *     sort_method method = (sort_method)(uintptr_t)userdata;
 *     const data *A = (const data *)a;
 *     const data *B = (const data *)b;
 *
 *     if (A->key < B->key) {
 *         return (method == sort_increasing) ? -1 : 1;
 *     } else if (B->key < A->key) {
 *         return (method == sort_increasing) ? 1 : -1;
 *     } else {
 *         return 0;
 *     }
 * }
 *
 * data values[] = {
 *     { 1, "first" }, { 2, "second" }, { 3, "third" }
 * };
 * data key = { 2, NULL };
 *
 * data *result = SDL_bsearch_r(&key, values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);
 * ```
 *
 * @param key a pointer to a key equal to the element being searched for.
 * @param base a pointer to the start of the array.
 * @param nmemb the number of elements in the array.
 * @param size the size of the elements in the array.
 * @param compare a function used to compare elements in the array.
 * @param userdata a pointer to pass to the compare function.
 * @returns a pointer to the matching element in the array, or NULL if not
 *          found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_bsearch
 * @sa SDL_qsort_r
 *
 * @from SDL_stdinc.h:2079 void * SDL_bsearch_r(const void *key, const void *base, size_t nmemb, size_t size, SDL_CompareCallback_r compare, void *userdata);
 */
  bsearchR: lib.symbols.SDL_bsearch_r,

/**
 * Compute the absolute value of `x`.
 *
 * @param x an integer value.
 * @returns the absolute value of x.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2091 int SDL_abs(int x);
 */
  abs: lib.symbols.SDL_abs,

/**
 * Query if a character is alphabetic (a letter).
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * for English 'a-z' and 'A-Z' as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2166 int SDL_isalpha(int x);
 */
  isalpha: lib.symbols.SDL_isalpha,

/**
 * Query if a character is alphabetic (a letter) or a number.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * for English 'a-z', 'A-Z', and '0-9' as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2181 int SDL_isalnum(int x);
 */
  isalnum: lib.symbols.SDL_isalnum,

/**
 * Report if a character is blank (a space or tab).
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 0x20 (space) or 0x9 (tab) as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2196 int SDL_isblank(int x);
 */
  isblank: lib.symbols.SDL_isblank,

/**
 * Report if a character is a control character.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 0 through 0x1F, and 0x7F, as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2211 int SDL_iscntrl(int x);
 */
  iscntrl: lib.symbols.SDL_iscntrl,

/**
 * Report if a character is a numeric digit.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * '0' (0x30) through '9' (0x39), as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2226 int SDL_isdigit(int x);
 */
  isdigit: lib.symbols.SDL_isdigit,

/**
 * Report if a character is a hexadecimal digit.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'A' through 'F', 'a' through 'f', and '0' through '9', as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2241 int SDL_isxdigit(int x);
 */
  isxdigit: lib.symbols.SDL_isxdigit,

/**
 * Report if a character is a punctuation mark.
 *
 * **WARNING**: Regardless of system locale, this is equivalent to
 * `((SDL_isgraph(x)) && (!SDL_isalnum(x)))`.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_isgraph
 * @sa SDL_isalnum
 *
 * @from SDL_stdinc.h:2259 int SDL_ispunct(int x);
 */
  ispunct: lib.symbols.SDL_ispunct,

/**
 * Report if a character is whitespace.
 *
 * **WARNING**: Regardless of system locale, this will only treat the
 * following ASCII values as true:
 *
 * - space (0x20)
 * - tab (0x09)
 * - newline (0x0A)
 * - vertical tab (0x0B)
 * - form feed (0x0C)
 * - return (0x0D)
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2281 int SDL_isspace(int x);
 */
  isspace: lib.symbols.SDL_isspace,

/**
 * Report if a character is upper case.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'A' through 'Z' as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2296 int SDL_isupper(int x);
 */
  isupper: lib.symbols.SDL_isupper,

/**
 * Report if a character is lower case.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * 'a' through 'z' as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2311 int SDL_islower(int x);
 */
  islower: lib.symbols.SDL_islower,

/**
 * Report if a character is "printable".
 *
 * Be advised that "printable" has a definition that goes back to text
 * terminals from the dawn of computing, making this a sort of special case
 * function that is not suitable for Unicode (or most any) text management.
 *
 * **WARNING**: Regardless of system locale, this will only treat ASCII values
 * ' ' (0x20) through '~' (0x7E) as true.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2330 int SDL_isprint(int x);
 */
  isprint: lib.symbols.SDL_isprint,

/**
 * Report if a character is any "printable" except space.
 *
 * Be advised that "printable" has a definition that goes back to text
 * terminals from the dawn of computing, making this a sort of special case
 * function that is not suitable for Unicode (or most any) text management.
 *
 * **WARNING**: Regardless of system locale, this is equivalent to
 * `(SDL_isprint(x)) && ((x) != ' ')`.
 *
 * @param x character value to check.
 * @returns non-zero if x falls within the character class, zero otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_isprint
 *
 * @from SDL_stdinc.h:2351 int SDL_isgraph(int x);
 */
  isgraph: lib.symbols.SDL_isgraph,

/**
 * Convert low-ASCII English letters to uppercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'a' through 'z' to uppercase.
 *
 * This function returns the uppercase equivalent of `x`. If a character
 * cannot be converted, or is already uppercase, this function returns `x`.
 *
 * @param x character value to check.
 * @returns capitalized version of x, or x if no conversion available.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2369 int SDL_toupper(int x);
 */
  toupper: lib.symbols.SDL_toupper,

/**
 * Convert low-ASCII English letters to lowercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to lowercase.
 *
 * This function returns the lowercase equivalent of `x`. If a character
 * cannot be converted, or is already lowercase, this function returns `x`.
 *
 * @param x character value to check.
 * @returns lowercase version of x, or x if no conversion available.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2387 int SDL_tolower(int x);
 */
  tolower: lib.symbols.SDL_tolower,

/**
 * Calculate a CRC-16 value.
 *
 * https://en.wikipedia.org/wiki/Cyclic_redundancy_check
 *
 * This function can be called multiple times, to stream data to be
 * checksummed in blocks. Each call must provide the previous CRC-16 return
 * value to be updated with the next block. The first call to this function
 * for a set of blocks should pass in a zero CRC value.
 *
 * @param crc the current checksum for this data set, or 0 for a new data set.
 * @param data a new block of data to add to the checksum.
 * @param len the size, in bytes, of the new block of data.
 * @returns a CRC-16 checksum value of all blocks in the data set.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2408 Uint16 SDL_crc16(Uint16 crc, const void *data, size_t len);
 */
  crc16: lib.symbols.SDL_crc16,

/**
 * Calculate a CRC-32 value.
 *
 * https://en.wikipedia.org/wiki/Cyclic_redundancy_check
 *
 * This function can be called multiple times, to stream data to be
 * checksummed in blocks. Each call must provide the previous CRC-32 return
 * value to be updated with the next block. The first call to this function
 * for a set of blocks should pass in a zero CRC value.
 *
 * @param crc the current checksum for this data set, or 0 for a new data set.
 * @param data a new block of data to add to the checksum.
 * @param len the size, in bytes, of the new block of data.
 * @returns a CRC-32 checksum value of all blocks in the data set.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2429 Uint32 SDL_crc32(Uint32 crc, const void *data, size_t len);
 */
  crc32: lib.symbols.SDL_crc32,

/**
 * Calculate a 32-bit MurmurHash3 value for a block of data.
 *
 * https://en.wikipedia.org/wiki/MurmurHash
 *
 * A seed may be specified, which changes the final results consistently, but
 * this does not work like SDL_crc16 and SDL_crc32: you can't feed a previous
 * result from this function back into itself as the next seed value to
 * calculate a hash in chunks; it won't produce the same hash as it would if
 * the same data was provided in a single call.
 *
 * If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not
 * cryptographically secure, so it shouldn't be used for hashing top-secret
 * data.
 *
 * @param data the data to be hashed.
 * @param len the size of data, in bytes.
 * @param seed a value that alters the final hash value.
 * @returns a Murmur3 32-bit hash value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2455 Uint32 SDL_murmur3_32(const void *data, size_t len, Uint32 seed);
 */
  murmur332: lib.symbols.SDL_murmur3_32,

/**
 * Initialize all 32-bit words of buffer of memory to a specific value.
 *
 * This function will set a buffer of `dwords` Uint32 values, pointed to by
 * `dst`, to the value specified in `val`.
 *
 * Unlike SDL_memset, this sets 32-bit values, not bytes, so it's not limited
 * to a range of 0-255.
 *
 * @param dst the destination memory region. Must not be NULL.
 * @param val the Uint32 value to set.
 * @param dwords the number of Uint32 values to set in `dst`.
 * @returns `dst`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2579 void * SDL_memset4(void *dst, Uint32 val, size_t dwords);
 */
  memset4: lib.symbols.SDL_memset4,

/**
 * This works exactly like wcsnlen() but doesn't require access to a C
 * runtime.
 *
 * Counts up to a maximum of `maxlen` wchar_t values in `wstr`, excluding the
 * null terminator.
 *
 * Like SDL_strnlen only counts bytes and not codepoints in a UTF-8 string,
 * this counts wchar_t values in a string, even if the string's encoding is of
 * variable width, like UTF-16.
 *
 * Also be aware that wchar_t is different sizes on different platforms (4
 * bytes on Linux, 2 on Windows, etc).
 *
 * Also, `maxlen` is a count of wide characters, not bytes!
 *
 * @param wstr The null-terminated wide string to read. Must not be NULL.
 * @param maxlen The maximum amount of wide characters to count.
 * @returns the length (in wide characters, excluding the null terminator) of
 *          `wstr` but never more than `maxlen`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_wcslen
 * @sa SDL_utf8strlen
 * @sa SDL_utf8strnlen
 *
 * @from SDL_stdinc.h:2719 size_t SDL_wcsnlen(const wchar_t *wstr, size_t maxlen);
 */
  wcsnlen: lib.symbols.SDL_wcsnlen,

/**
 * Search a wide string, up to n wide chars, for the first instance of a
 * specific substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * value to end the string, or `maxlen` wide character have been examined. It
 * is possible to use this function on a wide string without a null
 * terminator.
 *
 * Note that this looks for strings of _wide characters_, not _codepoints_, so
 * it's legal to search for malformed and incomplete UTF-16 sequences.
 *
 * @param haystack the wide string to search. Must not be NULL.
 * @param needle the wide string to search for. Must not be NULL.
 * @param maxlen the maximum number of wide characters to search in
 *               `haystack`.
 * @returns a pointer to the first instance of `needle` in the string, or NULL
 *          if not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2838 wchar_t * SDL_wcsnstr(const wchar_t *haystack, const wchar_t *needle, size_t maxlen);
 */
  wcsnstr: lib.symbols.SDL_wcsnstr,

/**
 * Compare two null-terminated wide strings, case-insensitively.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Depending on your platform, "wchar_t" might be 2 bytes, and expected to be
 * UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this
 * handles Unicode, it expects the string to be well-formed and not a
 * null-terminated string of arbitrary bytes. Characters that are not valid
 * UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * @param str1 the first string to compare. NULL is not permitted!
 * @param str2 the second string to compare. NULL is not permitted!
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2918 int SDL_wcscasecmp(const wchar_t *str1, const wchar_t *str2);
 */
  wcscasecmp: lib.symbols.SDL_wcscasecmp,

/**
 * Compare two wide strings, case-insensitively, up to a number of wchar_t.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Depending on your platform, "wchar_t" might be 2 bytes, and expected to be
 * UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this
 * handles Unicode, it expects the string to be well-formed and not a
 * null-terminated string of arbitrary bytes. Characters that are not valid
 * UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * Note that while this function might deal with variable-sized characters,
 * `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a
 * multi-byte UTF-16 sequence, it may convert a portion of the final character
 * to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not
 * to overflow a buffer.
 *
 * `maxlen` specifies a maximum number of wchar_t values to compare; if the
 * strings match to this number of wchar_t (or both have matched to a
 * null-terminator character before this number of bytes), they will be
 * considered equal.
 *
 * @param str1 the first string to compare. NULL is not permitted!
 * @param str2 the second string to compare. NULL is not permitted!
 * @param maxlen the maximum number of wchar_t values to compare.
 * @returns less than zero if str1 is "less than" str2, greater than zero if
 *          str1 is "greater than" str2, and zero if the strings match
 *          exactly.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:2960 int SDL_wcsncasecmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen);
 */
  wcsncasecmp: lib.symbols.SDL_wcsncasecmp,

/**
 * Parse a `long` from a wide string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside a `long`, the result is clamped to
 * the minimum and maximum representable `long` values.
 *
 * @param str The null-terminated wide string to read. Must not be NULL.
 * @param endp If not NULL, the address of the first invalid wide character
 *             (i.e. the next character after the parsed number) will be
 *             written to this pointer.
 * @param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * @returns the parsed `long`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_strtol
 *
 * @from SDL_stdinc.h:2987 long SDL_wcstol(const wchar_t *str, wchar_t **endp, int base);
 */
  wcstol: lib.symbols.SDL_wcstol,

/**
 * This works exactly like strnlen() but doesn't require access to a C
 * runtime.
 *
 * Counts up to a maximum of `maxlen` bytes in `str`, excluding the null
 * terminator.
 *
 * If you need the length of a UTF-8 string, consider using SDL_utf8strnlen().
 *
 * @param str The null-terminated string to read. Must not be NULL.
 * @param maxlen The maximum amount of bytes to count.
 * @returns the length (in bytes, excluding the null terminator) of `src` but
 *          never more than `maxlen`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_strlen
 * @sa SDL_utf8strlen
 * @sa SDL_utf8strnlen
 *
 * @from SDL_stdinc.h:3031 size_t SDL_strnlen(const char *str, size_t maxlen);
 */
  strnlen: lib.symbols.SDL_strnlen,

/**
 * Copy an UTF-8 string.
 *
 * This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while
 * also ensuring that the string written to `dst` does not end in a truncated
 * multi-byte sequence. Finally, it appends a null terminator.
 *
 * `src` and `dst` must not overlap.
 *
 * Note that unlike SDL_strlcpy(), this function returns the number of bytes
 * written, not the length of `src`.
 *
 * @param dst The destination buffer. Must not be NULL, and must not overlap
 *            with `src`.
 * @param src The null-terminated UTF-8 string to copy. Must not be NULL, and
 *            must not overlap with `dst`.
 * @param dst_bytes The length (in bytes) of the destination buffer. Must not
 *                  be 0.
 * @returns the number of bytes written, excluding the null terminator.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_strlcpy
 *
 * @from SDL_stdinc.h:3088 size_t SDL_utf8strlcpy(SDL_OUT_Z_CAP(dst_bytes) char *dst, const char *src, size_t dst_bytes);
 */
  utf8Strlcpy: lib.symbols.SDL_utf8strlcpy,

/**
 * Allocate a copy of a string, up to n characters.
 *
 * This allocates enough space for a null-terminated copy of `str`, up to
 * `maxlen` bytes, using SDL_malloc, and then makes a copy of the string into
 * this space.
 *
 * If the string is longer than `maxlen` bytes, the returned string will be
 * `maxlen` bytes long, plus a null-terminator character that isn't included
 * in the count.
 *
 * The returned string is owned by the caller, and should be passed to
 * SDL_free when no longer needed.
 *
 * @param str the string to copy.
 * @param maxlen the maximum length of the copied string, not counting the
 *               null-terminator character.
 * @returns a pointer to the newly-allocated string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:3159 SDL_MALLOC char * SDL_strndup(const char *str, size_t maxlen);
 */
  strndup: lib.symbols.SDL_strndup,

/**
 * Reverse a string's contents.
 *
 * This reverses a null-terminated string in-place. Only the content of the
 * string is reversed; the null-terminator character remains at the end of the
 * reversed string.
 *
 * **WARNING**: This function reverses the _bytes_ of the string, not the
 * codepoints. If `str` is a UTF-8 string with Unicode codepoints > 127, this
 * will ruin the string data. You should only use this function on strings
 * that are completely comprised of low ASCII characters.
 *
 * @param str the string to reverse.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:3180 char * SDL_strrev(char *str);
 */
  strrev: lib.symbols.SDL_strrev,

/**
 * Convert a string to uppercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to uppercase.
 *
 * This function operates on a null-terminated string of bytes--even if it is
 * malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their
 * uppercase equivalents in-place, returning the original `str` pointer.
 *
 * @param str the string to convert in-place. Can not be NULL.
 * @returns the `str` pointer passed into this function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_strlwr
 *
 * @from SDL_stdinc.h:3201 char * SDL_strupr(char *str);
 */
  strupr: lib.symbols.SDL_strupr,

/**
 * Convert a string to lowercase.
 *
 * **WARNING**: Regardless of system locale, this will only convert ASCII
 * values 'A' through 'Z' to lowercase.
 *
 * This function operates on a null-terminated string of bytes--even if it is
 * malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their
 * lowercase equivalents in-place, returning the original `str` pointer.
 *
 * @param str the string to convert in-place. Can not be NULL.
 * @returns the `str` pointer passed into this function.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_strupr
 *
 * @from SDL_stdinc.h:3222 char * SDL_strlwr(char *str);
 */
  strlwr: lib.symbols.SDL_strlwr,

/**
 * Search a string, up to n bytes, for the first instance of a specific
 * substring.
 *
 * The search ends once it finds the requested substring, or a null terminator
 * byte to end the string, or `maxlen` bytes have been examined. It is
 * possible to use this function on a string without a null terminator.
 *
 * Note that this looks for strings of _bytes_, not _characters_, so it's
 * legal to search for malformed and incomplete UTF-8 sequences.
 *
 * @param haystack the string to search. Must not be NULL.
 * @param needle the string to search for. Must not be NULL.
 * @param maxlen the maximum number of bytes to search in `haystack`.
 * @returns a pointer to the first instance of `needle` in the string, or NULL
 *          if not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:3304 char * SDL_strnstr(const char *haystack, const char *needle, size_t maxlen);
 */
  strnstr: lib.symbols.SDL_strnstr,

/**
 * Search a UTF-8 string for the first instance of a specific substring,
 * case-insensitively.
 *
 * This will work with Unicode strings, using a technique called
 * "case-folding" to handle the vast majority of case-sensitive human
 * languages regardless of system locale. It can deal with expanding values: a
 * German Eszett character can compare against two ASCII 's' chars and be
 * considered a match, for example. A notable exception: it does not handle
 * the Turkish 'i' character; human language is complicated!
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), which is to say two strings of random bits may turn out to
 * match if they convert to the same amount of replacement characters.
 *
 * @param haystack the string to search. Must not be NULL.
 * @param needle the string to search for. Must not be NULL.
 * @returns a pointer to the first instance of `needle` in the string, or NULL
 *          if not found.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:3332 char * SDL_strcasestr(const char *haystack, const char *needle);
 */
  strcasestr: lib.symbols.SDL_strcasestr,

/**
 * Count the number of codepoints in a UTF-8 string.
 *
 * Counts the _codepoints_, not _bytes_, in `str`, excluding the null
 * terminator.
 *
 * If you need to count the bytes in a string instead, consider using
 * SDL_strlen().
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the
 * count by several replacement characters.
 *
 * @param str The null-terminated UTF-8 string to read. Must not be NULL.
 * @returns The length (in codepoints, excluding the null terminator) of
 *          `src`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_utf8strnlen
 * @sa SDL_strlen
 *
 * @from SDL_stdinc.h:3389 size_t SDL_utf8strlen(const char *str);
 */
  utf8Strlen: lib.symbols.SDL_utf8strlen,

/**
 * Count the number of codepoints in a UTF-8 string, up to n bytes.
 *
 * Counts the _codepoints_, not _bytes_, in `str`, excluding the null
 * terminator.
 *
 * If you need to count the bytes in a string instead, consider using
 * SDL_strnlen().
 *
 * The counting stops at `bytes` bytes (not codepoints!). This seems
 * counterintuitive, but makes it easy to express the total size of the
 * string's buffer.
 *
 * Since this handles Unicode, it expects the strings to be well-formed UTF-8
 * and not a null-terminated string of arbitrary bytes. Bytes that are not
 * valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT
 * CHARACTER), so a malformed or incomplete UTF-8 sequence might increase the
 * count by several replacement characters.
 *
 * @param str The null-terminated UTF-8 string to read. Must not be NULL.
 * @param bytes The maximum amount of bytes to count.
 * @returns The length (in codepoints, excluding the null terminator) of `src`
 *          but never more than `maxlen`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_utf8strlen
 * @sa SDL_strnlen
 *
 * @from SDL_stdinc.h:3422 size_t SDL_utf8strnlen(const char *str, size_t bytes);
 */
  utf8Strnlen: lib.symbols.SDL_utf8strnlen,

/**
 * Convert an integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget possible negative
 * signs, null terminator bytes, etc).
 *
 * @param value the integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_uitoa
 * @sa SDL_ltoa
 * @sa SDL_lltoa
 *
 * @from SDL_stdinc.h:3450 char * SDL_itoa(int value, char *str, int radix);
 */
  itoa: lib.symbols.SDL_itoa,

/**
 * Convert an unsigned integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget null terminator
 * bytes, etc).
 *
 * @param value the unsigned integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_itoa
 * @sa SDL_ultoa
 * @sa SDL_ulltoa
 *
 * @from SDL_stdinc.h:3478 char * SDL_uitoa(unsigned int value, char *str, int radix);
 */
  uitoa: lib.symbols.SDL_uitoa,

/**
 * Convert a long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget possible negative
 * signs, null terminator bytes, etc).
 *
 * @param value the long integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ultoa
 * @sa SDL_itoa
 * @sa SDL_lltoa
 *
 * @from SDL_stdinc.h:3506 char * SDL_ltoa(long value, char *str, int radix);
 */
  ltoa: lib.symbols.SDL_ltoa,

/**
 * Convert an unsigned long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget null terminator
 * bytes, etc).
 *
 * @param value the unsigned long integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ltoa
 * @sa SDL_uitoa
 * @sa SDL_ulltoa
 *
 * @from SDL_stdinc.h:3534 char * SDL_ultoa(unsigned long value, char *str, int radix);
 */
  ultoa: lib.symbols.SDL_ultoa,

/**
 * Convert a long long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget possible negative
 * signs, null terminator bytes, etc).
 *
 * @param value the long long integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ulltoa
 * @sa SDL_itoa
 * @sa SDL_ltoa
 *
 * @from SDL_stdinc.h:3564 char * SDL_lltoa(long long value, char *str, int radix);
 */
  lltoa: lib.symbols.SDL_lltoa,

/**
 * Convert an unsigned long long integer into a string.
 *
 * This requires a radix to specified for string format. Specifying 10
 * produces a decimal number, 16 hexidecimal, etc. Must be in the range of 2
 * to 36.
 *
 * Note that this function will overflow a buffer if `str` is not large enough
 * to hold the output! It may be safer to use SDL_snprintf to clamp output, or
 * SDL_asprintf to allocate a buffer. Otherwise, it doesn't hurt to allocate
 * much more space than you expect to use (and don't forget null terminator
 * bytes, etc).
 *
 * @param value the unsigned long long integer to convert.
 * @param str the buffer to write the string into.
 * @param radix the radix to use for string generation.
 * @returns `str`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_lltoa
 * @sa SDL_uitoa
 * @sa SDL_ultoa
 *
 * @from SDL_stdinc.h:3592 char * SDL_ulltoa(unsigned long long value, char *str, int radix);
 */
  ulltoa: lib.symbols.SDL_ulltoa,

/**
 * Parse an `int` from a string.
 *
 * The result of calling `SDL_atoi(str)` is equivalent to
 * `(int)SDL_strtol(str, NULL, 10)`.
 *
 * @param str The null-terminated string to read. Must not be NULL.
 * @returns the parsed `int`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atof
 * @sa SDL_strtol
 * @sa SDL_strtoul
 * @sa SDL_strtoll
 * @sa SDL_strtoull
 * @sa SDL_strtod
 * @sa SDL_itoa
 *
 * @from SDL_stdinc.h:3616 int SDL_atoi(const char *str);
 */
  atoi: lib.symbols.SDL_atoi,

/**
 * Parse a `double` from a string.
 *
 * The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,
 * NULL)`.
 *
 * @param str The null-terminated string to read. Must not be NULL.
 * @returns the parsed `double`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atoi
 * @sa SDL_strtol
 * @sa SDL_strtoul
 * @sa SDL_strtoll
 * @sa SDL_strtoull
 * @sa SDL_strtod
 *
 * @from SDL_stdinc.h:3638 double SDL_atof(const char *str);
 */
  atof: lib.symbols.SDL_atof,

/**
 * Parse a `long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside a `long`, the result is clamped to
 * the minimum and maximum representable `long` values.
 *
 * @param str The null-terminated string to read. Must not be NULL.
 * @param endp If not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * @param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * @returns the parsed `long`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atoi
 * @sa SDL_atof
 * @sa SDL_strtoul
 * @sa SDL_strtoll
 * @sa SDL_strtoull
 * @sa SDL_strtod
 * @sa SDL_ltoa
 * @sa SDL_wcstol
 *
 * @from SDL_stdinc.h:3672 long SDL_strtol(const char *str, char **endp, int base);
 */
  strtol: lib.symbols.SDL_strtol,

/**
 * Parse an `unsigned long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside an `unsigned long`, the result is
 * clamped to the maximum representable `unsigned long` value.
 *
 * @param str The null-terminated string to read. Must not be NULL.
 * @param endp If not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * @param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * @returns the parsed `unsigned long`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atoi
 * @sa SDL_atof
 * @sa SDL_strtol
 * @sa SDL_strtoll
 * @sa SDL_strtoull
 * @sa SDL_strtod
 * @sa SDL_ultoa
 *
 * @from SDL_stdinc.h:3705 unsigned long SDL_strtoul(const char *str, char **endp, int base);
 */
  strtoul: lib.symbols.SDL_strtoul,

/**
 * Parse a `long long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside a `long long`, the result is
 * clamped to the minimum and maximum representable `long long` values.
 *
 * @param str The null-terminated string to read. Must not be NULL.
 * @param endp If not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * @param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * @returns the parsed `long long`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atoi
 * @sa SDL_atof
 * @sa SDL_strtol
 * @sa SDL_strtoul
 * @sa SDL_strtoull
 * @sa SDL_strtod
 * @sa SDL_lltoa
 *
 * @from SDL_stdinc.h:3740 long long SDL_strtoll(const char *str, char **endp, int base);
 */
  strtoll: lib.symbols.SDL_strtoll,

/**
 * Parse an `unsigned long long` from a string.
 *
 * If `str` starts with whitespace, then those whitespace characters are
 * skipped before attempting to parse the number.
 *
 * If the parsed number does not fit inside an `unsigned long long`, the
 * result is clamped to the maximum representable `unsigned long long` value.
 *
 * @param str The null-terminated string to read. Must not be NULL.
 * @param endp If not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * @param base The base of the integer to read. Supported values are 0 and 2
 *             to 36 inclusive. If 0, the base will be inferred from the
 *             number's prefix (0x for hexadecimal, 0 for octal, decimal
 *             otherwise).
 * @returns the parsed `unsigned long long`, or 0 if no number could be
 *          parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atoi
 * @sa SDL_atof
 * @sa SDL_strtol
 * @sa SDL_strtoll
 * @sa SDL_strtoul
 * @sa SDL_strtod
 * @sa SDL_ulltoa
 *
 * @from SDL_stdinc.h:3774 unsigned long long SDL_strtoull(const char *str, char **endp, int base);
 */
  strtoull: lib.symbols.SDL_strtoull,

/**
 * Parse a `double` from a string.
 *
 * This function makes fewer guarantees than the C runtime `strtod`:
 *
 * - Only decimal notation is guaranteed to be supported. The handling of
 *   scientific and hexadecimal notation is unspecified.
 * - Whether or not INF and NAN can be parsed is unspecified.
 * - The precision of the result is unspecified.
 *
 * @param str the null-terminated string to read. Must not be NULL.
 * @param endp if not NULL, the address of the first invalid character (i.e.
 *             the next character after the parsed number) will be written to
 *             this pointer.
 * @returns the parsed `double`, or 0 if no number could be parsed.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atoi
 * @sa SDL_atof
 * @sa SDL_strtol
 * @sa SDL_strtoll
 * @sa SDL_strtoul
 * @sa SDL_strtoull
 *
 * @from SDL_stdinc.h:3804 double SDL_strtod(const char *str, char **endp);
 */
  strtod: lib.symbols.SDL_strtod,

/**
 * Decode a UTF-8 string, one Unicode codepoint at a time.
 *
 * This will return the first Unicode codepoint in the UTF-8 encoded string in
 * `*pstr`, and then advance `*pstr` past any consumed bytes before returning.
 *
 * It will not access more than `*pslen` bytes from the string. `*pslen` will
 * be adjusted, as well, subtracting the number of bytes consumed.
 *
 * `pslen` is allowed to be NULL, in which case the string _must_ be
 * NULL-terminated, as the function will blindly read until it sees the NULL
 * char.
 *
 * if `*pslen` is zero, it assumes the end of string is reached and returns a
 * zero codepoint regardless of the contents of the string buffer.
 *
 * If the resulting codepoint is zero (a NULL terminator), or `*pslen` is
 * zero, it will not advance `*pstr` or `*pslen` at all.
 *
 * Generally this function is called in a loop until it returns zero,
 * adjusting its parameters each iteration.
 *
 * If an invalid UTF-8 sequence is encountered, this function returns
 * SDL_INVALID_UNICODE_CODEPOINT and advances the string/length by one byte
 * (which is to say, a multibyte sequence might produce several
 * SDL_INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid
 * UTF-8 sequence).
 *
 * Several things can generate invalid UTF-8 sequences, including overlong
 * encodings, the use of UTF-16 surrogate values, and truncated data. Please
 * refer to
 * [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)
 * for details.
 *
 * @param pstr a pointer to a UTF-8 string pointer to be read and adjusted.
 * @param pslen a pointer to the number of bytes in the string, to be read and
 *              adjusted. NULL is allowed.
 * @returns the first Unicode codepoint in the string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:4000 Uint32 SDL_StepUTF8(const char **pstr, size_t *pslen);
 */
  stepUtf8: lib.symbols.SDL_StepUTF8,

/**
 * Decode a UTF-8 string in reverse, one Unicode codepoint at a time.
 *
 * This will go to the start of the previous Unicode codepoint in the string,
 * move `*pstr` to that location and return that codepoint.
 *
 * If `*pstr` is already at the start of the string), it will not advance
 * `*pstr` at all.
 *
 * Generally this function is called in a loop until it returns zero,
 * adjusting its parameter each iteration.
 *
 * If an invalid UTF-8 sequence is encountered, this function returns
 * SDL_INVALID_UNICODE_CODEPOINT.
 *
 * Several things can generate invalid UTF-8 sequences, including overlong
 * encodings, the use of UTF-16 surrogate values, and truncated data. Please
 * refer to
 * [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)
 * for details.
 *
 * @param start a pointer to the beginning of the UTF-8 string.
 * @param pstr a pointer to a UTF-8 string pointer to be read and adjusted.
 * @returns the previous Unicode codepoint in the string.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:4031 Uint32 SDL_StepBackUTF8(const char *start, const char **pstr);
 */
  stepBackUtf8: lib.symbols.SDL_StepBackUTF8,

/**
 * Convert a single Unicode codepoint to UTF-8.
 *
 * The buffer pointed to by `dst` must be at least 4 bytes long, as this
 * function may generate between 1 and 4 bytes of output.
 *
 * This function returns the first byte _after_ the newly-written UTF-8
 * sequence, which is useful for encoding multiple codepoints in a loop, or
 * knowing where to write a NULL-terminator character to end the string (in
 * either case, plan to have a buffer of _more_ than 4 bytes!).
 *
 * If `codepoint` is an invalid value (outside the Unicode range, or a UTF-16
 * surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the
 * codepoint instead, and not set an error.
 *
 * If `dst` is NULL, this returns NULL immediately without writing to the
 * pointer and without setting an error.
 *
 * @param codepoint a Unicode codepoint to convert to UTF-8.
 * @param dst the location to write the encoded UTF-8. Must point to at least
 *            4 bytes!
 * @returns the first byte past the newly-written UTF-8 sequence.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_stdinc.h:4060 char * SDL_UCS4ToUTF8(Uint32 codepoint, char *dst);
 */
  ucs4ToUtf8: lib.symbols.SDL_UCS4ToUTF8,

/**
 * Seeds the pseudo-random number generator.
 *
 * Reusing the seed number will cause SDL_rand() to repeat the same stream of
 * 'random' numbers.
 *
 * @param seed the value to use as a random number seed, or 0 to use
 *             SDL_GetPerformanceCounter().
 *
 * @threadsafety This should be called on the same thread that calls
 *               SDL_rand()
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_rand
 * @sa SDL_rand_bits
 * @sa SDL_randf
 *
 * @from SDL_stdinc.h:4272 void SDL_srand(Uint64 seed);
 */
  srand: lib.symbols.SDL_srand,

/**
 * Generate a pseudo-random number less than n for positive n
 *
 * The method used is faster and of better quality than `rand() % n`. Odds are
 * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
 * much worse as n gets bigger.
 *
 * Example: to simulate a d6 use `SDL_rand(6) + 1` The +1 converts 0..5 to
 * 1..6
 *
 * If you want to generate a pseudo-random number in the full range of Sint32,
 * you should use: (Sint32)SDL_rand_bits()
 *
 * If you want reproducible output, be sure to initialize with SDL_srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @param n the number of possible outcomes. n must be positive.
 * @returns a random value in the range of [0 .. n-1].
 *
 * @threadsafety All calls should be made from a single thread
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_srand
 * @sa SDL_randf
 *
 * @from SDL_stdinc.h:4306 Sint32 SDL_rand(Sint32 n);
 */
  rand: lib.symbols.SDL_rand,

/**
 * Generate a uniform pseudo-random floating point number less than 1.0
 *
 * If you want reproducible output, be sure to initialize with SDL_srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @returns a random value in the range of [0.0, 1.0).
 *
 * @threadsafety All calls should be made from a single thread
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_srand
 * @sa SDL_rand
 *
 * @from SDL_stdinc.h:4329 float SDL_randf(void);
 */
  randf: lib.symbols.SDL_randf,

/**
 * Generate 32 pseudo-random bits.
 *
 * You likely want to use SDL_rand() to get a psuedo-random number instead.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @returns a random value in the range of [0-SDL_MAX_UINT32].
 *
 * @threadsafety All calls should be made from a single thread
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_rand
 * @sa SDL_randf
 * @sa SDL_srand
 *
 * @from SDL_stdinc.h:4352 Uint32 SDL_rand_bits(void);
 */
  randBits: lib.symbols.SDL_rand_bits,

/**
 * Generate a pseudo-random number less than n for positive n
 *
 * The method used is faster and of better quality than `rand() % n`. Odds are
 * roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and
 * much worse as n gets bigger.
 *
 * Example: to simulate a d6 use `SDL_rand_r(state, 6) + 1` The +1 converts
 * 0..5 to 1..6
 *
 * If you want to generate a pseudo-random number in the full range of Sint32,
 * you should use: (Sint32)SDL_rand_bits_r(state)
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @param state a pointer to the current random number state, this may not be
 *              NULL.
 * @param n the number of possible outcomes. n must be positive.
 * @returns a random value in the range of [0 .. n-1].
 *
 * @threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_rand
 * @sa SDL_rand_bits_r
 * @sa SDL_randf_r
 *
 * @from SDL_stdinc.h:4387 Sint32 SDL_rand_r(Uint64 *state, Sint32 n);
 */
  randR: lib.symbols.SDL_rand_r,

/**
 * Generate a uniform pseudo-random floating point number less than 1.0
 *
 * If you want reproducible output, be sure to initialize with SDL_srand()
 * first.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @param state a pointer to the current random number state, this may not be
 *              NULL.
 * @returns a random value in the range of [0.0, 1.0).
 *
 * @threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_rand_bits_r
 * @sa SDL_rand_r
 * @sa SDL_randf
 *
 * @from SDL_stdinc.h:4414 float SDL_randf_r(Uint64 *state);
 */
  randfR: lib.symbols.SDL_randf_r,

/**
 * Generate 32 pseudo-random bits.
 *
 * You likely want to use SDL_rand_r() to get a psuedo-random number instead.
 *
 * There are no guarantees as to the quality of the random sequence produced,
 * and this should not be used for security (cryptography, passwords) or where
 * money is on the line (loot-boxes, casinos). There are many random number
 * libraries available with different characteristics and you should pick one
 * of those to meet any serious needs.
 *
 * @param state a pointer to the current random number state, this may not be
 *              NULL.
 * @returns a random value in the range of [0-SDL_MAX_UINT32].
 *
 * @threadsafety This function is thread-safe, as long as the state pointer
 *               isn't shared between threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_rand_r
 * @sa SDL_randf_r
 *
 * @from SDL_stdinc.h:4439 Uint32 SDL_rand_bits_r(Uint64 *state);
 */
  randBitsR: lib.symbols.SDL_rand_bits_r,

/**
 * Compute the arc cosine of `x`.
 *
 * The definition of `y = acos(x)` is `x = cos(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `0 <= y <= Pi`
 *
 * This function operates on double-precision floating point values, use
 * SDL_acosf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc cosine of `x`, in radians.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_acosf
 * @sa SDL_asin
 * @sa SDL_cos
 *
 * @from SDL_stdinc.h:4493 double SDL_acos(double x);
 */
  acos: lib.symbols.SDL_acos,

/**
 * Compute the arc cosine of `x`.
 *
 * The definition of `y = acos(x)` is `x = cos(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `0 <= y <= Pi`
 *
 * This function operates on single-precision floating point values, use
 * SDL_acos for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc cosine of `x`, in radians.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_acos
 * @sa SDL_asinf
 * @sa SDL_cosf
 *
 * @from SDL_stdinc.h:4523 float SDL_acosf(float x);
 */
  acosf: lib.symbols.SDL_acosf,

/**
 * Compute the arc sine of `x`.
 *
 * The definition of `y = asin(x)` is `x = sin(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on double-precision floating point values, use
 * SDL_asinf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc sine of `x`, in radians.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_asinf
 * @sa SDL_acos
 * @sa SDL_sin
 *
 * @from SDL_stdinc.h:4553 double SDL_asin(double x);
 */
  asin: lib.symbols.SDL_asin,

/**
 * Compute the arc sine of `x`.
 *
 * The definition of `y = asin(x)` is `x = sin(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on single-precision floating point values, use
 * SDL_asin for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc sine of `x`, in radians.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_asin
 * @sa SDL_acosf
 * @sa SDL_sinf
 *
 * @from SDL_stdinc.h:4583 float SDL_asinf(float x);
 */
  asinf: lib.symbols.SDL_asinf,

/**
 * Compute the arc tangent of `x`.
 *
 * The definition of `y = atan(x)` is `x = tan(y)`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on double-precision floating point values, use
 * SDL_atanf for single-precision floats.
 *
 * To calculate the arc tangent of y / x, use SDL_atan2.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc tangent of of `x` in radians, or 0 if `x = 0`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atanf
 * @sa SDL_atan2
 * @sa SDL_tan
 *
 * @from SDL_stdinc.h:4615 double SDL_atan(double x);
 */
  atan: lib.symbols.SDL_atan,

/**
 * Compute the arc tangent of `x`.
 *
 * The definition of `y = atan(x)` is `x = tan(y)`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on single-precision floating point values, use
 * SDL_atan for dboule-precision floats.
 *
 * To calculate the arc tangent of y / x, use SDL_atan2f.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns arc tangent of of `x` in radians, or 0 if `x = 0`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atan
 * @sa SDL_atan2f
 * @sa SDL_tanf
 *
 * @from SDL_stdinc.h:4647 float SDL_atanf(float x);
 */
  atanf: lib.symbols.SDL_atanf,

/**
 * Compute the arc tangent of `y / x`, using the signs of x and y to adjust
 * the result's quadrant.
 *
 * The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant
 * of z is determined based on the signs of x and y.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on double-precision floating point values, use
 * SDL_atan2f for single-precision floats.
 *
 * To calculate the arc tangent of a single value, use SDL_atan.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param y floating point value of the numerator (y coordinate).
 * @param x floating point value of the denominator (x coordinate).
 * @returns arc tangent of of `y / x` in radians, or, if `x = 0`, either
 *          `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atan2f
 * @sa SDL_atan
 * @sa SDL_tan
 *
 * @from SDL_stdinc.h:4683 double SDL_atan2(double y, double x);
 */
  atan2: lib.symbols.SDL_atan2,

/**
 * Compute the arc tangent of `y / x`, using the signs of x and y to adjust
 * the result's quadrant.
 *
 * The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant
 * of z is determined based on the signs of x and y.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-Pi/2 <= y <= Pi/2`
 *
 * This function operates on single-precision floating point values, use
 * SDL_atan2 for double-precision floats.
 *
 * To calculate the arc tangent of a single value, use SDL_atanf.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param y floating point value of the numerator (y coordinate).
 * @param x floating point value of the denominator (x coordinate).
 * @returns arc tangent of of `y / x` in radians, or, if `x = 0`, either
 *          `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_atan2
 * @sa SDL_atan
 * @sa SDL_tan
 *
 * @from SDL_stdinc.h:4719 float SDL_atan2f(float y, float x);
 */
  atan2F: lib.symbols.SDL_atan2f,

/**
 * Compute the ceiling of `x`.
 *
 * The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`
 * rounded up to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_ceilf for single-precision floats.
 *
 * @param x floating point value.
 * @returns the ceiling of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ceilf
 * @sa SDL_floor
 * @sa SDL_trunc
 * @sa SDL_round
 * @sa SDL_lround
 *
 * @from SDL_stdinc.h:4747 double SDL_ceil(double x);
 */
  ceil: lib.symbols.SDL_ceil,

/**
 * Compute the ceiling of `x`.
 *
 * The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`
 * rounded up to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * SDL_ceil for double-precision floats.
 *
 * @param x floating point value.
 * @returns the ceiling of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ceil
 * @sa SDL_floorf
 * @sa SDL_truncf
 * @sa SDL_roundf
 * @sa SDL_lroundf
 *
 * @from SDL_stdinc.h:4775 float SDL_ceilf(float x);
 */
  ceilf: lib.symbols.SDL_ceilf,

/**
 * Copy the sign of one floating-point value to another.
 *
 * The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.
 *
 * Domain: `-INF <= x <= INF`, ``-INF <= y <= f``
 *
 * Range: `-INF <= z <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_copysignf for single-precision floats.
 *
 * @param x floating point value to use as the magnitude.
 * @param y floating point value to use as the sign.
 * @returns the floating point value with the sign of y and the magnitude of
 *          x.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_copysignf
 * @sa SDL_fabs
 *
 * @from SDL_stdinc.h:4801 double SDL_copysign(double x, double y);
 */
  copysign: lib.symbols.SDL_copysign,

/**
 * Copy the sign of one floating-point value to another.
 *
 * The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.
 *
 * Domain: `-INF <= x <= INF`, ``-INF <= y <= f``
 *
 * Range: `-INF <= z <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_copysign for double-precision floats.
 *
 * @param x floating point value to use as the magnitude.
 * @param y floating point value to use as the sign.
 * @returns the floating point value with the sign of y and the magnitude of
 *          x.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_copysign
 * @sa SDL_fabsf
 *
 * @from SDL_stdinc.h:4827 float SDL_copysignf(float x, float y);
 */
  copysignf: lib.symbols.SDL_copysignf,

/**
 * Compute the cosine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on double-precision floating point values, use
 * SDL_cosf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns cosine of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_cosf
 * @sa SDL_acos
 * @sa SDL_sin
 *
 * @from SDL_stdinc.h:4855 double SDL_cos(double x);
 */
  cos: lib.symbols.SDL_cos,

/**
 * Compute the cosine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on single-precision floating point values, use
 * SDL_cos for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns cosine of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_cos
 * @sa SDL_acosf
 * @sa SDL_sinf
 *
 * @from SDL_stdinc.h:4883 float SDL_cosf(float x);
 */
  cosf: lib.symbols.SDL_cosf,

/**
 * Compute the exponential of `x`.
 *
 * The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the
 * natural logarithm. The inverse is the natural logarithm, SDL_log.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * The output will overflow if `exp(x)` is too large to be represented.
 *
 * This function operates on double-precision floating point values, use
 * SDL_expf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns value of `e^x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_expf
 * @sa SDL_log
 *
 * @from SDL_stdinc.h:4915 double SDL_exp(double x);
 */
  exp: lib.symbols.SDL_exp,

/**
 * Compute the exponential of `x`.
 *
 * The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the
 * natural logarithm. The inverse is the natural logarithm, SDL_logf.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * The output will overflow if `exp(x)` is too large to be represented.
 *
 * This function operates on single-precision floating point values, use
 * SDL_exp for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value.
 * @returns value of `e^x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_exp
 * @sa SDL_logf
 *
 * @from SDL_stdinc.h:4947 float SDL_expf(float x);
 */
  expf: lib.symbols.SDL_expf,

/**
 * Compute the absolute value of `x`
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_fabsf for single-precision floats.
 *
 * @param x floating point value to use as the magnitude.
 * @returns the absolute value of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_fabsf
 *
 * @from SDL_stdinc.h:4968 double SDL_fabs(double x);
 */
  fabs: lib.symbols.SDL_fabs,

/**
 * Compute the absolute value of `x`
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_fabs for double-precision floats.
 *
 * @param x floating point value to use as the magnitude.
 * @returns the absolute value of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_fabs
 *
 * @from SDL_stdinc.h:4989 float SDL_fabsf(float x);
 */
  fabsf: lib.symbols.SDL_fabsf,

/**
 * Compute the floor of `x`.
 *
 * The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`
 * rounded down to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_floorf for single-precision floats.
 *
 * @param x floating point value.
 * @returns the floor of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_floorf
 * @sa SDL_ceil
 * @sa SDL_trunc
 * @sa SDL_round
 * @sa SDL_lround
 *
 * @from SDL_stdinc.h:5017 double SDL_floor(double x);
 */
  floor: lib.symbols.SDL_floor,

/**
 * Compute the floor of `x`.
 *
 * The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`
 * rounded down to the nearest integer.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * SDL_floor for double-precision floats.
 *
 * @param x floating point value.
 * @returns the floor of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_floor
 * @sa SDL_ceilf
 * @sa SDL_truncf
 * @sa SDL_roundf
 * @sa SDL_lroundf
 *
 * @from SDL_stdinc.h:5045 float SDL_floorf(float x);
 */
  floorf: lib.symbols.SDL_floorf,

/**
 * Truncate `x` to an integer.
 *
 * Rounds `x` to the next closest integer to 0. This is equivalent to removing
 * the fractional part of `x`, leaving only the integer part.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_truncf for single-precision floats.
 *
 * @param x floating point value.
 * @returns `x` truncated to an integer.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_truncf
 * @sa SDL_fmod
 * @sa SDL_ceil
 * @sa SDL_floor
 * @sa SDL_round
 * @sa SDL_lround
 *
 * @from SDL_stdinc.h:5074 double SDL_trunc(double x);
 */
  trunc: lib.symbols.SDL_trunc,

/**
 * Truncate `x` to an integer.
 *
 * Rounds `x` to the next closest integer to 0. This is equivalent to removing
 * the fractional part of `x`, leaving only the integer part.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * SDL_trunc for double-precision floats.
 *
 * @param x floating point value.
 * @returns `x` truncated to an integer.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_trunc
 * @sa SDL_fmodf
 * @sa SDL_ceilf
 * @sa SDL_floorf
 * @sa SDL_roundf
 * @sa SDL_lroundf
 *
 * @from SDL_stdinc.h:5103 float SDL_truncf(float x);
 */
  truncf: lib.symbols.SDL_truncf,

/**
 * Return the floating-point remainder of `x / y`
 *
 * Divides `x` by `y`, and returns the remainder.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`
 *
 * Range: `-y <= z <= y`
 *
 * This function operates on double-precision floating point values, use
 * SDL_fmodf for single-precision floats.
 *
 * @param x the numerator.
 * @param y the denominator. Must not be 0.
 * @returns the remainder of `x / y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_fmodf
 * @sa SDL_modf
 * @sa SDL_trunc
 * @sa SDL_ceil
 * @sa SDL_floor
 * @sa SDL_round
 * @sa SDL_lround
 *
 * @from SDL_stdinc.h:5133 double SDL_fmod(double x, double y);
 */
  fmod: lib.symbols.SDL_fmod,

/**
 * Return the floating-point remainder of `x / y`
 *
 * Divides `x` by `y`, and returns the remainder.
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`, `y != 0`
 *
 * Range: `-y <= z <= y`
 *
 * This function operates on single-precision floating point values, use
 * SDL_fmod for double-precision floats.
 *
 * @param x the numerator.
 * @param y the denominator. Must not be 0.
 * @returns the remainder of `x / y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_fmod
 * @sa SDL_truncf
 * @sa SDL_modff
 * @sa SDL_ceilf
 * @sa SDL_floorf
 * @sa SDL_roundf
 * @sa SDL_lroundf
 *
 * @from SDL_stdinc.h:5163 float SDL_fmodf(float x, float y);
 */
  fmodf: lib.symbols.SDL_fmodf,

/**
 * Return whether the value is infinity.
 *
 * @param x double-precision floating point value.
 * @returns non-zero if the value is infinity, 0 otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_isinff
 *
 * @from SDL_stdinc.h:5177 int SDL_isinf(double x);
 */
  isinf: lib.symbols.SDL_isinf,

/**
 * Return whether the value is infinity.
 *
 * @param x floating point value.
 * @returns non-zero if the value is infinity, 0 otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_isinf
 *
 * @from SDL_stdinc.h:5191 int SDL_isinff(float x);
 */
  isinff: lib.symbols.SDL_isinff,

/**
 * Return whether the value is NaN.
 *
 * @param x double-precision floating point value.
 * @returns non-zero if the value is NaN, 0 otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_isnanf
 *
 * @from SDL_stdinc.h:5205 int SDL_isnan(double x);
 */
  isnan: lib.symbols.SDL_isnan,

/**
 * Return whether the value is NaN.
 *
 * @param x floating point value.
 * @returns non-zero if the value is NaN, 0 otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_isnan
 *
 * @from SDL_stdinc.h:5219 int SDL_isnanf(float x);
 */
  isnanf: lib.symbols.SDL_isnanf,

/**
 * Compute the natural logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on double-precision floating point values, use
 * SDL_logf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than 0.
 * @returns the natural logarithm of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_logf
 * @sa SDL_log10
 * @sa SDL_exp
 *
 * @from SDL_stdinc.h:5249 double SDL_log(double x);
 */
  log: lib.symbols.SDL_log,

/**
 * Compute the natural logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on single-precision floating point values, use
 * SDL_log for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than 0.
 * @returns the natural logarithm of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_log
 * @sa SDL_expf
 *
 * @from SDL_stdinc.h:5278 float SDL_logf(float x);
 */
  logf: lib.symbols.SDL_logf,

/**
 * Compute the base-10 logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on double-precision floating point values, use
 * SDL_log10f for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than 0.
 * @returns the logarithm of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_log10f
 * @sa SDL_log
 * @sa SDL_pow
 *
 * @from SDL_stdinc.h:5308 double SDL_log10(double x);
 */
  log10: lib.symbols.SDL_log10,

/**
 * Compute the base-10 logarithm of `x`.
 *
 * Domain: `0 < x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * It is an error for `x` to be less than or equal to 0.
 *
 * This function operates on single-precision floating point values, use
 * SDL_log10 for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than 0.
 * @returns the logarithm of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_log10
 * @sa SDL_logf
 * @sa SDL_powf
 *
 * @from SDL_stdinc.h:5338 float SDL_log10f(float x);
 */
  log10F: lib.symbols.SDL_log10f,

/**
 * Split `x` into integer and fractional parts
 *
 * This function operates on double-precision floating point values, use
 * SDL_modff for single-precision floats.
 *
 * @param x floating point value.
 * @param y output pointer to store the integer part of `x`.
 * @returns the fractional part of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_modff
 * @sa SDL_trunc
 * @sa SDL_fmod
 *
 * @from SDL_stdinc.h:5358 double SDL_modf(double x, double *y);
 */
  modf: lib.symbols.SDL_modf,

/**
 * Split `x` into integer and fractional parts
 *
 * This function operates on single-precision floating point values, use
 * SDL_modf for double-precision floats.
 *
 * @param x floating point value.
 * @param y output pointer to store the integer part of `x`.
 * @returns the fractional part of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_modf
 * @sa SDL_truncf
 * @sa SDL_fmodf
 *
 * @from SDL_stdinc.h:5378 float SDL_modff(float x, float *y);
 */
  modff: lib.symbols.SDL_modff,

/**
 * Raise `x` to the power `y`
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-INF <= z <= INF`
 *
 * If `y` is the base of the natural logarithm (e), consider using SDL_exp
 * instead.
 *
 * This function operates on double-precision floating point values, use
 * SDL_powf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x the base.
 * @param y the exponent.
 * @returns `x` raised to the power `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_powf
 * @sa SDL_exp
 * @sa SDL_log
 *
 * @from SDL_stdinc.h:5410 double SDL_pow(double x, double y);
 */
  pow: lib.symbols.SDL_pow,

/**
 * Raise `x` to the power `y`
 *
 * Domain: `-INF <= x <= INF`, `-INF <= y <= INF`
 *
 * Range: `-INF <= z <= INF`
 *
 * If `y` is the base of the natural logarithm (e), consider using SDL_exp
 * instead.
 *
 * This function operates on single-precision floating point values, use
 * SDL_pow for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x the base.
 * @param y the exponent.
 * @returns `x` raised to the power `y`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_pow
 * @sa SDL_expf
 * @sa SDL_logf
 *
 * @from SDL_stdinc.h:5442 float SDL_powf(float x, float y);
 */
  powf: lib.symbols.SDL_powf,

/**
 * Round `x` to the nearest integer.
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on double-precision floating point values, use
 * SDL_roundf for single-precision floats. To get the result as an integer
 * type, use SDL_lround.
 *
 * @param x floating point value.
 * @returns the nearest integer to `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_roundf
 * @sa SDL_lround
 * @sa SDL_floor
 * @sa SDL_ceil
 * @sa SDL_trunc
 *
 * @from SDL_stdinc.h:5471 double SDL_round(double x);
 */
  round: lib.symbols.SDL_round,

/**
 * Round `x` to the nearest integer.
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`, y integer
 *
 * This function operates on single-precision floating point values, use
 * SDL_round for double-precision floats. To get the result as an integer
 * type, use SDL_lroundf.
 *
 * @param x floating point value.
 * @returns the nearest integer to `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_round
 * @sa SDL_lroundf
 * @sa SDL_floorf
 * @sa SDL_ceilf
 * @sa SDL_truncf
 *
 * @from SDL_stdinc.h:5500 float SDL_roundf(float x);
 */
  roundf: lib.symbols.SDL_roundf,

/**
 * Round `x` to the nearest integer representable as a long
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `MIN_LONG <= y <= MAX_LONG`
 *
 * This function operates on double-precision floating point values, use
 * SDL_lroundf for single-precision floats. To get the result as a
 * floating-point type, use SDL_round.
 *
 * @param x floating point value.
 * @returns the nearest integer to `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_lroundf
 * @sa SDL_round
 * @sa SDL_floor
 * @sa SDL_ceil
 * @sa SDL_trunc
 *
 * @from SDL_stdinc.h:5529 long SDL_lround(double x);
 */
  lround: lib.symbols.SDL_lround,

/**
 * Round `x` to the nearest integer representable as a long
 *
 * Rounds `x` to the nearest integer. Values halfway between integers will be
 * rounded away from zero.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `MIN_LONG <= y <= MAX_LONG`
 *
 * This function operates on single-precision floating point values, use
 * SDL_lround for double-precision floats. To get the result as a
 * floating-point type, use SDL_roundf.
 *
 * @param x floating point value.
 * @returns the nearest integer to `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_lround
 * @sa SDL_roundf
 * @sa SDL_floorf
 * @sa SDL_ceilf
 * @sa SDL_truncf
 *
 * @from SDL_stdinc.h:5558 long SDL_lroundf(float x);
 */
  lroundf: lib.symbols.SDL_lroundf,

/**
 * Scale `x` by an integer power of two.
 *
 * Multiplies `x` by the `n`th power of the floating point radix (always 2).
 *
 * Domain: `-INF <= x <= INF`, `n` integer
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_scalbnf for single-precision floats.
 *
 * @param x floating point value to be scaled.
 * @param n integer exponent.
 * @returns `x * 2^n`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_scalbnf
 * @sa SDL_pow
 *
 * @from SDL_stdinc.h:5583 double SDL_scalbn(double x, int n);
 */
  scalbn: lib.symbols.SDL_scalbn,

/**
 * Scale `x` by an integer power of two.
 *
 * Multiplies `x` by the `n`th power of the floating point radix (always 2).
 *
 * Domain: `-INF <= x <= INF`, `n` integer
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_scalbn for double-precision floats.
 *
 * @param x floating point value to be scaled.
 * @param n integer exponent.
 * @returns `x * 2^n`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_scalbn
 * @sa SDL_powf
 *
 * @from SDL_stdinc.h:5608 float SDL_scalbnf(float x, int n);
 */
  scalbnf: lib.symbols.SDL_scalbnf,

/**
 * Compute the sine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on double-precision floating point values, use
 * SDL_sinf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns sine of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_sinf
 * @sa SDL_asin
 * @sa SDL_cos
 *
 * @from SDL_stdinc.h:5636 double SDL_sin(double x);
 */
  sin: lib.symbols.SDL_sin,

/**
 * Compute the sine of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-1 <= y <= 1`
 *
 * This function operates on single-precision floating point values, use
 * SDL_sin for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns sine of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_sin
 * @sa SDL_asinf
 * @sa SDL_cosf
 *
 * @from SDL_stdinc.h:5664 float SDL_sinf(float x);
 */
  sinf: lib.symbols.SDL_sinf,

/**
 * Compute the square root of `x`.
 *
 * Domain: `0 <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_sqrtf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than or equal to 0.
 * @returns square root of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_sqrtf
 *
 * @from SDL_stdinc.h:5690 double SDL_sqrt(double x);
 */
  sqrt: lib.symbols.SDL_sqrt,

/**
 * Compute the square root of `x`.
 *
 * Domain: `0 <= x <= INF`
 *
 * Range: `0 <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_sqrt for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value. Must be greater than or equal to 0.
 * @returns square root of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_sqrt
 *
 * @from SDL_stdinc.h:5716 float SDL_sqrtf(float x);
 */
  sqrtf: lib.symbols.SDL_sqrtf,

/**
 * Compute the tangent of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on double-precision floating point values, use
 * SDL_tanf for single-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns tangent of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_tanf
 * @sa SDL_sin
 * @sa SDL_cos
 * @sa SDL_atan
 * @sa SDL_atan2
 *
 * @from SDL_stdinc.h:5746 double SDL_tan(double x);
 */
  tan: lib.symbols.SDL_tan,

/**
 * Compute the tangent of `x`.
 *
 * Domain: `-INF <= x <= INF`
 *
 * Range: `-INF <= y <= INF`
 *
 * This function operates on single-precision floating point values, use
 * SDL_tan for double-precision floats.
 *
 * This function may use a different approximation across different versions,
 * platforms and configurations. i.e, it can return a different value given
 * the same input on different machines or operating systems, or if SDL is
 * updated.
 *
 * @param x floating point value, in radians.
 * @returns tangent of `x`.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_tan
 * @sa SDL_sinf
 * @sa SDL_cosf
 * @sa SDL_atanf
 * @sa SDL_atan2f
 *
 * @from SDL_stdinc.h:5776 float SDL_tanf(float x);
 */
  tanf: lib.symbols.SDL_tanf,

/**
 * Helper function to convert a string's encoding in one call.
 *
 * This function converts a buffer or string between encodings in one pass.
 *
 * The string does not need to be NULL-terminated; this function operates on
 * the number of bytes specified in `inbytesleft` whether there is a NULL
 * character anywhere in the buffer.
 *
 * The returned string is owned by the caller, and should be passed to
 * SDL_free when no longer needed.
 *
 * @param tocode the character encoding of the output string. Examples are
 *               "UTF-8", "UCS-4", etc.
 * @param fromcode the character encoding of data in `inbuf`.
 * @param inbuf the string to convert to a different encoding.
 * @param inbytesleft the size of the input string _in bytes_.
 * @returns a new string, converted to the new encoding, or NULL on error.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_iconv_open
 * @sa SDL_iconv_close
 * @sa SDL_iconv
 *
 * @from SDL_stdinc.h:5890 char * SDL_iconv_string(const char *tocode,                                               const char *fromcode,                                               const char *inbuf,                                               size_t inbytesleft);
 */
  iconvString: lib.symbols.SDL_iconv_string,



/*--- SDL_storage ---*/

/**
 * Opens up a read-only container for the application's filesystem.
 *
 * @param override a path to override the backend's default title root.
 * @param props a property list that may contain backend-specific information.
 * @returns a title storage container on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseStorage
 * @sa SDL_GetStorageFileSize
 * @sa SDL_OpenUserStorage
 * @sa SDL_ReadStorageFile
 *
 * @from SDL_storage.h:348 SDL_Storage * SDL_OpenTitleStorage(const char *override, SDL_PropertiesID props);
 */
  openTitleStorage: lib.symbols.SDL_OpenTitleStorage,

/**
 * Opens up a container for a user's unique read/write filesystem.
 *
 * While title storage can generally be kept open throughout runtime, user
 * storage should only be opened when the client is ready to read/write files.
 * This allows the backend to properly batch file operations and flush them
 * when the container has been closed; ensuring safe and optimal save I/O.
 *
 * @param org the name of your organization.
 * @param app the name of your application.
 * @param props a property list that may contain backend-specific information.
 * @returns a user storage container on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseStorage
 * @sa SDL_GetStorageFileSize
 * @sa SDL_GetStorageSpaceRemaining
 * @sa SDL_OpenTitleStorage
 * @sa SDL_ReadStorageFile
 * @sa SDL_StorageReady
 * @sa SDL_WriteStorageFile
 *
 * @from SDL_storage.h:374 SDL_Storage * SDL_OpenUserStorage(const char *org, const char *app, SDL_PropertiesID props);
 */
  openUserStorage: lib.symbols.SDL_OpenUserStorage,

/**
 * Opens up a container for local filesystem storage.
 *
 * This is provided for development and tools. Portable applications should
 * use SDL_OpenTitleStorage() for access to game data and
 * SDL_OpenUserStorage() for access to user data.
 *
 * @param path the base path prepended to all storage paths, or NULL for no
 *             base path.
 * @returns a filesystem storage container on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseStorage
 * @sa SDL_GetStorageFileSize
 * @sa SDL_GetStorageSpaceRemaining
 * @sa SDL_OpenTitleStorage
 * @sa SDL_OpenUserStorage
 * @sa SDL_ReadStorageFile
 * @sa SDL_WriteStorageFile
 *
 * @from SDL_storage.h:398 SDL_Storage * SDL_OpenFileStorage(const char *path);
 */
  openFileStorage: lib.symbols.SDL_OpenFileStorage,

/**
 * Opens up a container using a client-provided storage interface.
 *
 * Applications do not need to use this function unless they are providing
 * their own SDL_Storage implementation. If you just need an SDL_Storage, you
 * should use the built-in implementations in SDL, like SDL_OpenTitleStorage()
 * or SDL_OpenUserStorage().
 *
 * This function makes a copy of `iface` and the caller does not need to keep
 * it around after this call.
 *
 * @param iface the interface that implements this storage, initialized using
 *              SDL_INIT_INTERFACE().
 * @param userdata the pointer that will be passed to the interface functions.
 * @returns a storage container on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CloseStorage
 * @sa SDL_GetStorageFileSize
 * @sa SDL_GetStorageSpaceRemaining
 * @sa SDL_INIT_INTERFACE
 * @sa SDL_ReadStorageFile
 * @sa SDL_StorageReady
 * @sa SDL_WriteStorageFile
 *
 * @from SDL_storage.h:427 SDL_Storage * SDL_OpenStorage(const SDL_StorageInterface *iface, void *userdata);
 */
  openStorage: lib.symbols.SDL_OpenStorage,

/**
 * Closes and frees a storage container.
 *
 * @param storage a storage container to close.
 * @returns true if the container was freed with no errors, false otherwise;
 *          call SDL_GetError() for more information. Even if the function
 *          returns an error, the container data will be freed; the error is
 *          only for informational purposes.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_OpenFileStorage
 * @sa SDL_OpenStorage
 * @sa SDL_OpenTitleStorage
 * @sa SDL_OpenUserStorage
 *
 * @from SDL_storage.h:445 bool SDL_CloseStorage(SDL_Storage *storage);
 */
  closeStorage: lib.symbols.SDL_CloseStorage,

/**
 * Checks if the storage container is ready to use.
 *
 * This function should be called in regular intervals until it returns true -
 * however, it is not recommended to spinwait on this call, as the backend may
 * depend on a synchronous message loop. You might instead poll this in your
 * game's main loop while processing events and drawing a loading screen.
 *
 * @param storage a storage container to query.
 * @returns true if the container is ready, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_storage.h:460 bool SDL_StorageReady(SDL_Storage *storage);
 */
  storageReady: lib.symbols.SDL_StorageReady,

/**
 * Query the size of a file within a storage container.
 *
 * @param storage a storage container to query.
 * @param path the relative path of the file to query.
 * @param length a pointer to be filled with the file's length.
 * @returns true if the file could be queried or false on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ReadStorageFile
 * @sa SDL_StorageReady
 *
 * @from SDL_storage.h:476 bool SDL_GetStorageFileSize(SDL_Storage *storage, const char *path, Uint64 *length);
 */
  getStorageFileSize: lib.symbols.SDL_GetStorageFileSize,

/**
 * Synchronously read a file from a storage container into a client-provided
 * buffer.
 *
 * The value of `length` must match the length of the file exactly; call
 * SDL_GetStorageFileSize() to get this value. This behavior may be relaxed in
 * a future release.
 *
 * @param storage a storage container to read from.
 * @param path the relative path of the file to read.
 * @param destination a client-provided buffer to read the file into.
 * @param length the length of the destination buffer.
 * @returns true if the file was read or false on failure; call SDL_GetError()
 *          for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetStorageFileSize
 * @sa SDL_StorageReady
 * @sa SDL_WriteStorageFile
 *
 * @from SDL_storage.h:499 bool SDL_ReadStorageFile(SDL_Storage *storage, const char *path, void *destination, Uint64 length);
 */
  readStorageFile: lib.symbols.SDL_ReadStorageFile,

/**
 * Synchronously write a file from client memory into a storage container.
 *
 * @param storage a storage container to write to.
 * @param path the relative path of the file to write.
 * @param source a client-provided buffer to write from.
 * @param length the length of the source buffer.
 * @returns true if the file was written or false on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetStorageSpaceRemaining
 * @sa SDL_ReadStorageFile
 * @sa SDL_StorageReady
 *
 * @from SDL_storage.h:517 bool SDL_WriteStorageFile(SDL_Storage *storage, const char *path, const void *source, Uint64 length);
 */
  writeStorageFile: lib.symbols.SDL_WriteStorageFile,

/**
 * Create a directory in a writable storage container.
 *
 * @param storage a storage container.
 * @param path the path of the directory to create.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StorageReady
 *
 * @from SDL_storage.h:531 bool SDL_CreateStorageDirectory(SDL_Storage *storage, const char *path);
 */
  createStorageDirectory: lib.symbols.SDL_CreateStorageDirectory,

/**
 * Enumerate a directory in a storage container through a callback function.
 *
 * This function provides every directory entry through an app-provided
 * callback, called once for each directory entry, until all results have been
 * provided or the callback returns either SDL_ENUM_SUCCESS or
 * SDL_ENUM_FAILURE.
 *
 * This will return false if there was a system problem in general, or if a
 * callback returns SDL_ENUM_FAILURE. A successful return means a callback
 * returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries
 * were enumerated.
 *
 * If `path` is NULL, this is treated as a request to enumerate the root of
 * the storage container's tree. An empty string also works for this.
 *
 * @param storage a storage container.
 * @param path the path of the directory to enumerate, or NULL for the root.
 * @param callback a function that is called for each entry in the directory.
 * @param userdata a pointer that is passed to `callback`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StorageReady
 *
 * @from SDL_storage.h:560 bool SDL_EnumerateStorageDirectory(SDL_Storage *storage, const char *path, SDL_EnumerateDirectoryCallback callback, void *userdata);
 */
  enumerateStorageDirectory: lib.symbols.SDL_EnumerateStorageDirectory,

/**
 * Remove a file or an empty directory in a writable storage container.
 *
 * @param storage a storage container.
 * @param path the path of the directory to enumerate.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StorageReady
 *
 * @from SDL_storage.h:574 bool SDL_RemoveStoragePath(SDL_Storage *storage, const char *path);
 */
  removeStoragePath: lib.symbols.SDL_RemoveStoragePath,

/**
 * Rename a file or directory in a writable storage container.
 *
 * @param storage a storage container.
 * @param oldpath the old path.
 * @param newpath the new path.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StorageReady
 *
 * @from SDL_storage.h:589 bool SDL_RenameStoragePath(SDL_Storage *storage, const char *oldpath, const char *newpath);
 */
  renameStoragePath: lib.symbols.SDL_RenameStoragePath,

/**
 * Copy a file in a writable storage container.
 *
 * @param storage a storage container.
 * @param oldpath the old path.
 * @param newpath the new path.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StorageReady
 *
 * @from SDL_storage.h:604 bool SDL_CopyStorageFile(SDL_Storage *storage, const char *oldpath, const char *newpath);
 */
  copyStorageFile: lib.symbols.SDL_CopyStorageFile,

/**
 * Get information about a filesystem path in a storage container.
 *
 * @param storage a storage container.
 * @param path the path to query.
 * @param info a pointer filled in with information about the path, or NULL to
 *             check for the existence of a file.
 * @returns true on success or false if the file doesn't exist, or another
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StorageReady
 *
 * @from SDL_storage.h:620 bool SDL_GetStoragePathInfo(SDL_Storage *storage, const char *path, SDL_PathInfo *info);
 */
  getStoragePathInfo: lib.symbols.SDL_GetStoragePathInfo,

/**
 * Queries the remaining space in a storage container.
 *
 * @param storage a storage container to query.
 * @returns the amount of remaining space, in bytes.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_StorageReady
 * @sa SDL_WriteStorageFile
 *
 * @from SDL_storage.h:633 Uint64 SDL_GetStorageSpaceRemaining(SDL_Storage *storage);
 */
  getStorageSpaceRemaining: lib.symbols.SDL_GetStorageSpaceRemaining,

/**
 * Enumerate a directory tree, filtered by pattern, and return a list.
 *
 * Files are filtered out if they don't match the string in `pattern`, which
 * may contain wildcard characters `*` (match everything) and `?` (match one
 * character). If pattern is NULL, no filtering is done and all results are
 * returned. Subdirectories are permitted, and are specified with a path
 * separator of '/'. Wildcard characters `*` and `?` never match a path
 * separator.
 *
 * `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching
 * case-insensitive.
 *
 * The returned array is always NULL-terminated, for your iterating
 * convenience, but if `count` is non-NULL, on return it will contain the
 * number of items in the array, not counting the NULL terminator.
 *
 * If `path` is NULL, this is treated as a request to enumerate the root of
 * the storage container's tree. An empty string also works for this.
 *
 * @param storage a storage container.
 * @param path the path of the directory to enumerate, or NULL for the root.
 * @param pattern the pattern that files in the directory must match. Can be
 *                NULL.
 * @param flags `SDL_GLOB_*` bitflags that affect this search.
 * @param count on return, will be set to the number of items in the returned
 *              array. Can be NULL.
 * @returns an array of strings on success or NULL on failure; call
 *          SDL_GetError() for more information. The caller should pass the
 *          returned pointer to SDL_free when done with it. This is a single
 *          allocation that should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * @threadsafety It is safe to call this function from any thread, assuming
 *               the `storage` object is thread-safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_storage.h:673 char ** SDL_GlobStorageDirectory(SDL_Storage *storage, const char *path, const char *pattern, SDL_GlobFlags flags, int *count);
 */
  globStorageDirectory: lib.symbols.SDL_GlobStorageDirectory,



/*--- SDL_surface ---*/

/**
 * @from SDL_surface:65 SDL_SURFACE_
 */
  SURFACE: SDL_surface_enums.SURFACE,

/**
 * @from SDL_surface:248 SDL_PROP_SURFACE_
 */
  PROP_SURFACE: SDL_surface_enums.PROP_SURFACE,

/**
 * The scaling mode.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:82 SDL_SCALEMODE_
 */
  SCALEMODE: SDL_surface_enums.SDL_ScaleMode,

/**
 * The flip mode.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:94 SDL_FLIP_
 */
  FLIP: SDL_surface_enums.SDL_FlipMode,



/**
 * Allocate a new surface with a specific pixel format.
 *
 * The pixels of the new surface are initialized to zero.
 *
 * @param width the width of the surface.
 * @param height the height of the surface.
 * @param format the SDL_PixelFormat for the new surface's pixel format.
 * @returns the new SDL_Surface structure that is created or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateSurfaceFrom
 * @sa SDL_DestroySurface
 *
 * @from SDL_surface.h:166 SDL_Surface * SDL_CreateSurface(int width, int height, SDL_PixelFormat format);
 */
  createSurface: lib.symbols.SDL_CreateSurface,

/**
 * Allocate a new surface with a specific pixel format and existing pixel
 * data.
 *
 * No copy is made of the pixel data. Pixel data is not managed automatically;
 * you must free the surface before you free the pixel data.
 *
 * Pitch is the offset in bytes from one row of pixels to the next, e.g.
 * `width*4` for `SDL_PIXELFORMAT_RGBA8888`.
 *
 * You may pass NULL for pixels and 0 for pitch to create a surface that you
 * will fill in with valid values later.
 *
 * @param width the width of the surface.
 * @param height the height of the surface.
 * @param format the SDL_PixelFormat for the new surface's pixel format.
 * @param pixels a pointer to existing pixel data.
 * @param pitch the number of bytes between each row, including padding.
 * @returns the new SDL_Surface structure that is created or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateSurface
 * @sa SDL_DestroySurface
 *
 * @from SDL_surface.h:196 SDL_Surface * SDL_CreateSurfaceFrom(int width, int height, SDL_PixelFormat format, void *pixels, int pitch);
 */
  createSurfaceFrom: lib.symbols.SDL_CreateSurfaceFrom,

/**
 * Free a surface.
 *
 * It is safe to pass NULL to this function.
 *
 * @param surface the SDL_Surface to free.
 *
 * @threadsafety No other thread should be using the surface when it is freed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateSurface
 * @sa SDL_CreateSurfaceFrom
 *
 * @from SDL_surface.h:212 void SDL_DestroySurface(SDL_Surface *surface);
 */
  destroySurface: lib.symbols.SDL_DestroySurface,

/**
 * Get the properties associated with a surface.
 *
 * The following properties are understood by SDL:
 *
 * - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
 *   surfaces, this defines the value of 100% diffuse white, with higher
 *   values being displayed in the High Dynamic Range headroom. This defaults
 *   to 203 for HDR10 surfaces and 1.0 for floating point surfaces.
 * - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point
 *   surfaces, this defines the maximum dynamic range used by the content, in
 *   terms of the SDR white point. This defaults to 0.0, which disables tone
 *   mapping.
 * - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator
 *   used when compressing from a surface with high dynamic range to another
 *   with lower dynamic range. Currently this supports "chrome", which uses
 *   the same tone mapping that Chrome uses for HDR content, the form "*=N",
 *   where N is a floating point scale factor applied in linear space, and
 *   "none", which disables tone mapping. This defaults to "chrome".
 * - `SDL_PROP_SURFACE_HOTSPOT_X_NUMBER`: the hotspot pixel offset from the
 *   left edge of the image, if this surface is being used as a cursor.
 * - `SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the
 *   top edge of the image, if this surface is being used as a cursor.
 *
 * @param surface the SDL_Surface structure to query.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:246 SDL_PropertiesID SDL_GetSurfaceProperties(SDL_Surface *surface);
 */
  getSurfaceProperties: lib.symbols.SDL_GetSurfaceProperties,

/**
 * Set the colorspace used by a surface.
 *
 * Setting the colorspace doesn't change the pixels, only how they are
 * interpreted in color operations.
 *
 * @param surface the SDL_Surface structure to update.
 * @param colorspace an SDL_Colorspace value describing the surface
 *                   colorspace.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetSurfaceColorspace
 *
 * @from SDL_surface.h:272 bool SDL_SetSurfaceColorspace(SDL_Surface *surface, SDL_Colorspace colorspace);
 */
  setSurfaceColorspace: lib.symbols.SDL_SetSurfaceColorspace,

/**
 * Get the colorspace used by a surface.
 *
 * The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point
 * formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for
 * other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.
 *
 * @param surface the SDL_Surface structure to query.
 * @returns the colorspace used by the surface, or SDL_COLORSPACE_UNKNOWN if
 *          the surface is NULL.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetSurfaceColorspace
 *
 * @from SDL_surface.h:291 SDL_Colorspace SDL_GetSurfaceColorspace(SDL_Surface *surface);
 */
  getSurfaceColorspace: lib.symbols.SDL_GetSurfaceColorspace,

/**
 * Create a palette and associate it with a surface.
 *
 * This function creates a palette compatible with the provided surface. The
 * palette is then returned for you to modify, and the surface will
 * automatically use the new palette in future operations. You do not need to
 * destroy the returned palette, it will be freed when the reference count
 * reaches 0, usually when the surface is destroyed.
 *
 * Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or
 * SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as
 * white and 1 as black. Other surfaces will get a palette initialized with
 * white in every entry.
 *
 * If this function is called for a surface that already has a palette, a new
 * palette will be created to replace it.
 *
 * @param surface the SDL_Surface structure to update.
 * @returns a new SDL_Palette structure on success or NULL on failure (e.g. if
 *          the surface didn't have an index format); call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetPaletteColors
 *
 * @from SDL_surface.h:321 SDL_Palette * SDL_CreateSurfacePalette(SDL_Surface *surface);
 */
  createSurfacePalette: lib.symbols.SDL_CreateSurfacePalette,

/**
 * Set the palette used by a surface.
 *
 * A single palette can be shared with many surfaces.
 *
 * @param surface the SDL_Surface structure to update.
 * @param palette the SDL_Palette structure to use.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreatePalette
 * @sa SDL_GetSurfacePalette
 *
 * @from SDL_surface.h:340 bool SDL_SetSurfacePalette(SDL_Surface *surface, SDL_Palette *palette);
 */
  setSurfacePalette: lib.symbols.SDL_SetSurfacePalette,

/**
 * Get the palette used by a surface.
 *
 * @param surface the SDL_Surface structure to query.
 * @returns a pointer to the palette used by the surface, or NULL if there is
 *          no palette used.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetSurfacePalette
 *
 * @from SDL_surface.h:355 SDL_Palette * SDL_GetSurfacePalette(SDL_Surface *surface);
 */
  getSurfacePalette: lib.symbols.SDL_GetSurfacePalette,

/**
 * Add an alternate version of a surface.
 *
 * This function adds an alternate version of this surface, usually used for
 * content with high DPI representations like cursors or icons. The size,
 * format, and content do not need to match the original surface, and these
 * alternate versions will not be updated when the original surface changes.
 *
 * This function adds a reference to the alternate version, so you should call
 * SDL_DestroySurface() on the image after this call.
 *
 * @param surface the SDL_Surface structure to update.
 * @param image a pointer to an alternate SDL_Surface to associate with this
 *              surface.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RemoveSurfaceAlternateImages
 * @sa SDL_GetSurfaceImages
 * @sa SDL_SurfaceHasAlternateImages
 *
 * @from SDL_surface.h:382 bool SDL_AddSurfaceAlternateImage(SDL_Surface *surface, SDL_Surface *image);
 */
  addSurfaceAlternateImage: lib.symbols.SDL_AddSurfaceAlternateImage,

/**
 * Return whether a surface has alternate versions available.
 *
 * @param surface the SDL_Surface structure to query.
 * @returns true if alternate versions are available or false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddSurfaceAlternateImage
 * @sa SDL_RemoveSurfaceAlternateImages
 * @sa SDL_GetSurfaceImages
 *
 * @from SDL_surface.h:398 bool SDL_SurfaceHasAlternateImages(SDL_Surface *surface);
 */
  surfaceHasAlternateImages: lib.symbols.SDL_SurfaceHasAlternateImages,

/**
 * Get an array including all versions of a surface.
 *
 * This returns all versions of a surface, with the surface being queried as
 * the first element in the returned array.
 *
 * Freeing the array of surfaces does not affect the surfaces in the array.
 * They are still referenced by the surface being queried and will be cleaned
 * up normally.
 *
 * @param surface the SDL_Surface structure to query.
 * @param count a pointer filled in with the number of surface pointers
 *              returned, may be NULL.
 * @returns a NULL terminated array of SDL_Surface pointers or NULL on
 *          failure; call SDL_GetError() for more information. This should be
 *          freed with SDL_free() when it is no longer needed.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddSurfaceAlternateImage
 * @sa SDL_RemoveSurfaceAlternateImages
 * @sa SDL_SurfaceHasAlternateImages
 *
 * @from SDL_surface.h:425 SDL_Surface ** SDL_GetSurfaceImages(SDL_Surface *surface, int *count);
 */
  getSurfaceImages: lib.symbols.SDL_GetSurfaceImages,

/**
 * Remove all alternate versions of a surface.
 *
 * This function removes a reference from all the alternative versions,
 * destroying them if this is the last reference to them.
 *
 * @param surface the SDL_Surface structure to update.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddSurfaceAlternateImage
 * @sa SDL_GetSurfaceImages
 * @sa SDL_SurfaceHasAlternateImages
 *
 * @from SDL_surface.h:443 void SDL_RemoveSurfaceAlternateImages(SDL_Surface *surface);
 */
  removeSurfaceAlternateImages: lib.symbols.SDL_RemoveSurfaceAlternateImages,

/**
 * Set up a surface for directly accessing the pixels.
 *
 * Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
 * and read from `surface->pixels`, using the pixel format stored in
 * `surface->format`. Once you are done accessing the surface, you should use
 * SDL_UnlockSurface() to release it.
 *
 * Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
 * 0, then you can read and write to the surface at any time, and the pixel
 * format of the surface will not change.
 *
 * @param surface the SDL_Surface structure to be locked.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe. The locking referred to by
 *               this function is making the pixels available for direct
 *               access, not thread-safe locking.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_MUSTLOCK
 * @sa SDL_UnlockSurface
 *
 * @from SDL_surface.h:470 bool SDL_LockSurface(SDL_Surface *surface);
 */
  lockSurface: lib.symbols.SDL_LockSurface,

/**
 * Release a surface after directly accessing the pixels.
 *
 * @param surface the SDL_Surface structure to be unlocked.
 *
 * @threadsafety This function is not thread safe. The locking referred to by
 *               this function is making the pixels available for direct
 *               access, not thread-safe locking.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LockSurface
 *
 * @from SDL_surface.h:485 void SDL_UnlockSurface(SDL_Surface *surface);
 */
  unlockSurface: lib.symbols.SDL_UnlockSurface,

/**
 * Load a BMP image from a seekable SDL data stream.
 *
 * The new surface should be freed with SDL_DestroySurface(). Not doing so
 * will result in a memory leak.
 *
 * @param src the data stream for the surface.
 * @param closeio if true, calls SDL_CloseIO() on `src` before returning, even
 *                in the case of an error.
 * @returns a pointer to a new SDL_Surface structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroySurface
 * @sa SDL_LoadBMP
 * @sa SDL_SaveBMP_IO
 *
 * @from SDL_surface.h:507 SDL_Surface * SDL_LoadBMP_IO(SDL_IOStream *src, bool closeio);
 */
  loadBmpIo: lib.symbols.SDL_LoadBMP_IO,

/**
 * Load a BMP image from a file.
 *
 * The new surface should be freed with SDL_DestroySurface(). Not doing so
 * will result in a memory leak.
 *
 * @param file the BMP file to load.
 * @returns a pointer to a new SDL_Surface structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroySurface
 * @sa SDL_LoadBMP_IO
 * @sa SDL_SaveBMP
 *
 * @from SDL_surface.h:527 SDL_Surface * SDL_LoadBMP(const char *file);
 */
  loadBmp: lib.symbols.SDL_LoadBMP,

/**
 * Save a surface to a seekable SDL data stream in BMP format.
 *
 * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 * BMP directly. Other RGB formats with 8-bit or higher get converted to a
 * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 * not supported.
 *
 * @param surface the SDL_Surface structure containing the image to be saved.
 * @param dst a data stream to save to.
 * @param closeio if true, calls SDL_CloseIO() on `dst` before returning, even
 *                in the case of an error.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LoadBMP_IO
 * @sa SDL_SaveBMP
 *
 * @from SDL_surface.h:552 bool SDL_SaveBMP_IO(SDL_Surface *surface, SDL_IOStream *dst, bool closeio);
 */
  saveBmpIo: lib.symbols.SDL_SaveBMP_IO,

/**
 * Save a surface to a file.
 *
 * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 * BMP directly. Other RGB formats with 8-bit or higher get converted to a
 * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 * not supported.
 *
 * @param surface the SDL_Surface structure containing the image to be saved.
 * @param file a file to save to.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_LoadBMP
 * @sa SDL_SaveBMP_IO
 *
 * @from SDL_surface.h:575 bool SDL_SaveBMP(SDL_Surface *surface, const char *file);
 */
  saveBmp: lib.symbols.SDL_SaveBMP,

/**
 * Set the RLE acceleration hint for a surface.
 *
 * If RLE is enabled, color key and alpha blending blits are much faster, but
 * the surface must be locked before directly accessing the pixels.
 *
 * @param surface the SDL_Surface structure to optimize.
 * @param enabled true to enable RLE acceleration, false to disable it.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BlitSurface
 * @sa SDL_LockSurface
 * @sa SDL_UnlockSurface
 *
 * @from SDL_surface.h:596 bool SDL_SetSurfaceRLE(SDL_Surface *surface, bool enabled);
 */
  setSurfaceRle: lib.symbols.SDL_SetSurfaceRLE,

/**
 * Returns whether the surface is RLE enabled.
 *
 * It is safe to pass a NULL `surface` here; it will return false.
 *
 * @param surface the SDL_Surface structure to query.
 * @returns true if the surface is RLE enabled, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetSurfaceRLE
 *
 * @from SDL_surface.h:612 bool SDL_SurfaceHasRLE(SDL_Surface *surface);
 */
  surfaceHasRle: lib.symbols.SDL_SurfaceHasRLE,

/**
 * Set the color key (transparent pixel) in a surface.
 *
 * The color key defines a pixel value that will be treated as transparent in
 * a blit. For example, one can use this to specify that cyan pixels should be
 * considered transparent, and therefore not rendered.
 *
 * It is a pixel of the format used by the surface, as generated by
 * SDL_MapRGB().
 *
 * @param surface the SDL_Surface structure to update.
 * @param enabled true to enable color key, false to disable color key.
 * @param key the transparent pixel.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetSurfaceColorKey
 * @sa SDL_SetSurfaceRLE
 * @sa SDL_SurfaceHasColorKey
 *
 * @from SDL_surface.h:638 bool SDL_SetSurfaceColorKey(SDL_Surface *surface, bool enabled, Uint32 key);
 */
  setSurfaceColorKey: lib.symbols.SDL_SetSurfaceColorKey,

/**
 * Returns whether the surface has a color key.
 *
 * It is safe to pass a NULL `surface` here; it will return false.
 *
 * @param surface the SDL_Surface structure to query.
 * @returns true if the surface has a color key, false otherwise.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetSurfaceColorKey
 * @sa SDL_GetSurfaceColorKey
 *
 * @from SDL_surface.h:655 bool SDL_SurfaceHasColorKey(SDL_Surface *surface);
 */
  surfaceHasColorKey: lib.symbols.SDL_SurfaceHasColorKey,

/**
 * Get the color key (transparent pixel) for a surface.
 *
 * The color key is a pixel of the format used by the surface, as generated by
 * SDL_MapRGB().
 *
 * If the surface doesn't have color key enabled this function returns false.
 *
 * @param surface the SDL_Surface structure to query.
 * @param key a pointer filled in with the transparent pixel.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetSurfaceColorKey
 * @sa SDL_SurfaceHasColorKey
 *
 * @from SDL_surface.h:677 bool SDL_GetSurfaceColorKey(SDL_Surface *surface, Uint32 *key);
 */
  getSurfaceColorKey: lib.symbols.SDL_GetSurfaceColorKey,

/**
 * Set an additional color value multiplied into blit operations.
 *
 * When this surface is blitted, during the blit operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * (color / 255)`
 *
 * @param surface the SDL_Surface structure to update.
 * @param r the red color value multiplied into blit operations.
 * @param g the green color value multiplied into blit operations.
 * @param b the blue color value multiplied into blit operations.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetSurfaceColorMod
 * @sa SDL_SetSurfaceAlphaMod
 *
 * @from SDL_surface.h:702 bool SDL_SetSurfaceColorMod(SDL_Surface *surface, Uint8 r, Uint8 g, Uint8 b);
 */
  setSurfaceColorMod: lib.symbols.SDL_SetSurfaceColorMod,

/**
 * Get the additional color value multiplied into blit operations.
 *
 * @param surface the SDL_Surface structure to query.
 * @param r a pointer filled in with the current red color value.
 * @param g a pointer filled in with the current green color value.
 * @param b a pointer filled in with the current blue color value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetSurfaceAlphaMod
 * @sa SDL_SetSurfaceColorMod
 *
 * @from SDL_surface.h:722 bool SDL_GetSurfaceColorMod(SDL_Surface *surface, Uint8 *r, Uint8 *g, Uint8 *b);
 */
  getSurfaceColorMod: lib.symbols.SDL_GetSurfaceColorMod,

/**
 * Set an additional alpha value used in blit operations.
 *
 * When this surface is blitted, during the blit operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * (alpha / 255)`
 *
 * @param surface the SDL_Surface structure to update.
 * @param alpha the alpha value multiplied into blit operations.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetSurfaceAlphaMod
 * @sa SDL_SetSurfaceColorMod
 *
 * @from SDL_surface.h:744 bool SDL_SetSurfaceAlphaMod(SDL_Surface *surface, Uint8 alpha);
 */
  setSurfaceAlphaMod: lib.symbols.SDL_SetSurfaceAlphaMod,

/**
 * Get the additional alpha value used in blit operations.
 *
 * @param surface the SDL_Surface structure to query.
 * @param alpha a pointer filled in with the current alpha value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetSurfaceColorMod
 * @sa SDL_SetSurfaceAlphaMod
 *
 * @from SDL_surface.h:761 bool SDL_GetSurfaceAlphaMod(SDL_Surface *surface, Uint8 *alpha);
 */
  getSurfaceAlphaMod: lib.symbols.SDL_GetSurfaceAlphaMod,

/**
 * Set the blend mode used for blit operations.
 *
 * To copy a surface to another surface (or texture) without blending with the
 * existing data, the blendmode of the SOURCE surface should be set to
 * `SDL_BLENDMODE_NONE`.
 *
 * @param surface the SDL_Surface structure to update.
 * @param blendMode the SDL_BlendMode to use for blit blending.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetSurfaceBlendMode
 *
 * @from SDL_surface.h:781 bool SDL_SetSurfaceBlendMode(SDL_Surface *surface, SDL_BlendMode blendMode);
 */
  setSurfaceBlendMode: lib.symbols.SDL_SetSurfaceBlendMode,

/**
 * Get the blend mode used for blit operations.
 *
 * @param surface the SDL_Surface structure to query.
 * @param blendMode a pointer filled in with the current SDL_BlendMode.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetSurfaceBlendMode
 *
 * @from SDL_surface.h:797 bool SDL_GetSurfaceBlendMode(SDL_Surface *surface, SDL_BlendMode *blendMode);
 */
  getSurfaceBlendMode: lib.symbols.SDL_GetSurfaceBlendMode,

/**
 * Set the clipping rectangle for a surface.
 *
 * When `surface` is the destination of a blit, only the area within the clip
 * rectangle is drawn into.
 *
 * Note that blits are automatically clipped to the edges of the source and
 * destination surfaces.
 *
 * @param surface the SDL_Surface structure to be clipped.
 * @param rect the SDL_Rect structure representing the clipping rectangle, or
 *             NULL to disable clipping.
 * @returns true if the rectangle intersects the surface, otherwise false and
 *          blits will be completely clipped.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetSurfaceClipRect
 *
 * @from SDL_surface.h:820 bool SDL_SetSurfaceClipRect(SDL_Surface *surface, const SDL_Rect *rect);
 */
  setSurfaceClipRect: lib.symbols.SDL_SetSurfaceClipRect,

/**
 * Get the clipping rectangle for a surface.
 *
 * When `surface` is the destination of a blit, only the area within the clip
 * rectangle is drawn into.
 *
 * @param surface the SDL_Surface structure representing the surface to be
 *                clipped.
 * @param rect an SDL_Rect structure filled in with the clipping rectangle for
 *             the surface.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetSurfaceClipRect
 *
 * @from SDL_surface.h:841 bool SDL_GetSurfaceClipRect(SDL_Surface *surface, SDL_Rect *rect);
 */
  getSurfaceClipRect: lib.symbols.SDL_GetSurfaceClipRect,

/**
 * Flip a surface vertically or horizontally.
 *
 * @param surface the surface to flip.
 * @param flip the direction to flip.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:855 bool SDL_FlipSurface(SDL_Surface *surface, SDL_FlipMode flip);
 */
  flipSurface: lib.symbols.SDL_FlipSurface,

/**
 * Creates a new surface identical to the existing surface.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * The returned surface should be freed with SDL_DestroySurface().
 *
 * @param surface the surface to duplicate.
 * @returns a copy of the surface or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroySurface
 *
 * @from SDL_surface.h:875 SDL_Surface * SDL_DuplicateSurface(SDL_Surface *surface);
 */
  duplicateSurface: lib.symbols.SDL_DuplicateSurface,

/**
 * Creates a new surface identical to the existing surface, scaled to the
 * desired size.
 *
 * The returned surface should be freed with SDL_DestroySurface().
 *
 * @param surface the surface to duplicate and scale.
 * @param width the width of the new surface.
 * @param height the height of the new surface.
 * @param scaleMode the SDL_ScaleMode to be used.
 * @returns a copy of the surface or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroySurface
 *
 * @from SDL_surface.h:896 SDL_Surface * SDL_ScaleSurface(SDL_Surface *surface, int width, int height, SDL_ScaleMode scaleMode);
 */
  scaleSurface: lib.symbols.SDL_ScaleSurface,

/**
 * Copy an existing surface to a new surface of the specified format.
 *
 * This function is used to optimize images for faster *repeat* blitting. This
 * is accomplished by converting the original and storing the result as a new
 * surface. The new, optimized surface can then be used as the source for
 * future blits, making them faster.
 *
 * If you are converting to an indexed surface and want to map colors to a
 * palette, you can use SDL_ConvertSurfaceAndColorspace() instead.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * @param surface the existing SDL_Surface structure to convert.
 * @param format the new pixel format.
 * @returns the new SDL_Surface structure that is created or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ConvertSurfaceAndColorspace
 * @sa SDL_DestroySurface
 *
 * @from SDL_surface.h:924 SDL_Surface * SDL_ConvertSurface(SDL_Surface *surface, SDL_PixelFormat format);
 */
  convertSurface: lib.symbols.SDL_ConvertSurface,

/**
 * Copy an existing surface to a new surface of the specified format and
 * colorspace.
 *
 * This function converts an existing surface to a new format and colorspace
 * and returns the new surface. This will perform any pixel format and
 * colorspace conversion needed.
 *
 * If the original surface has alternate images, the new surface will have a
 * reference to them as well.
 *
 * @param surface the existing SDL_Surface structure to convert.
 * @param format the new pixel format.
 * @param palette an optional palette to use for indexed formats, may be NULL.
 * @param colorspace the new colorspace.
 * @param props an SDL_PropertiesID with additional color properties, or 0.
 * @returns the new SDL_Surface structure that is created or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ConvertSurface
 * @sa SDL_DestroySurface
 *
 * @from SDL_surface.h:952 SDL_Surface * SDL_ConvertSurfaceAndColorspace(SDL_Surface *surface, SDL_PixelFormat format, SDL_Palette *palette, SDL_Colorspace colorspace, SDL_PropertiesID props);
 */
  convertSurfaceAndColorspace: lib.symbols.SDL_ConvertSurfaceAndColorspace,

/**
 * Copy a block of pixels of one format to another format.
 *
 * @param width the width of the block to copy, in pixels.
 * @param height the height of the block to copy, in pixels.
 * @param src_format an SDL_PixelFormat value of the `src` pixels format.
 * @param src a pointer to the source pixels.
 * @param src_pitch the pitch of the source pixels, in bytes.
 * @param dst_format an SDL_PixelFormat value of the `dst` pixels format.
 * @param dst a pointer to be filled in with new pixel data.
 * @param dst_pitch the pitch of the destination pixels, in bytes.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety The same destination pixels should not be used from two
 *               threads at once. It is safe to use the same source pixels
 *               from multiple threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ConvertPixelsAndColorspace
 *
 * @from SDL_surface.h:976 bool SDL_ConvertPixels(int width, int height, SDL_PixelFormat src_format, const void *src, int src_pitch, SDL_PixelFormat dst_format, void *dst, int dst_pitch);
 */
  convertPixels: lib.symbols.SDL_ConvertPixels,

/**
 * Copy a block of pixels of one format and colorspace to another format and
 * colorspace.
 *
 * @param width the width of the block to copy, in pixels.
 * @param height the height of the block to copy, in pixels.
 * @param src_format an SDL_PixelFormat value of the `src` pixels format.
 * @param src_colorspace an SDL_Colorspace value describing the colorspace of
 *                       the `src` pixels.
 * @param src_properties an SDL_PropertiesID with additional source color
 *                       properties, or 0.
 * @param src a pointer to the source pixels.
 * @param src_pitch the pitch of the source pixels, in bytes.
 * @param dst_format an SDL_PixelFormat value of the `dst` pixels format.
 * @param dst_colorspace an SDL_Colorspace value describing the colorspace of
 *                       the `dst` pixels.
 * @param dst_properties an SDL_PropertiesID with additional destination color
 *                       properties, or 0.
 * @param dst a pointer to be filled in with new pixel data.
 * @param dst_pitch the pitch of the destination pixels, in bytes.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety The same destination pixels should not be used from two
 *               threads at once. It is safe to use the same source pixels
 *               from multiple threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ConvertPixels
 *
 * @from SDL_surface.h:1009 bool SDL_ConvertPixelsAndColorspace(int width, int height, SDL_PixelFormat src_format, SDL_Colorspace src_colorspace, SDL_PropertiesID src_properties, const void *src, int src_pitch, SDL_PixelFormat dst_format, SDL_Colorspace dst_colorspace, SDL_PropertiesID dst_properties, void *dst, int dst_pitch);
 */
  convertPixelsAndColorspace: lib.symbols.SDL_ConvertPixelsAndColorspace,

/**
 * Premultiply the alpha on a block of pixels.
 *
 * This is safe to use with src == dst, but not for other overlapping areas.
 *
 * @param width the width of the block to convert, in pixels.
 * @param height the height of the block to convert, in pixels.
 * @param src_format an SDL_PixelFormat value of the `src` pixels format.
 * @param src a pointer to the source pixels.
 * @param src_pitch the pitch of the source pixels, in bytes.
 * @param dst_format an SDL_PixelFormat value of the `dst` pixels format.
 * @param dst a pointer to be filled in with premultiplied pixel data.
 * @param dst_pitch the pitch of the destination pixels, in bytes.
 * @param linear true to convert from sRGB to linear space for the alpha
 *               multiplication, false to do multiplication in sRGB space.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety The same destination pixels should not be used from two
 *               threads at once. It is safe to use the same source pixels
 *               from multiple threads.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:1035 bool SDL_PremultiplyAlpha(int width, int height, SDL_PixelFormat src_format, const void *src, int src_pitch, SDL_PixelFormat dst_format, void *dst, int dst_pitch, bool linear);
 */
  premultiplyAlpha: lib.symbols.SDL_PremultiplyAlpha,

/**
 * Premultiply the alpha in a surface.
 *
 * This is safe to use with src == dst, but not for other overlapping areas.
 *
 * @param surface the surface to modify.
 * @param linear true to convert from sRGB to linear space for the alpha
 *               multiplication, false to do multiplication in sRGB space.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:1052 bool SDL_PremultiplySurfaceAlpha(SDL_Surface *surface, bool linear);
 */
  premultiplySurfaceAlpha: lib.symbols.SDL_PremultiplySurfaceAlpha,

/**
 * Clear a surface with a specific color, with floating point precision.
 *
 * This function handles all surface formats, and ignores any clip rectangle.
 *
 * If the surface is YUV, the color is assumed to be in the sRGB colorspace,
 * otherwise the color is assumed to be in the colorspace of the suface.
 *
 * @param surface the SDL_Surface to clear.
 * @param r the red component of the pixel, normally in the range 0-1.
 * @param g the green component of the pixel, normally in the range 0-1.
 * @param b the blue component of the pixel, normally in the range 0-1.
 * @param a the alpha component of the pixel, normally in the range 0-1.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:1074 bool SDL_ClearSurface(SDL_Surface *surface, float r, float g, float b, float a);
 */
  clearSurface: lib.symbols.SDL_ClearSurface,

/**
 * Perform a fast fill of a rectangle with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * SDL_SetSurfaceClipRect()), then this function will fill based on the
 * intersection of the clip rectangle and `rect`.
 *
 * @param dst the SDL_Surface structure that is the drawing target.
 * @param rect the SDL_Rect structure representing the rectangle to fill, or
 *             NULL to fill the entire surface.
 * @param color the color to fill with.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_FillSurfaceRects
 *
 * @from SDL_surface.h:1101 bool SDL_FillSurfaceRect(SDL_Surface *dst, const SDL_Rect *rect, Uint32 color);
 */
  fillSurfaceRect: lib.symbols.SDL_FillSurfaceRect,

/**
 * Perform a fast fill of a set of rectangles with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * SDL_SetSurfaceClipRect()), then this function will fill based on the
 * intersection of the clip rectangle and `rect`.
 *
 * @param dst the SDL_Surface structure that is the drawing target.
 * @param rects an array of SDL_Rects representing the rectangles to fill.
 * @param count the number of rectangles in the array.
 * @param color the color to fill with.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_FillSurfaceRect
 *
 * @from SDL_surface.h:1128 bool SDL_FillSurfaceRects(SDL_Surface *dst, const SDL_Rect *rects, int count, Uint32 color);
 */
  fillSurfaceRects: lib.symbols.SDL_FillSurfaceRects,

/**
 * Performs a fast blit from the source surface to the destination surface
 * with clipping.
 *
 * If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or
 * `dst`) is copied while ensuring clipping to `dst->clip_rect`.
 *
 * The final blit rectangles are saved in `srcrect` and `dstrect` after all
 * clipping is performed.
 *
 * The blit function should not be called on a locked surface.
 *
 * The blit semantics for surfaces with and without blending and colorkey are
 * defined as follows:
 *
 * ```
 *    RGBA->RGB:
 *      Source surface blend mode set to SDL_BLENDMODE_BLEND:
 *       alpha-blend (using the source alpha-channel and per-surface alpha)
 *       SDL_SRCCOLORKEY ignored.
 *     Source surface blend mode set to SDL_BLENDMODE_NONE:
 *       copy RGB.
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       RGB values of the source color key, ignoring alpha in the
 *       comparison.
 *
 *   RGB->RGBA:
 *     Source surface blend mode set to SDL_BLENDMODE_BLEND:
 *       alpha-blend (using the source per-surface alpha)
 *     Source surface blend mode set to SDL_BLENDMODE_NONE:
 *       copy RGB, set destination alpha to source per-surface alpha value.
 *     both:
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       source color key.
 *
 *   RGBA->RGBA:
 *     Source surface blend mode set to SDL_BLENDMODE_BLEND:
 *       alpha-blend (using the source alpha-channel and per-surface alpha)
 *       SDL_SRCCOLORKEY ignored.
 *     Source surface blend mode set to SDL_BLENDMODE_NONE:
 *       copy all of RGBA to the destination.
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       RGB values of the source color key, ignoring alpha in the
 *       comparison.
 *
 *   RGB->RGB:
 *     Source surface blend mode set to SDL_BLENDMODE_BLEND:
 *       alpha-blend (using the source per-surface alpha)
 *     Source surface blend mode set to SDL_BLENDMODE_NONE:
 *       copy RGB.
 *     both:
 *       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
 *       source color key.
 * ```
 *
 * @param src the SDL_Surface structure to be copied from.
 * @param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface.
 * @param dst the SDL_Surface structure that is the blit target.
 * @param dstrect the SDL_Rect structure representing the x and y position in
 *                the destination surface, or NULL for (0,0). The width and
 *                height are ignored, and are copied from `srcrect`. If you
 *                want a specific width and height, you should use
 *                SDL_BlitSurfaceScaled().
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BlitSurfaceScaled
 *
 * @from SDL_surface.h:1204 bool SDL_BlitSurface(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect);
 */
  blitSurface: lib.symbols.SDL_BlitSurface,

/**
 * Perform low-level surface blitting only.
 *
 * This is a semi-private blit function and it performs low-level surface
 * blitting, assuming the input rectangles have already been clipped.
 *
 * @param src the SDL_Surface structure to be copied from.
 * @param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, may not be NULL.
 * @param dst the SDL_Surface structure that is the blit target.
 * @param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, may not be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BlitSurface
 *
 * @from SDL_surface.h:1228 bool SDL_BlitSurfaceUnchecked(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect);
 */
  blitSurfaceUnchecked: lib.symbols.SDL_BlitSurfaceUnchecked,

/**
 * Perform a scaled blit to a destination surface, which may be of a different
 * format.
 *
 * @param src the SDL_Surface structure to be copied from.
 * @param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface.
 * @param dst the SDL_Surface structure that is the blit target.
 * @param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, or NULL to fill the entire
 *                destination surface.
 * @param scaleMode the SDL_ScaleMode to be used.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BlitSurface
 *
 * @from SDL_surface.h:1252 bool SDL_BlitSurfaceScaled(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect, SDL_ScaleMode scaleMode);
 */
  blitSurfaceScaled: lib.symbols.SDL_BlitSurfaceScaled,

/**
 * Perform low-level surface scaled blitting only.
 *
 * This is a semi-private function and it performs low-level surface blitting,
 * assuming the input rectangles have already been clipped.
 *
 * @param src the SDL_Surface structure to be copied from.
 * @param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, may not be NULL.
 * @param dst the SDL_Surface structure that is the blit target.
 * @param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, may not be NULL.
 * @param scaleMode the SDL_ScaleMode to be used.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BlitSurfaceScaled
 *
 * @from SDL_surface.h:1277 bool SDL_BlitSurfaceUncheckedScaled(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect, SDL_ScaleMode scaleMode);
 */
  blitSurfaceUncheckedScaled: lib.symbols.SDL_BlitSurfaceUncheckedScaled,

/**
 * Perform a stretched pixel copy from one surface to another.
 *
 * @param src the SDL_Surface structure to be copied from.
 * @param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, may not be NULL.
 * @param dst the SDL_Surface structure that is the blit target.
 * @param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, may not be NULL.
 * @param scaleMode the SDL_ScaleMode to be used.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.4.0.
 *
 * @sa SDL_BlitSurfaceScaled
 *
 * @from SDL_surface.h:1299 bool SDL_StretchSurface(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect, SDL_ScaleMode scaleMode);
 */
  stretchSurface: lib.symbols.SDL_StretchSurface,

/**
 * Perform a tiled blit to a destination surface, which may be of a different
 * format.
 *
 * The pixels in `srcrect` will be repeated as many times as needed to
 * completely fill `dstrect`.
 *
 * @param src the SDL_Surface structure to be copied from.
 * @param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface.
 * @param dst the SDL_Surface structure that is the blit target.
 * @param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, or NULL to fill the entire surface.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BlitSurface
 *
 * @from SDL_surface.h:1324 bool SDL_BlitSurfaceTiled(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect);
 */
  blitSurfaceTiled: lib.symbols.SDL_BlitSurfaceTiled,

/**
 * Perform a scaled and tiled blit to a destination surface, which may be of a
 * different format.
 *
 * The pixels in `srcrect` will be scaled and repeated as many times as needed
 * to completely fill `dstrect`.
 *
 * @param src the SDL_Surface structure to be copied from.
 * @param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface.
 * @param scale the scale used to transform srcrect into the destination
 *              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
 *              64x64 tiles.
 * @param scaleMode scale algorithm to be used.
 * @param dst the SDL_Surface structure that is the blit target.
 * @param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, or NULL to fill the entire surface.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BlitSurface
 *
 * @from SDL_surface.h:1353 bool SDL_BlitSurfaceTiledWithScale(SDL_Surface *src, const SDL_Rect *srcrect, float scale, SDL_ScaleMode scaleMode, SDL_Surface *dst, const SDL_Rect *dstrect);
 */
  blitSurfaceTiledWithScale: lib.symbols.SDL_BlitSurfaceTiledWithScale,

/**
 * Perform a scaled blit using the 9-grid algorithm to a destination surface,
 * which may be of a different format.
 *
 * The pixels in the source surface are split into a 3x3 grid, using the
 * different corner sizes for each corner, and the sides and center making up
 * the remaining pixels. The corners are then scaled using `scale` and fit
 * into the corners of the destination rectangle. The sides and center are
 * then stretched into place to cover the remaining destination rectangle.
 *
 * @param src the SDL_Surface structure to be copied from.
 * @param srcrect the SDL_Rect structure representing the rectangle to be used
 *                for the 9-grid, or NULL to use the entire surface.
 * @param left_width the width, in pixels, of the left corners in `srcrect`.
 * @param right_width the width, in pixels, of the right corners in `srcrect`.
 * @param top_height the height, in pixels, of the top corners in `srcrect`.
 * @param bottom_height the height, in pixels, of the bottom corners in
 *                      `srcrect`.
 * @param scale the scale used to transform the corner of `srcrect` into the
 *              corner of `dstrect`, or 0.0f for an unscaled blit.
 * @param scaleMode scale algorithm to be used.
 * @param dst the SDL_Surface structure that is the blit target.
 * @param dstrect the SDL_Rect structure representing the target rectangle in
 *                the destination surface, or NULL to fill the entire surface.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety Only one thread should be using the `src` and `dst` surfaces
 *               at any given time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_BlitSurface
 *
 * @from SDL_surface.h:1389 bool SDL_BlitSurface9Grid(SDL_Surface *src, const SDL_Rect *srcrect, int left_width, int right_width, int top_height, int bottom_height, float scale, SDL_ScaleMode scaleMode, SDL_Surface *dst, const SDL_Rect *dstrect);
 */
  blitSurface9Grid: lib.symbols.SDL_BlitSurface9Grid,

/**
 * Map an RGB triple to an opaque pixel value for a surface.
 *
 * This function maps the RGB color value to the specified pixel format and
 * returns the pixel value best approximating the given RGB color value for
 * the given pixel format.
 *
 * If the surface has a palette, the index of the closest matching color in
 * the palette will be returned.
 *
 * If the surface pixel format has an alpha component it will be returned as
 * all 1 bits (fully opaque).
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * @param surface the surface to use for the pixel format and palette.
 * @param r the red component of the pixel in the range 0-255.
 * @param g the green component of the pixel in the range 0-255.
 * @param b the blue component of the pixel in the range 0-255.
 * @returns a pixel value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_MapSurfaceRGBA
 *
 * @from SDL_surface.h:1421 Uint32 SDL_MapSurfaceRGB(SDL_Surface *surface, Uint8 r, Uint8 g, Uint8 b);
 */
  mapSurfaceRgb: lib.symbols.SDL_MapSurfaceRGB,

/**
 * Map an RGBA quadruple to a pixel value for a surface.
 *
 * This function maps the RGBA color value to the specified pixel format and
 * returns the pixel value best approximating the given RGBA color value for
 * the given pixel format.
 *
 * If the surface pixel format has no alpha component the alpha value will be
 * ignored (as it will be in formats with a palette).
 *
 * If the surface has a palette, the index of the closest matching color in
 * the palette will be returned.
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * @param surface the surface to use for the pixel format and palette.
 * @param r the red component of the pixel in the range 0-255.
 * @param g the green component of the pixel in the range 0-255.
 * @param b the blue component of the pixel in the range 0-255.
 * @param a the alpha component of the pixel in the range 0-255.
 * @returns a pixel value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_MapSurfaceRGB
 *
 * @from SDL_surface.h:1454 Uint32 SDL_MapSurfaceRGBA(SDL_Surface *surface, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
 */
  mapSurfaceRgba: lib.symbols.SDL_MapSurfaceRGBA,

/**
 * Retrieves a single pixel from a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * Like SDL_GetRGBA, this uses the entire 0..255 range when converting color
 * components from pixel formats with less than 8 bits per RGB component.
 *
 * @param surface the surface to read.
 * @param x the horizontal coordinate, 0 <= x < width.
 * @param y the vertical coordinate, 0 <= y < height.
 * @param r a pointer filled in with the red channel, 0-255, or NULL to ignore
 *          this channel.
 * @param g a pointer filled in with the green channel, 0-255, or NULL to
 *          ignore this channel.
 * @param b a pointer filled in with the blue channel, 0-255, or NULL to
 *          ignore this channel.
 * @param a a pointer filled in with the alpha channel, 0-255, or NULL to
 *          ignore this channel.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:1483 bool SDL_ReadSurfacePixel(SDL_Surface *surface, int x, int y, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
 */
  readSurfacePixel: lib.symbols.SDL_ReadSurfacePixel,

/**
 * Retrieves a single pixel from a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * @param surface the surface to read.
 * @param x the horizontal coordinate, 0 <= x < width.
 * @param y the vertical coordinate, 0 <= y < height.
 * @param r a pointer filled in with the red channel, normally in the range
 *          0-1, or NULL to ignore this channel.
 * @param g a pointer filled in with the green channel, normally in the range
 *          0-1, or NULL to ignore this channel.
 * @param b a pointer filled in with the blue channel, normally in the range
 *          0-1, or NULL to ignore this channel.
 * @param a a pointer filled in with the alpha channel, normally in the range
 *          0-1, or NULL to ignore this channel.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:1509 bool SDL_ReadSurfacePixelFloat(SDL_Surface *surface, int x, int y, float *r, float *g, float *b, float *a);
 */
  readSurfacePixelFloat: lib.symbols.SDL_ReadSurfacePixelFloat,

/**
 * Writes a single pixel to a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * Like SDL_MapRGBA, this uses the entire 0..255 range when converting color
 * components from pixel formats with less than 8 bits per RGB component.
 *
 * @param surface the surface to write.
 * @param x the horizontal coordinate, 0 <= x < width.
 * @param y the vertical coordinate, 0 <= y < height.
 * @param r the red channel value, 0-255.
 * @param g the green channel value, 0-255.
 * @param b the blue channel value, 0-255.
 * @param a the alpha channel value, 0-255.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:1534 bool SDL_WriteSurfacePixel(SDL_Surface *surface, int x, int y, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
 */
  writeSurfacePixel: lib.symbols.SDL_WriteSurfacePixel,

/**
 * Writes a single pixel to a surface.
 *
 * This function prioritizes correctness over speed: it is suitable for unit
 * tests, but is not intended for use in a game engine.
 *
 * @param surface the surface to write.
 * @param x the horizontal coordinate, 0 <= x < width.
 * @param y the vertical coordinate, 0 <= y < height.
 * @param r the red channel value, normally in the range 0-1.
 * @param g the green channel value, normally in the range 0-1.
 * @param b the blue channel value, normally in the range 0-1.
 * @param a the alpha channel value, normally in the range 0-1.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_surface.h:1556 bool SDL_WriteSurfacePixelFloat(SDL_Surface *surface, int x, int y, float r, float g, float b, float a);
 */
  writeSurfacePixelFloat: lib.symbols.SDL_WriteSurfacePixelFloat,



/*--- SDL_system ---*/

/**
 * Application sandbox environment.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_system.h:627 SDL_SANDBOX_
 */
  SANDBOX: SDL_system_enums.SDL_Sandbox,



/**
 * Set a callback for every Windows message, run before TranslateMessage().
 *
 * The callback may modify the message, and should return true if the message
 * should continue to be processed, or false to prevent further processing.
 *
 * @param callback the SDL_WindowsMessageHook function to call.
 * @param userdata a pointer to pass to every iteration of `callback`.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_WindowsMessageHook
 * @sa SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP
 *
 * @from SDL_system.h:93 void SDL_SetWindowsMessageHook(SDL_WindowsMessageHook callback, void *userdata);
 */
  setWindowsMessageHook: lib.symbols.SDL_SetWindowsMessageHook,

/**
 * Get the D3D9 adapter index that matches the specified display.
 *
 * The returned adapter index can be passed to `IDirect3D9::CreateDevice` and
 * controls on which monitor a full screen application will appear.
 *
 * @param displayID the instance of the display to query.
 * @returns the D3D9 adapter index on success or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:111 int SDL_GetDirect3D9AdapterIndex(SDL_DisplayID displayID);
 */
  getDirect3D9AdapterIndex: lib.symbols.SDL_GetDirect3D9AdapterIndex,

/**
 * Get the DXGI Adapter and Output indices for the specified display.
 *
 * The DXGI Adapter and Output indices can be passed to `EnumAdapters` and
 * `EnumOutputs` respectively to get the objects required to create a DX10 or
 * DX11 device and swap chain.
 *
 * @param displayID the instance of the display to query.
 * @param adapterIndex a pointer to be filled in with the adapter index.
 * @param outputIndex a pointer to be filled in with the output index.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:128 bool SDL_GetDXGIOutputInfo(SDL_DisplayID displayID, int *adapterIndex, int *outputIndex);
 */
  getDxgiOutputInfo: lib.symbols.SDL_GetDXGIOutputInfo,

/**
 * Set a callback for every X11 event.
 *
 * The callback may modify the event, and should return true if the event
 * should continue to be processed, or false to prevent further processing.
 *
 * @param callback the SDL_X11EventHook function to call.
 * @param userdata a pointer to pass to every iteration of `callback`.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:173 void SDL_SetX11EventHook(SDL_X11EventHook callback, void *userdata);
 */
  setX11EventHook: lib.symbols.SDL_SetX11EventHook,

/**
 * Sets the UNIX nice value for a thread.
 *
 * This uses setpriority() if possible, and RealtimeKit if available.
 *
 * @param threadID the Unix thread ID to change priority of.
 * @param priority the new, Unix-specific, priority value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:190 bool SDL_SetLinuxThreadPriority(Sint64 threadID, int priority);
 */
  /* setLinuxThreadPriority: lib.symbols.SDL_SetLinuxThreadPriority, */

/**
 * Sets the priority (not nice level) and scheduling policy for a thread.
 *
 * This uses setpriority() if possible, and RealtimeKit if available.
 *
 * @param threadID the Unix thread ID to change priority of.
 * @param sdlPriority the new SDL_ThreadPriority value.
 * @param schedPolicy the new scheduling policy (SCHED_FIFO, SCHED_RR,
 *                    SCHED_OTHER, etc...).
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:206 bool SDL_SetLinuxThreadPriorityAndPolicy(Sint64 threadID, int sdlPriority, int schedPolicy);
 */
  /* setLinuxThreadPriorityAndPolicy: lib.symbols.SDL_SetLinuxThreadPriorityAndPolicy, */

/**
 * Use this function to set the animation callback on Apple iOS.
 *
 * The function prototype for `callback` is:
 *
 * ```c
 * void callback(void *callbackParam);
 * ```
 *
 * Where its parameter, `callbackParam`, is what was passed as `callbackParam`
 * to SDL_SetiOSAnimationCallback().
 *
 * This function is only available on Apple iOS.
 *
 * For more information see:
 *
 * https://wiki.libsdl.org/SDL3/README/ios
 *
 * Note that if you use the "main callbacks" instead of a standard C `main`
 * function, you don't have to use this API, as SDL will manage this for you.
 *
 * Details on main callbacks are here:
 *
 * https://wiki.libsdl.org/SDL3/README/main-functions
 *
 * @param window the window for which the animation callback should be set.
 * @param interval the number of frames after which **callback** will be
 *                 called.
 * @param callback the function to call for every frame.
 * @param callbackParam a pointer that is passed to `callback`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetiOSEventPump
 *
 * @from SDL_system.h:270 bool SDL_SetiOSAnimationCallback(SDL_Window *window, int interval, SDL_iOSAnimationCallback callback, void *callbackParam);
 */
  /* setiOsAnimationCallback: lib.symbols.SDL_SetiOSAnimationCallback, */

/**
 * Use this function to enable or disable the SDL event pump on Apple iOS.
 *
 * This function is only available on Apple iOS.
 *
 * @param enabled true to enable the event pump, false to disable it.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetiOSAnimationCallback
 *
 * @from SDL_system.h:283 void SDL_SetiOSEventPump(bool enabled);
 */
  /* setiOsEventPump: lib.symbols.SDL_SetiOSEventPump, */

/**
 * Get the Android Java Native Interface Environment of the current thread.
 *
 * This is the JNIEnv one needs to access the Java virtual machine from native
 * code, and is needed for many Android APIs to be usable from C.
 *
 * The prototype of the function in SDL's code actually declare a void* return
 * type, even if the implementation returns a pointer to a JNIEnv. The
 * rationale being that the SDL headers can avoid including jni.h.
 *
 * @returns a pointer to Java native interface object (JNIEnv) to which the
 *          current thread is attached, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAndroidActivity
 *
 * @from SDL_system.h:313 void * SDL_GetAndroidJNIEnv(void);
 */
  /* getAndroidJniEnv: lib.symbols.SDL_GetAndroidJNIEnv, */

/**
 * Retrieve the Java instance of the Android activity class.
 *
 * The prototype of the function in SDL's code actually declares a void*
 * return type, even if the implementation returns a jobject. The rationale
 * being that the SDL headers can avoid including jni.h.
 *
 * The jobject returned by the function is a local reference and must be
 * released by the caller. See the PushLocalFrame() and PopLocalFrame() or
 * DeleteLocalRef() functions of the Java native interface:
 *
 * https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html
 *
 * @returns the jobject representing the instance of the Activity class of the
 *          Android application, or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAndroidJNIEnv
 *
 * @from SDL_system.h:338 void * SDL_GetAndroidActivity(void);
 */
  /* getAndroidActivity: lib.symbols.SDL_GetAndroidActivity, */

/**
 * Query Android API level of the current device.
 *
 * - API level 35: Android 15 (VANILLA_ICE_CREAM)
 * - API level 34: Android 14 (UPSIDE_DOWN_CAKE)
 * - API level 33: Android 13 (TIRAMISU)
 * - API level 32: Android 12L (S_V2)
 * - API level 31: Android 12 (S)
 * - API level 30: Android 11 (R)
 * - API level 29: Android 10 (Q)
 * - API level 28: Android 9 (P)
 * - API level 27: Android 8.1 (O_MR1)
 * - API level 26: Android 8.0 (O)
 * - API level 25: Android 7.1 (N_MR1)
 * - API level 24: Android 7.0 (N)
 * - API level 23: Android 6.0 (M)
 * - API level 22: Android 5.1 (LOLLIPOP_MR1)
 * - API level 21: Android 5.0 (LOLLIPOP, L)
 * - API level 20: Android 4.4W (KITKAT_WATCH)
 * - API level 19: Android 4.4 (KITKAT)
 * - API level 18: Android 4.3 (JELLY_BEAN_MR2)
 * - API level 17: Android 4.2 (JELLY_BEAN_MR1)
 * - API level 16: Android 4.1 (JELLY_BEAN)
 * - API level 15: Android 4.0.3 (ICE_CREAM_SANDWICH_MR1)
 * - API level 14: Android 4.0 (ICE_CREAM_SANDWICH)
 * - API level 13: Android 3.2 (HONEYCOMB_MR2)
 * - API level 12: Android 3.1 (HONEYCOMB_MR1)
 * - API level 11: Android 3.0 (HONEYCOMB)
 * - API level 10: Android 2.3.3 (GINGERBREAD_MR1)
 *
 * @returns the Android API level.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:374 int SDL_GetAndroidSDKVersion(void);
 */
  /* getAndroidSdkVersion: lib.symbols.SDL_GetAndroidSDKVersion, */

/**
 * Query if the application is running on a Chromebook.
 *
 * @returns true if this is a Chromebook, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:383 bool SDL_IsChromebook(void);
 */
  /* isChromebook: lib.symbols.SDL_IsChromebook, */

/**
 * Query if the application is running on a Samsung DeX docking station.
 *
 * @returns true if this is a DeX docking station, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:392 bool SDL_IsDeXMode(void);
 */
  /* isDeXMode: lib.symbols.SDL_IsDeXMode, */

/**
 * Trigger the Android system back button behavior.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:401 void SDL_SendAndroidBackButton(void);
 */
  /* sendAndroidBackButton: lib.symbols.SDL_SendAndroidBackButton, */

/**
 * Get the path used for internal storage for this Android application.
 *
 * This path is unique to your application and cannot be written to by other
 * applications.
 *
 * Your internal storage path is typically:
 * `/data/data/your.app.package/files`.
 *
 * This is a C wrapper over `android.content.Context.getFilesDir()`:
 *
 * https://developer.android.com/reference/android/content/Context#getFilesDir()
 *
 * @returns the path used for internal storage or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAndroidExternalStoragePath
 * @sa SDL_GetAndroidCachePath
 *
 * @from SDL_system.h:440 const char * SDL_GetAndroidInternalStoragePath(void);
 */
  /* getAndroidInternalStoragePath: lib.symbols.SDL_GetAndroidInternalStoragePath, */

/**
 * Get the current state of external storage for this Android application.
 *
 * The current state of external storage, a bitmask of these values:
 * `SDL_ANDROID_EXTERNAL_STORAGE_READ`, `SDL_ANDROID_EXTERNAL_STORAGE_WRITE`.
 *
 * If external storage is currently unavailable, this will return 0.
 *
 * @returns the current state of external storage, or 0 if external storage is
 *          currently unavailable.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAndroidExternalStoragePath
 *
 * @from SDL_system.h:457 Uint32 SDL_GetAndroidExternalStorageState(void);
 */
  /* getAndroidExternalStorageState: lib.symbols.SDL_GetAndroidExternalStorageState, */

/**
 * Get the path used for external storage for this Android application.
 *
 * This path is unique to your application, but is public and can be written
 * to by other applications.
 *
 * Your external storage path is typically:
 * `/storage/sdcard0/Android/data/your.app.package/files`.
 *
 * This is a C wrapper over `android.content.Context.getExternalFilesDir()`:
 *
 * https://developer.android.com/reference/android/content/Context#getExternalFilesDir()
 *
 * @returns the path used for external storage for this application on success
 *          or NULL on failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAndroidExternalStorageState
 * @sa SDL_GetAndroidInternalStoragePath
 * @sa SDL_GetAndroidCachePath
 *
 * @from SDL_system.h:481 const char * SDL_GetAndroidExternalStoragePath(void);
 */
  /* getAndroidExternalStoragePath: lib.symbols.SDL_GetAndroidExternalStoragePath, */

/**
 * Get the path used for caching data for this Android application.
 *
 * This path is unique to your application, but is public and can be written
 * to by other applications.
 *
 * Your cache path is typically: `/data/data/your.app.package/cache/`.
 *
 * This is a C wrapper over `android.content.Context.getCacheDir()`:
 *
 * https://developer.android.com/reference/android/content/Context#getCacheDir()
 *
 * @returns the path used for caches for this application on success or NULL
 *          on failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetAndroidInternalStoragePath
 * @sa SDL_GetAndroidExternalStoragePath
 *
 * @from SDL_system.h:503 const char * SDL_GetAndroidCachePath(void);
 */
  /* getAndroidCachePath: lib.symbols.SDL_GetAndroidCachePath, */

/**
 * Request permissions at runtime, asynchronously.
 *
 * You do not need to call this for built-in functionality of SDL; recording
 * from a microphone or reading images from a camera, using standard SDL APIs,
 * will manage permission requests for you.
 *
 * This function never blocks. Instead, the app-supplied callback will be
 * called when a decision has been made. This callback may happen on a
 * different thread, and possibly much later, as it might wait on a user to
 * respond to a system dialog. If permission has already been granted for a
 * specific entitlement, the callback will still fire, probably on the current
 * thread and before this function returns.
 *
 * If the request submission fails, this function returns -1 and the callback
 * will NOT be called, but this should only happen in catastrophic conditions,
 * like memory running out. Normally there will be a yes or no to the request
 * through the callback.
 *
 * For the `permission` parameter, choose a value from here:
 *
 * https://developer.android.com/reference/android/Manifest.permission
 *
 * @param permission the permission to request.
 * @param cb the callback to trigger when the request has a response.
 * @param userdata an app-controlled pointer that is passed to the callback.
 * @returns true if the request was submitted, false if there was an error
 *          submitting. The result of the request is only ever reported
 *          through the callback, not this return value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:552 bool SDL_RequestAndroidPermission(const char *permission, SDL_RequestAndroidPermissionCallback cb, void *userdata);
 */
  /* requestAndroidPermission: lib.symbols.SDL_RequestAndroidPermission, */

/**
 * Shows an Android toast notification.
 *
 * Toasts are a sort of lightweight notification that are unique to Android.
 *
 * https://developer.android.com/guide/topics/ui/notifiers/toasts
 *
 * Shows toast in UI thread.
 *
 * For the `gravity` parameter, choose a value from here, or -1 if you don't
 * have a preference:
 *
 * https://developer.android.com/reference/android/view/Gravity
 *
 * @param message text message to be shown.
 * @param duration 0=short, 1=long.
 * @param gravity where the notification should appear on the screen.
 * @param xoffset set this parameter only when gravity >=0.
 * @param yoffset set this parameter only when gravity >=0.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:580 bool SDL_ShowAndroidToast(const char *message, int duration, int gravity, int xoffset, int yoffset);
 */
  /* showAndroidToast: lib.symbols.SDL_ShowAndroidToast, */

/**
 * Send a user command to SDLActivity.
 *
 * Override "boolean onUnhandledMessage(Message msg)" to handle the message.
 *
 * @param command user command that must be greater or equal to 0x8000.
 * @param param user parameter.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:596 bool SDL_SendAndroidMessage(Uint32 command, int param);
 */
  /* sendAndroidMessage: lib.symbols.SDL_SendAndroidMessage, */

/**
 * Query if the current device is a tablet.
 *
 * If SDL can't determine this, it will return false.
 *
 * @returns true if the device is a tablet, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:609 bool SDL_IsTablet(void);
 */
  isTablet: lib.symbols.SDL_IsTablet,

/**
 * Query if the current device is a TV.
 *
 * If SDL can't determine this, it will return false.
 *
 * @returns true if the device is a TV, false otherwise.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:620 bool SDL_IsTV(void);
 */
  isTv: lib.symbols.SDL_IsTV,

/**
 * Get the application sandbox environment, if any.
 *
 * @returns the application sandbox environment or SDL_SANDBOX_NONE if the
 *          application is not running in a sandbox environment.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:644 SDL_Sandbox SDL_GetSandbox(void);
 */
  getSandbox: lib.symbols.SDL_GetSandbox,

/**
 * Let iOS apps with external event handling report
 * onApplicationWillTerminate.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:664 void SDL_OnApplicationWillTerminate(void);
 */
  onApplicationWillTerminate: lib.symbols.SDL_OnApplicationWillTerminate,

/**
 * Let iOS apps with external event handling report
 * onApplicationDidReceiveMemoryWarning.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:681 void SDL_OnApplicationDidReceiveMemoryWarning(void);
 */
  onApplicationDidReceiveMemoryWarning: lib.symbols.SDL_OnApplicationDidReceiveMemoryWarning,

/**
 * Let iOS apps with external event handling report
 * onApplicationWillResignActive.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:698 void SDL_OnApplicationWillEnterBackground(void);
 */
  onApplicationWillEnterBackground: lib.symbols.SDL_OnApplicationWillEnterBackground,

/**
 * Let iOS apps with external event handling report
 * onApplicationDidEnterBackground.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:715 void SDL_OnApplicationDidEnterBackground(void);
 */
  onApplicationDidEnterBackground: lib.symbols.SDL_OnApplicationDidEnterBackground,

/**
 * Let iOS apps with external event handling report
 * onApplicationWillEnterForeground.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:732 void SDL_OnApplicationWillEnterForeground(void);
 */
  onApplicationWillEnterForeground: lib.symbols.SDL_OnApplicationWillEnterForeground,

/**
 * Let iOS apps with external event handling report
 * onApplicationDidBecomeActive.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:749 void SDL_OnApplicationDidEnterForeground(void);
 */
  onApplicationDidEnterForeground: lib.symbols.SDL_OnApplicationDidEnterForeground,

/**
 * Let iOS apps with external event handling report
 * onApplicationDidChangeStatusBarOrientation.
 *
 * This functions allows iOS apps that have their own event handling to hook
 * into SDL to generate SDL events. This maps directly to an iOS-specific
 * event, but since it doesn't do anything iOS-specific internally, it is
 * available on all platforms, in case it might be useful for some specific
 * paradigm. Most apps do not need to use this directly; SDL's internal event
 * code will handle all this for windows created by SDL_CreateWindow!
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:768 void SDL_OnApplicationDidChangeStatusBarOrientation(void);
 */
  /* onApplicationDidChangeStatusBarOrientation: lib.symbols.SDL_OnApplicationDidChangeStatusBarOrientation, */

/**
 * Gets a reference to the global async task queue handle for GDK,
 * initializing if needed.
 *
 * Once you are done with the task queue, you should call
 * XTaskQueueCloseHandle to reduce the reference count to avoid a resource
 * leak.
 *
 * @param outTaskQueue a pointer to be filled in with task queue handle.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:792 bool SDL_GetGDKTaskQueue(XTaskQueueHandle *outTaskQueue);
 */
  /* getGdkTaskQueue: lib.symbols.SDL_GetGDKTaskQueue, */

/**
 * Gets a reference to the default user handle for GDK.
 *
 * This is effectively a synchronous version of XUserAddAsync, which always
 * prefers the default user and allows a sign-in UI.
 *
 * @param outUserHandle a pointer to be filled in with the default user
 *                      handle.
 * @returns true if success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_system.h:807 bool SDL_GetGDKDefaultUser(XUserHandle *outUserHandle);
 */
  /* getGdkDefaultUser: lib.symbols.SDL_GetGDKDefaultUser, */



/*--- SDL_thread ---*/

/**
 * @from SDL_thread:282 SDL_PROP_THREAD_CREATE_
 */
  PROP_THREAD_CREATE: SDL_thread_enums.PROP_THREAD_CREATE,

/**
 * The SDL thread priority.
 *
 * SDL will make system changes as necessary in order to apply the thread
 * priority. Code which attempts to control thread state related to priority
 * should be aware that calling SDL_SetCurrentThreadPriority may alter such
 * state. SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of
 * this behavior.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_thread.h:109 SDL_THREAD_PRIORITY_
 */
  THREAD_PRIORITY: SDL_thread_enums.SDL_ThreadPriority,

/**
 * The SDL thread state.
 *
 * The current state of a thread can be checked by calling SDL_GetThreadState.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_GetThreadState
 *
 * @from SDL_thread.h:125 SDL_THREAD_
 */
  THREAD: SDL_thread_enums.SDL_ThreadState,



/**
 * Create a new thread with with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_THREAD_CREATE_ENTRY_FUNCTION_POINTER`: an SDL_ThreadFunction
 *   value that will be called at the start of the new thread's life.
 *   Required.
 * - `SDL_PROP_THREAD_CREATE_NAME_STRING`: the name of the new thread, which
 *   might be available to debuggers. Optional, defaults to NULL.
 * - `SDL_PROP_THREAD_CREATE_USERDATA_POINTER`: an arbitrary app-defined
 *   pointer, which is passed to the entry function on the new thread, as its
 *   only parameter. Optional, defaults to NULL.
 * - `SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER`: the size, in bytes, of the new
 *   thread's stack. Optional, defaults to 0 (system-defined default).
 *
 * SDL makes an attempt to report `SDL_PROP_THREAD_CREATE_NAME_STRING` to the
 * system, so that debuggers can display it. Not all platforms support this.
 *
 * Thread naming is a little complicated: Most systems have very small limits
 * for the string length (Haiku has 32 bytes, Linux currently has 16, Visual
 * C++ 6.0 has _nine_!), and possibly other arbitrary rules. You'll have to
 * see what happens with your system's debugger. The name should be UTF-8 (but
 * using the naming limits of C identifiers is a better bet). There are no
 * requirements for thread naming conventions, so long as the string is
 * null-terminated UTF-8, but these guidelines are helpful in choosing a name:
 *
 * https://stackoverflow.com/questions/149932/naming-conventions-for-threads
 *
 * If a system imposes requirements, SDL will try to munge the string for it
 * (truncate, etc), but the original string contents will be available from
 * SDL_GetThreadName().
 *
 * The size (in bytes) of the new stack can be specified with
 * `SDL_PROP_THREAD_CREATE_STACKSIZE_NUMBER`. Zero means "use the system
 * default" which might be wildly different between platforms. x86 Linux
 * generally defaults to eight megabytes, an embedded device might be a few
 * kilobytes instead. You generally need to specify a stack that is a multiple
 * of the system's page size (in many cases, this is 4 kilobytes, but check
 * your system documentation).
 *
 * Note that this "function" is actually a macro that calls an internal
 * function with two extra parameters not listed here; they are hidden through
 * preprocessor macros and are needed to support various C runtimes at the
 * point of the function call. Language bindings that aren't using the C
 * headers will need to deal with this.
 *
 * The actual symbol in SDL is `SDL_CreateThreadWithPropertiesRuntime`, so
 * there is no symbol clash, but trying to load an SDL shared library and look
 * for "SDL_CreateThreadWithProperties" will fail.
 *
 * Usually, apps should just call this function the same way on every platform
 * and let the macros hide the details.
 *
 * @param props the properties to use.
 * @returns an opaque pointer to the new thread object on success, NULL if the
 *          new thread could not be created; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateThread
 * @sa SDL_WaitThread
 *
 * @from SDL_thread.h:280 SDL_Thread * SDL_CreateThreadWithProperties(SDL_PropertiesID props);
 */
  /* createThreadWithProperties: lib.symbols.SDL_CreateThreadWithProperties, */

/**
 * The actual entry point for SDL_CreateThreadWithProperties.
 *
 * @param props the properties to use
 * @param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.
 * @param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.
 * @returns an opaque pointer to the new thread object on success, NULL if the
 *          new thread could not be created; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_thread.h:346 SDL_Thread * SDL_CreateThreadWithPropertiesRuntime(SDL_PropertiesID props, SDL_FunctionPointer pfnBeginThread, SDL_FunctionPointer pfnEndThread);
 */
  createThreadWithPropertiesRuntime: lib.symbols.SDL_CreateThreadWithPropertiesRuntime,

/**
 * Get the thread name as it was specified in SDL_CreateThread().
 *
 * @param thread the thread to query.
 * @returns a pointer to a UTF-8 string that names the specified thread, or
 *          NULL if it doesn't have a name.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_thread.h:366 const char * SDL_GetThreadName(SDL_Thread *thread);
 */
  getThreadName: lib.symbols.SDL_GetThreadName,

/**
 * Get the thread identifier for the current thread.
 *
 * This thread identifier is as reported by the underlying operating system.
 * If SDL is running on a platform that does not support threads the return
 * value will always be zero.
 *
 * This function also returns a valid thread ID when called from the main
 * thread.
 *
 * @returns the ID of the current thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetThreadID
 *
 * @from SDL_thread.h:384 SDL_ThreadID SDL_GetCurrentThreadID(void);
 */
  getCurrentThreadId: lib.symbols.SDL_GetCurrentThreadID,

/**
 * Get the thread identifier for the specified thread.
 *
 * This thread identifier is as reported by the underlying operating system.
 * If SDL is running on a platform that does not support threads the return
 * value will always be zero.
 *
 * @param thread the thread to query.
 * @returns the ID of the specified thread, or the ID of the current thread if
 *          `thread` is NULL.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCurrentThreadID
 *
 * @from SDL_thread.h:401 SDL_ThreadID SDL_GetThreadID(SDL_Thread *thread);
 */
  getThreadId: lib.symbols.SDL_GetThreadID,

/**
 * Set the priority for the current thread.
 *
 * Note that some platforms will not let you alter the priority (or at least,
 * promote the thread to a higher priority) at all, and some require you to be
 * an administrator account. Be prepared for this to fail.
 *
 * @param priority the SDL_ThreadPriority to set.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_thread.h:416 bool SDL_SetCurrentThreadPriority(SDL_ThreadPriority priority);
 */
  setCurrentThreadPriority: lib.symbols.SDL_SetCurrentThreadPriority,

/**
 * Wait for a thread to finish.
 *
 * Threads that haven't been detached will remain until this function cleans
 * them up. Not doing so is a resource leak.
 *
 * Once a thread has been cleaned up through this function, the SDL_Thread
 * that references it becomes invalid and should not be referenced again. As
 * such, only one thread may call SDL_WaitThread() on another.
 *
 * The return code from the thread function is placed in the area pointed to
 * by `status`, if `status` is not NULL.
 *
 * You may not wait on a thread that has been used in a call to
 * SDL_DetachThread(). Use either that function or this one, but not both, or
 * behavior is undefined.
 *
 * It is safe to pass a NULL thread to this function; it is a no-op.
 *
 * Note that the thread pointer is freed by this function and is not valid
 * afterward.
 *
 * @param thread the SDL_Thread pointer that was returned from the
 *               SDL_CreateThread() call that started this thread.
 * @param status a pointer filled in with the value returned from the thread
 *               function by its 'return', or -1 if the thread has been
 *               detached or isn't valid, may be NULL.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateThread
 * @sa SDL_DetachThread
 *
 * @from SDL_thread.h:451 void SDL_WaitThread(SDL_Thread *thread, int *status);
 */
  waitThread: lib.symbols.SDL_WaitThread,

/**
 * Get the current state of a thread.
 *
 * @param thread the thread to query.
 * @returns the current state of a thread, or SDL_THREAD_UNKNOWN if the thread
 *          isn't valid.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ThreadState
 *
 * @from SDL_thread.h:464 SDL_ThreadState SDL_GetThreadState(SDL_Thread *thread);
 */
  getThreadState: lib.symbols.SDL_GetThreadState,

/**
 * Let a thread clean up on exit without intervention.
 *
 * A thread may be "detached" to signify that it should not remain until
 * another thread has called SDL_WaitThread() on it. Detaching a thread is
 * useful for long-running threads that nothing needs to synchronize with or
 * further manage. When a detached thread is done, it simply goes away.
 *
 * There is no way to recover the return code of a detached thread. If you
 * need this, don't detach the thread and instead use SDL_WaitThread().
 *
 * Once a thread is detached, you should usually assume the SDL_Thread isn't
 * safe to reference again, as it will become invalid immediately upon the
 * detached thread's exit, instead of remaining until someone has called
 * SDL_WaitThread() to finally clean it up. As such, don't detach the same
 * thread more than once.
 *
 * If a thread has already exited when passed to SDL_DetachThread(), it will
 * stop waiting for a call to SDL_WaitThread() and clean up immediately. It is
 * not safe to detach a thread that might be used with SDL_WaitThread().
 *
 * You may not call SDL_WaitThread() on a thread that has been detached. Use
 * either that function or this one, but not both, or behavior is undefined.
 *
 * It is safe to pass NULL to this function; it is a no-op.
 *
 * @param thread the SDL_Thread pointer that was returned from the
 *               SDL_CreateThread() call that started this thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateThread
 * @sa SDL_WaitThread
 *
 * @from SDL_thread.h:500 void SDL_DetachThread(SDL_Thread *thread);
 */
  detachThread: lib.symbols.SDL_DetachThread,

/**
 * Get the current thread's value associated with a thread local storage ID.
 *
 * @param id a pointer to the thread local storage ID, may not be NULL.
 * @returns the value associated with the ID for the current thread or NULL if
 *          no value has been set; call SDL_GetError() for more information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetTLS
 *
 * @from SDL_thread.h:515 void * SDL_GetTLS(SDL_TLSID *id);
 */
  getTls: lib.symbols.SDL_GetTLS,

/**
 * Set the current thread's value associated with a thread local storage ID.
 *
 * If the thread local storage ID is not initialized (the value is 0), a new
 * ID will be created in a thread-safe way, so all calls using a pointer to
 * the same ID will refer to the same local storage.
 *
 * Note that replacing a value from a previous call to this function on the
 * same thread does _not_ call the previous value's destructor!
 *
 * `destructor` can be NULL; it is assumed that `value` does not need to be
 * cleaned up if so.
 *
 * @param id a pointer to the thread local storage ID, may not be NULL.
 * @param value the value to associate with the ID for the current thread.
 * @param destructor a function called when the thread exits, to free the
 *                   value, may be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTLS
 *
 * @from SDL_thread.h:556 bool SDL_SetTLS(SDL_TLSID *id, const void *value, SDL_TLSDestructorCallback destructor);
 */
  setTls: lib.symbols.SDL_SetTLS,

/**
 * Cleanup all TLS data for this thread.
 *
 * If you are creating your threads outside of SDL and then calling SDL
 * functions, you should call this function before your thread exits, to
 * properly clean up SDL memory.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_thread.h:569 void SDL_CleanupTLS(void);
 */
  cleanupTls: lib.symbols.SDL_CleanupTLS,



/*--- SDL_time ---*/

/**
 * The preferred date format of the current system locale.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_GetDateTimeLocalePreferences
 *
 * @from SDL_time.h:73 SDL_DATE_FORMAT_
 */
  DATE_FORMAT: SDL_time_enums.SDL_DateFormat,

/**
 * The preferred time format of the current system locale.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_GetDateTimeLocalePreferences
 *
 * @from SDL_time.h:87 SDL_TIME_FORMAT_
 */
  TIME_FORMAT: SDL_time_enums.SDL_TimeFormat,



/**
 * Gets the current preferred date and time format for the system locale.
 *
 * This might be a "slow" call that has to query the operating system. It's
 * best to ask for this once and save the results. However, the preferred
 * formats can change, usually because the user has changed a system
 * preference outside of your program.
 *
 * @param dateFormat a pointer to the SDL_DateFormat to hold the returned date
 *                   format, may be NULL.
 * @param timeFormat a pointer to the SDL_TimeFormat to hold the returned time
 *                   format, may be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:110 bool SDL_GetDateTimeLocalePreferences(SDL_DateFormat *dateFormat, SDL_TimeFormat *timeFormat);
 */
  getDateTimeLocalePreferences: lib.symbols.SDL_GetDateTimeLocalePreferences,

/**
 * Gets the current value of the system realtime clock in nanoseconds since
 * Jan 1, 1970 in Universal Coordinated Time (UTC).
 *
 * @param ticks the SDL_Time to hold the returned tick count.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:122 bool SDL_GetCurrentTime(SDL_Time *ticks);
 */
  getCurrentTime: lib.symbols.SDL_GetCurrentTime,

/**
 * Converts an SDL_Time in nanoseconds since the epoch to a calendar time in
 * the SDL_DateTime format.
 *
 * @param ticks the SDL_Time to be converted.
 * @param dt the resulting SDL_DateTime.
 * @param localTime the resulting SDL_DateTime will be expressed in local time
 *                  if true, otherwise it will be in Universal Coordinated
 *                  Time (UTC).
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:138 bool SDL_TimeToDateTime(SDL_Time ticks, SDL_DateTime *dt, bool localTime);
 */
  timeToDateTime: lib.symbols.SDL_TimeToDateTime,

/**
 * Converts a calendar time to an SDL_Time in nanoseconds since the epoch.
 *
 * This function ignores the day_of_week member of the SDL_DateTime struct, so
 * it may remain unset.
 *
 * @param dt the source SDL_DateTime.
 * @param ticks the resulting SDL_Time.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:153 bool SDL_DateTimeToTime(const SDL_DateTime *dt, SDL_Time *ticks);
 */
  dateTimeToTime: lib.symbols.SDL_DateTimeToTime,

/**
 * Converts an SDL time into a Windows FILETIME (100-nanosecond intervals
 * since January 1, 1601).
 *
 * This function fills in the two 32-bit values of the FILETIME structure.
 *
 * @param ticks the time to convert.
 * @param dwLowDateTime a pointer filled in with the low portion of the
 *                      Windows FILETIME value.
 * @param dwHighDateTime a pointer filled in with the high portion of the
 *                       Windows FILETIME value.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:169 void SDL_TimeToWindows(SDL_Time ticks, Uint32 *dwLowDateTime, Uint32 *dwHighDateTime);
 */
  timeToWindows: lib.symbols.SDL_TimeToWindows,

/**
 * Converts a Windows FILETIME (100-nanosecond intervals since January 1,
 * 1601) to an SDL time.
 *
 * This function takes the two 32-bit values of the FILETIME structure as
 * parameters.
 *
 * @param dwLowDateTime the low portion of the Windows FILETIME value.
 * @param dwHighDateTime the high portion of the Windows FILETIME value.
 * @returns the converted SDL time.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:184 SDL_Time SDL_TimeFromWindows(Uint32 dwLowDateTime, Uint32 dwHighDateTime);
 */
  timeFromWindows: lib.symbols.SDL_TimeFromWindows,

/**
 * Get the number of days in a month for a given year.
 *
 * @param year the year.
 * @param month the month [1-12].
 * @returns the number of days in the requested month or -1 on failure; call
 *          SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:196 int SDL_GetDaysInMonth(int year, int month);
 */
  getDaysInMonth: lib.symbols.SDL_GetDaysInMonth,

/**
 * Get the day of year for a calendar date.
 *
 * @param year the year component of the date.
 * @param month the month component of the date.
 * @param day the day component of the date.
 * @returns the day of year [0-365] if the date is valid or -1 on failure;
 *          call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:209 int SDL_GetDayOfYear(int year, int month, int day);
 */
  getDayOfYear: lib.symbols.SDL_GetDayOfYear,

/**
 * Get the day of week for a calendar date.
 *
 * @param year the year component of the date.
 * @param month the month component of the date.
 * @param day the day component of the date.
 * @returns a value between 0 and 6 (0 being Sunday) if the date is valid or
 *          -1 on failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_time.h:222 int SDL_GetDayOfWeek(int year, int month, int day);
 */
  getDayOfWeek: lib.symbols.SDL_GetDayOfWeek,



/*--- SDL_timer ---*/

/**
 * Get the number of milliseconds since SDL library initialization.
 *
 * @returns an unsigned 64-bit value representing the number of milliseconds
 *          since the SDL library initialized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_timer.h:196 Uint64 SDL_GetTicks(void);
 */
  getTicks: lib.symbols.SDL_GetTicks,

/**
 * Get the number of nanoseconds since SDL library initialization.
 *
 * @returns an unsigned 64-bit value representing the number of nanoseconds
 *          since the SDL library initialized.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_timer.h:208 Uint64 SDL_GetTicksNS(void);
 */
  getTicksNs: lib.symbols.SDL_GetTicksNS,

/**
 * Get the current value of the high resolution counter.
 *
 * This function is typically used for profiling.
 *
 * The counter values are only meaningful relative to each other. Differences
 * between values can be converted to times by using
 * SDL_GetPerformanceFrequency().
 *
 * @returns the current counter value.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPerformanceFrequency
 *
 * @from SDL_timer.h:227 Uint64 SDL_GetPerformanceCounter(void);
 */
  getPerformanceCounter: lib.symbols.SDL_GetPerformanceCounter,

/**
 * Get the count per second of the high resolution counter.
 *
 * @returns a platform-specific count per second.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetPerformanceCounter
 *
 * @from SDL_timer.h:240 Uint64 SDL_GetPerformanceFrequency(void);
 */
  getPerformanceFrequency: lib.symbols.SDL_GetPerformanceFrequency,

/**
 * Wait a specified number of milliseconds before returning.
 *
 * This function waits a specified number of milliseconds before returning. It
 * waits at least the specified time, but possibly longer due to OS
 * scheduling.
 *
 * @param ms the number of milliseconds to delay.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DelayNS
 * @sa SDL_DelayPrecise
 *
 * @from SDL_timer.h:258 void SDL_Delay(Uint32 ms);
 */
  delay: lib.symbols.SDL_Delay,

/**
 * Wait a specified number of nanoseconds before returning.
 *
 * This function waits a specified number of nanoseconds before returning. It
 * waits at least the specified time, but possibly longer due to OS
 * scheduling.
 *
 * @param ns the number of nanoseconds to delay.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Delay
 * @sa SDL_DelayPrecise
 *
 * @from SDL_timer.h:276 void SDL_DelayNS(Uint64 ns);
 */
  delayNs: lib.symbols.SDL_DelayNS,

/**
 * Wait a specified number of nanoseconds before returning.
 *
 * This function waits a specified number of nanoseconds before returning. It
 * will attempt to wait as close to the requested time as possible, busy
 * waiting if necessary, but could return later due to OS scheduling.
 *
 * @param ns the number of nanoseconds to delay.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Delay
 * @sa SDL_DelayNS
 *
 * @from SDL_timer.h:294 void SDL_DelayPrecise(Uint64 ns);
 */
  delayPrecise: lib.symbols.SDL_DelayPrecise,

/**
 * Call a callback function at a future time.
 *
 * The callback function is passed the current timer interval and the user
 * supplied parameter from the SDL_AddTimer() call and should return the next
 * timer interval. If the value returned from the callback is 0, the timer is
 * canceled and will be removed.
 *
 * The callback is run on a separate thread, and for short timeouts can
 * potentially be called before this function returns.
 *
 * Timers take into account the amount of time it took to execute the
 * callback. For example, if the callback took 250 ms to execute and returned
 * 1000 (ms), the timer would only wait another 750 ms before its next
 * iteration.
 *
 * Timing may be inexact due to OS scheduling. Be sure to note the current
 * time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your
 * callback needs to adjust for variances.
 *
 * @param interval the timer delay, in milliseconds, passed to `callback`.
 * @param callback the SDL_TimerCallback function to call when the specified
 *                 `interval` elapses.
 * @param userdata a pointer that is passed to `callback`.
 * @returns a timer ID or 0 on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddTimerNS
 * @sa SDL_RemoveTimer
 *
 * @from SDL_timer.h:363 SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void *userdata);
 */
  addTimer: lib.symbols.SDL_AddTimer,

/**
 * Call a callback function at a future time.
 *
 * The callback function is passed the current timer interval and the user
 * supplied parameter from the SDL_AddTimerNS() call and should return the
 * next timer interval. If the value returned from the callback is 0, the
 * timer is canceled and will be removed.
 *
 * The callback is run on a separate thread, and for short timeouts can
 * potentially be called before this function returns.
 *
 * Timers take into account the amount of time it took to execute the
 * callback. For example, if the callback took 250 ns to execute and returned
 * 1000 (ns), the timer would only wait another 750 ns before its next
 * iteration.
 *
 * Timing may be inexact due to OS scheduling. Be sure to note the current
 * time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your
 * callback needs to adjust for variances.
 *
 * @param interval the timer delay, in nanoseconds, passed to `callback`.
 * @param callback the SDL_TimerCallback function to call when the specified
 *                 `interval` elapses.
 * @param userdata a pointer that is passed to `callback`.
 * @returns a timer ID or 0 on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddTimer
 * @sa SDL_RemoveTimer
 *
 * @from SDL_timer.h:425 SDL_TimerID SDL_AddTimerNS(Uint64 interval, SDL_NSTimerCallback callback, void *userdata);
 */
  addTimerNs: lib.symbols.SDL_AddTimerNS,

/**
 * Remove a timer created with SDL_AddTimer().
 *
 * @param id the ID of the timer to remove.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety It is safe to call this function from any thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_AddTimer
 *
 * @from SDL_timer.h:440 bool SDL_RemoveTimer(SDL_TimerID id);
 */
  removeTimer: lib.symbols.SDL_RemoveTimer,



/*--- SDL_touch ---*/

/**
 * An enum that describes the type of a touch device.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_touch.h:82 SDL_TOUCH_DEVICE_
 */
  TOUCH_DEVICE: SDL_touch_enums.SDL_TouchDeviceType,



/**
 * Get a list of registered touch devices.
 *
 * On some platforms SDL first sees the touch device if it was actually used.
 * Therefore the returned list might be empty, although devices are available.
 * After using all devices at least once the number will be correct.
 *
 * @param count a pointer filled in with the number of devices returned, may
 *              be NULL.
 * @returns a 0 terminated array of touch device IDs or NULL on failure; call
 *          SDL_GetError() for more information. This should be freed with
 *          SDL_free() when it is no longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_touch.h:139 SDL_TouchID * SDL_GetTouchDevices(int *count);
 */
  getTouchDevices: lib.symbols.SDL_GetTouchDevices,

/**
 * Get the touch device name as reported from the driver.
 *
 * @param touchID the touch device instance ID.
 * @returns touch device name, or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_touch.h:150 const char * SDL_GetTouchDeviceName(SDL_TouchID touchID);
 */
  getTouchDeviceName: lib.symbols.SDL_GetTouchDeviceName,

/**
 * Get the type of the given touch device.
 *
 * @param touchID the ID of a touch device.
 * @returns touch device type.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_touch.h:160 SDL_TouchDeviceType SDL_GetTouchDeviceType(SDL_TouchID touchID);
 */
  getTouchDeviceType: lib.symbols.SDL_GetTouchDeviceType,

/**
 * Get a list of active fingers for a given touch device.
 *
 * @param touchID the ID of a touch device.
 * @param count a pointer filled in with the number of fingers returned, can
 *              be NULL.
 * @returns a NULL terminated array of SDL_Finger pointers or NULL on failure;
 *          call SDL_GetError() for more information. This is a single
 *          allocation that should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_touch.h:175 SDL_Finger ** SDL_GetTouchFingers(SDL_TouchID touchID, int *count);
 */
  getTouchFingers: lib.symbols.SDL_GetTouchFingers,



/*--- SDL_tray ---*/

/**
 * @from SDL_tray:79 SDL_TRAYENTRY_
 */
  TRAYENTRY: SDL_tray_enums.TRAYENTRY,



/**
 * Create an icon to be placed in the operating system's tray, or equivalent.
 *
 * Many platforms advise not using a system tray unless persistence is a
 * necessary feature. Avoid needlessly creating a tray icon, as the user may
 * feel like it clutters their interface.
 *
 * Using tray icons require the video subsystem.
 *
 * @param icon a surface to be used as icon. May be NULL.
 * @param tooltip a tooltip to be displayed when the mouse hovers the icon in
 *                UTF-8 encoding. Not supported on all platforms. May be NULL.
 * @returns The newly created system tray icon.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTrayMenu
 * @sa SDL_GetTrayMenu
 * @sa SDL_DestroyTray
 *
 * @from SDL_tray.h:120 SDL_Tray * SDL_CreateTray(SDL_Surface *icon, const char *tooltip);
 */
  createTray: lib.symbols.SDL_CreateTray,

/**
 * Updates the system tray icon's icon.
 *
 * @param tray the tray icon to be updated.
 * @param icon the new icon. May be NULL.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTray
 *
 * @from SDL_tray.h:135 void SDL_SetTrayIcon(SDL_Tray *tray, SDL_Surface *icon);
 */
  setTrayIcon: lib.symbols.SDL_SetTrayIcon,

/**
 * Updates the system tray icon's tooltip.
 *
 * @param tray the tray icon to be updated.
 * @param tooltip the new tooltip in UTF-8 encoding. May be NULL.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTray
 *
 * @from SDL_tray.h:150 void SDL_SetTrayTooltip(SDL_Tray *tray, const char *tooltip);
 */
  setTrayTooltip: lib.symbols.SDL_SetTrayTooltip,

/**
 * Create a menu for a system tray.
 *
 * This should be called at most once per tray icon.
 *
 * This function does the same thing as SDL_CreateTraySubmenu(), except that
 * it takes a SDL_Tray instead of a SDL_TrayEntry.
 *
 * A menu does not need to be destroyed; it will be destroyed with the tray.
 *
 * @param tray the tray to bind the menu to.
 * @returns the newly created menu.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTray
 * @sa SDL_GetTrayMenu
 * @sa SDL_GetTrayMenuParentTray
 *
 * @from SDL_tray.h:174 SDL_TrayMenu * SDL_CreateTrayMenu(SDL_Tray *tray);
 */
  createTrayMenu: lib.symbols.SDL_CreateTrayMenu,

/**
 * Create a submenu for a system tray entry.
 *
 * This should be called at most once per tray entry.
 *
 * This function does the same thing as SDL_CreateTrayMenu, except that it
 * takes a SDL_TrayEntry instead of a SDL_Tray.
 *
 * A menu does not need to be destroyed; it will be destroyed with the tray.
 *
 * @param entry the tray entry to bind the menu to.
 * @returns the newly created menu.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_InsertTrayEntryAt
 * @sa SDL_GetTraySubmenu
 * @sa SDL_GetTrayMenuParentEntry
 *
 * @from SDL_tray.h:198 SDL_TrayMenu * SDL_CreateTraySubmenu(SDL_TrayEntry *entry);
 */
  createTraySubmenu: lib.symbols.SDL_CreateTraySubmenu,

/**
 * Gets a previously created tray menu.
 *
 * You should have called SDL_CreateTrayMenu() on the tray object. This
 * function allows you to fetch it again later.
 *
 * This function does the same thing as SDL_GetTraySubmenu(), except that it
 * takes a SDL_Tray instead of a SDL_TrayEntry.
 *
 * A menu does not need to be destroyed; it will be destroyed with the tray.
 *
 * @param tray the tray entry to bind the menu to.
 * @returns the newly created menu.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTray
 * @sa SDL_CreateTrayMenu
 *
 * @from SDL_tray.h:222 SDL_TrayMenu * SDL_GetTrayMenu(SDL_Tray *tray);
 */
  getTrayMenu: lib.symbols.SDL_GetTrayMenu,

/**
 * Gets a previously created tray entry submenu.
 *
 * You should have called SDL_CreateTraySubmenu() on the entry object. This
 * function allows you to fetch it again later.
 *
 * This function does the same thing as SDL_GetTrayMenu(), except that it
 * takes a SDL_TrayEntry instead of a SDL_Tray.
 *
 * A menu does not need to be destroyed; it will be destroyed with the tray.
 *
 * @param entry the tray entry to bind the menu to.
 * @returns the newly created menu.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_InsertTrayEntryAt
 * @sa SDL_CreateTraySubmenu
 *
 * @from SDL_tray.h:246 SDL_TrayMenu * SDL_GetTraySubmenu(SDL_TrayEntry *entry);
 */
  getTraySubmenu: lib.symbols.SDL_GetTraySubmenu,

/**
 * Returns a list of entries in the menu, in order.
 *
 * @param menu The menu to get entries from.
 * @param count An optional pointer to obtain the number of entries in the
 *              menu.
 * @returns a NULL-terminated list of entries within the given menu. The
 *          pointer becomes invalid when any function that inserts or deletes
 *          entries in the menu is called.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_RemoveTrayEntry
 * @sa SDL_InsertTrayEntryAt
 *
 * @from SDL_tray.h:266 const SDL_TrayEntry ** SDL_GetTrayEntries(SDL_TrayMenu *menu, int *count);
 */
  getTrayEntries: lib.symbols.SDL_GetTrayEntries,

/**
 * Removes a tray entry.
 *
 * @param entry The entry to be deleted.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTrayEntries
 * @sa SDL_InsertTrayEntryAt
 *
 * @from SDL_tray.h:281 void SDL_RemoveTrayEntry(SDL_TrayEntry *entry);
 */
  removeTrayEntry: lib.symbols.SDL_RemoveTrayEntry,

/**
 * Insert a tray entry at a given position.
 *
 * If label is NULL, the entry will be a separator. Many functions won't work
 * for an entry that is a separator.
 *
 * An entry does not need to be destroyed; it will be destroyed with the tray.
 *
 * @param menu the menu to append the entry to.
 * @param pos the desired position for the new entry. Entries at or following
 *            this place will be moved. If pos is -1, the entry is appended.
 * @param label the text to be displayed on the entry, in UTF-8 encoding, or
 *              NULL for a separator.
 * @param flags a combination of flags, some of which are mandatory.
 * @returns the newly created entry, or NULL if pos is out of bounds.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_TrayEntryFlags
 * @sa SDL_GetTrayEntries
 * @sa SDL_RemoveTrayEntry
 * @sa SDL_GetTrayEntryParent
 *
 * @from SDL_tray.h:309 SDL_TrayEntry * SDL_InsertTrayEntryAt(SDL_TrayMenu *menu, int pos, const char *label, SDL_TrayEntryFlags flags);
 */
  insertTrayEntryAt: lib.symbols.SDL_InsertTrayEntryAt,

/**
 * Sets the label of an entry.
 *
 * An entry cannot change between a separator and an ordinary entry; that is,
 * it is not possible to set a non-NULL label on an entry that has a NULL
 * label (separators), or to set a NULL label to an entry that has a non-NULL
 * label. The function will silently fail if that happens.
 *
 * @param entry the entry to be updated.
 * @param label the new label for the entry in UTF-8 encoding.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTrayEntries
 * @sa SDL_InsertTrayEntryAt
 * @sa SDL_GetTrayEntryLabel
 *
 * @from SDL_tray.h:331 void SDL_SetTrayEntryLabel(SDL_TrayEntry *entry, const char *label);
 */
  setTrayEntryLabel: lib.symbols.SDL_SetTrayEntryLabel,

/**
 * Gets the label of an entry.
 *
 * If the returned value is NULL, the entry is a separator.
 *
 * @param entry the entry to be read.
 * @returns the label of the entry in UTF-8 encoding.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTrayEntries
 * @sa SDL_InsertTrayEntryAt
 * @sa SDL_SetTrayEntryLabel
 *
 * @from SDL_tray.h:350 const char * SDL_GetTrayEntryLabel(SDL_TrayEntry *entry);
 */
  getTrayEntryLabel: lib.symbols.SDL_GetTrayEntryLabel,

/**
 * Sets whether or not an entry is checked.
 *
 * The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.
 *
 * @param entry the entry to be updated.
 * @param checked true if the entry should be checked; false otherwise.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTrayEntries
 * @sa SDL_InsertTrayEntryAt
 * @sa SDL_GetTrayEntryChecked
 *
 * @from SDL_tray.h:369 void SDL_SetTrayEntryChecked(SDL_TrayEntry *entry, bool checked);
 */
  setTrayEntryChecked: lib.symbols.SDL_SetTrayEntryChecked,

/**
 * Gets whether or not an entry is checked.
 *
 * The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.
 *
 * @param entry the entry to be read.
 * @returns true if the entry is checked; false otherwise.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTrayEntries
 * @sa SDL_InsertTrayEntryAt
 * @sa SDL_SetTrayEntryChecked
 *
 * @from SDL_tray.h:388 bool SDL_GetTrayEntryChecked(SDL_TrayEntry *entry);
 */
  getTrayEntryChecked: lib.symbols.SDL_GetTrayEntryChecked,

/**
 * Sets whether or not an entry is enabled.
 *
 * @param entry the entry to be updated.
 * @param enabled true if the entry should be enabled; false otherwise.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTrayEntries
 * @sa SDL_InsertTrayEntryAt
 * @sa SDL_GetTrayEntryEnabled
 *
 * @from SDL_tray.h:405 void SDL_SetTrayEntryEnabled(SDL_TrayEntry *entry, bool enabled);
 */
  setTrayEntryEnabled: lib.symbols.SDL_SetTrayEntryEnabled,

/**
 * Gets whether or not an entry is enabled.
 *
 * @param entry the entry to be read.
 * @returns true if the entry is enabled; false otherwise.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTrayEntries
 * @sa SDL_InsertTrayEntryAt
 * @sa SDL_SetTrayEntryEnabled
 *
 * @from SDL_tray.h:422 bool SDL_GetTrayEntryEnabled(SDL_TrayEntry *entry);
 */
  getTrayEntryEnabled: lib.symbols.SDL_GetTrayEntryEnabled,

/**
 * Sets a callback to be invoked when the entry is selected.
 *
 * @param entry the entry to be updated.
 * @param callback a callback to be invoked when the entry is selected.
 * @param userdata an optional pointer to pass extra data to the callback when
 *                 it will be invoked.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetTrayEntries
 * @sa SDL_InsertTrayEntryAt
 *
 * @from SDL_tray.h:440 void SDL_SetTrayEntryCallback(SDL_TrayEntry *entry, SDL_TrayCallback callback, void *userdata);
 */
  setTrayEntryCallback: lib.symbols.SDL_SetTrayEntryCallback,

/**
 * Simulate a click on a tray entry.
 *
 * @param entry The entry to activate.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_tray.h:452 void SDL_ClickTrayEntry(SDL_TrayEntry *entry);
 */
  clickTrayEntry: lib.symbols.SDL_ClickTrayEntry,

/**
 * Destroys a tray object.
 *
 * This also destroys all associated menus and entries.
 *
 * @param tray the tray icon to be destroyed.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTray
 *
 * @from SDL_tray.h:468 void SDL_DestroyTray(SDL_Tray *tray);
 */
  destroyTray: lib.symbols.SDL_DestroyTray,

/**
 * Gets the menu containing a certain tray entry.
 *
 * @param entry the entry for which to get the parent menu.
 * @returns the parent menu.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_InsertTrayEntryAt
 *
 * @from SDL_tray.h:483 SDL_TrayMenu * SDL_GetTrayEntryParent(SDL_TrayEntry *entry);
 */
  getTrayEntryParent: lib.symbols.SDL_GetTrayEntryParent,

/**
 * Gets the entry for which the menu is a submenu, if the current menu is a
 * submenu.
 *
 * Either this function or SDL_GetTrayMenuParentTray() will return non-NULL
 * for any given menu.
 *
 * @param menu the menu for which to get the parent entry.
 * @returns the parent entry, or NULL if this menu is not a submenu.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTraySubmenu
 * @sa SDL_GetTrayMenuParentTray
 *
 * @from SDL_tray.h:503 SDL_TrayEntry * SDL_GetTrayMenuParentEntry(SDL_TrayMenu *menu);
 */
  getTrayMenuParentEntry: lib.symbols.SDL_GetTrayMenuParentEntry,

/**
 * Gets the tray for which this menu is the first-level menu, if the current
 * menu isn't a submenu.
 *
 * Either this function or SDL_GetTrayMenuParentEntry() will return non-NULL
 * for any given menu.
 *
 * @param menu the menu for which to get the parent enttrayry.
 * @returns the parent tray, or NULL if this menu is a submenu.
 *
 * @threadsafety This function should be called on the thread that created the
 *               tray.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateTrayMenu
 * @sa SDL_GetTrayMenuParentEntry
 *
 * @from SDL_tray.h:523 SDL_Tray * SDL_GetTrayMenuParentTray(SDL_TrayMenu *menu);
 */
  getTrayMenuParentTray: lib.symbols.SDL_GetTrayMenuParentTray,

/**
 * Update the trays.
 *
 * This is called automatically by the event loop and is only needed if you're
 * using trays but aren't handling SDL events.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_tray.h:535 void SDL_UpdateTrays(void);
 */
  updateTrays: lib.symbols.SDL_UpdateTrays,



/*--- SDL_version ---*/

/**
 * Get the version of SDL that is linked against your program.
 *
 * If you are linking to SDL dynamically, then it is possible that the current
 * version will be different than the version you compiled against. This
 * function returns the current version, while SDL_VERSION is the version you
 * compiled with.
 *
 * This function may be called safely at any time, even before SDL_Init().
 *
 * @returns the version of the linked library.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRevision
 *
 * @from SDL_version.h:147 int SDL_GetVersion(void);
 */
  getVersion: lib.symbols.SDL_GetVersion,

/**
 * Get the code revision of SDL that is linked against your program.
 *
 * This value is the revision of the code you are linked with and may be
 * different from the code you are compiling with, which is found in the
 * constant SDL_REVISION.
 *
 * The revision is arbitrary string (a hash value) uniquely identifying the
 * exact revision of the SDL library in use, and is only useful in comparing
 * against other revisions. It is NOT an incrementing number.
 *
 * If SDL wasn't built from a git repository with the appropriate tools, this
 * will return an empty string.
 *
 * You shouldn't use this function for anything but logging it for debugging
 * purposes. The string is not intended to be reliable in any way.
 *
 * @returns an arbitrary string, uniquely identifying the exact revision of
 *          the SDL library in use.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetVersion
 *
 * @from SDL_version.h:173 const char * SDL_GetRevision(void);
 */
  getRevision: lib.symbols.SDL_GetRevision,



/*--- SDL_video ---*/

/**
 * @from SDL_video:188 SDL_WINDOW_
 */
  WINDOW: SDL_video_enums.WINDOW,

/**
 * @from SDL_video:465 SDL_GL_CONTEXT_PROFILE_
 */
  GL_CONTEXT_PROFILE: SDL_video_enums.GL_CONTEXT_PROFILE,

/**
 * @from SDL_video:477 SDL_GL_CONTEXT_
 */
  GL_CONTEXT: SDL_video_enums.GL_CONTEXT,

/**
 * @from SDL_video:491 SDL_GL_CONTEXT_RELEASE_BEHAVIOR_
 */
  GL_CONTEXT_RELEASE_BEHAVIOR: SDL_video_enums.GL_CONTEXT_RELEASE_BEHAVIOR,

/**
 * @from SDL_video:502 SDL_GL_CONTEXT_RESET_
 */
  GL_CONTEXT_RESET: SDL_video_enums.GL_CONTEXT_RESET,

/**
 * @from SDL_video:629 SDL_PROP_DISPLAY_
 */
  PROP_DISPLAY: SDL_video_enums.PROP_DISPLAY,

/**
 * @from SDL_video:1309 SDL_PROP_WINDOW_CREATE_
 */
  PROP_WINDOW_CREATE: SDL_video_enums.PROP_WINDOW_CREATE,

/**
 * @from SDL_video:1517 SDL_PROP_WINDOW_
 */
  PROP_WINDOW: SDL_video_enums.PROP_WINDOW,

/**
 * @from SDL_video:2312 SDL_WINDOW_SURFACE_VSYNC_
 */
  WINDOW_SURFACE_VSYNC: SDL_video_enums.WINDOW_SURFACE_VSYNC,

/**
 * System theme.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_video.h:107 SDL_SYSTEM_THEME_
 */
  SYSTEM_THEME: SDL_video_enums.SDL_SystemTheme,

/**
 * Display orientation values; the way a display is rotated.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_video.h:156 SDL_ORIENTATION_
 */
  ORIENTATION: SDL_video_enums.SDL_DisplayOrientation,

/**
 * Window flash operation.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_video.h:302 SDL_FLASH_
 */
  FLASH: SDL_video_enums.SDL_FlashOperation,

/**
 * An enumeration of OpenGL configuration attributes.
 *
 * While you can set most OpenGL attributes normally, the attributes listed
 * above must be known before SDL creates the window that will be used with
 * the OpenGL context. These attributes are set and read with
 * SDL_GL_SetAttribute() and SDL_GL_GetAttribute().
 *
 * In some cases, these attributes are minimum requests; the GL does not
 * promise to give you exactly what you asked for. It's possible to ask for a
 * 16-bit depth buffer and get a 24-bit one instead, for example, or to ask
 * for no stencil buffer and still have one available. Context creation should
 * fail if the GL can't provide your requested attributes at a minimum, but
 * you should check to see exactly what you got.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @from SDL_video.h:426 SDL_GL_
 */
  GL: SDL_video_enums.SDL_GLAttr,

/**
 * Possible return values from the SDL_HitTest callback.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This enum is available since SDL 3.2.0.
 *
 * @sa SDL_HitTest
 *
 * @from SDL_video.h:2678 SDL_HITTEST_
 */
  HITTEST: SDL_video_enums.SDL_HitTestResult,



/**
 * Get the number of video drivers compiled into SDL.
 *
 * @returns the number of built in video drivers.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetVideoDriver
 *
 * @from SDL_video.h:519 int SDL_GetNumVideoDrivers(void);
 */
  getNumVideoDrivers: lib.symbols.SDL_GetNumVideoDrivers,

/**
 * Get the name of a built in video driver.
 *
 * The video drivers are presented in the order in which they are normally
 * checked during initialization.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
 * "x11" or "windows". These never have Unicode characters, and are not meant
 * to be proper names.
 *
 * @param index the index of a video driver.
 * @returns the name of the video driver with the given **index**.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumVideoDrivers
 *
 * @from SDL_video.h:540 const char * SDL_GetVideoDriver(int index);
 */
  getVideoDriver: lib.symbols.SDL_GetVideoDriver,

/**
 * Get the name of the currently initialized video driver.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
 * "x11" or "windows". These never have Unicode characters, and are not meant
 * to be proper names.
 *
 * @returns the name of the current video driver or NULL if no driver has been
 *          initialized.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetNumVideoDrivers
 * @sa SDL_GetVideoDriver
 *
 * @from SDL_video.h:559 const char * SDL_GetCurrentVideoDriver(void);
 */
  getCurrentVideoDriver: lib.symbols.SDL_GetCurrentVideoDriver,

/**
 * Get the current system theme.
 *
 * @returns the current system theme, light, dark, or unknown.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:570 SDL_SystemTheme SDL_GetSystemTheme(void);
 */
  getSystemTheme: lib.symbols.SDL_GetSystemTheme,

/**
 * Get a list of currently connected displays.
 *
 * @param count a pointer filled in with the number of displays returned, may
 *              be NULL.
 * @returns a 0 terminated array of display instance IDs or NULL on failure;
 *          call SDL_GetError() for more information. This should be freed
 *          with SDL_free() when it is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:585 SDL_DisplayID * SDL_GetDisplays(int *count);
 */
  getDisplays: lib.symbols.SDL_GetDisplays,

/**
 * Return the primary display.
 *
 * @returns the instance ID of the primary display on success or 0 on failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:599 SDL_DisplayID SDL_GetPrimaryDisplay(void);
 */
  getPrimaryDisplay: lib.symbols.SDL_GetPrimaryDisplay,

/**
 * Get the properties associated with a display.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN`: true if the display has HDR
 *   headroom above the SDR white point. This is for informational and
 *   diagnostic purposes only, as not all platforms provide this information
 *   at the display level.
 *
 * On KMS/DRM:
 *
 * - `SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER`: the "panel
 *   orientation" property for the display in degrees of clockwise rotation.
 *   Note that this is provided only as a hint, and the application is
 *   responsible for any coordinate transformations needed to conform to the
 *   requested display orientation.
 *
 * @param displayID the instance ID of the display to query.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:627 SDL_PropertiesID SDL_GetDisplayProperties(SDL_DisplayID displayID);
 */
  getDisplayProperties: lib.symbols.SDL_GetDisplayProperties,

/**
 * Get the name of a display in UTF-8 encoding.
 *
 * @param displayID the instance ID of the display to query.
 * @returns the name of a display or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:645 const char * SDL_GetDisplayName(SDL_DisplayID displayID);
 */
  getDisplayName: lib.symbols.SDL_GetDisplayName,

/**
 * Get the desktop area represented by a display.
 *
 * The primary display is often located at (0,0), but may be placed at a
 * different location depending on monitor layout.
 *
 * @param displayID the instance ID of the display to query.
 * @param rect the SDL_Rect structure filled in with the display bounds.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplayUsableBounds
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:665 bool SDL_GetDisplayBounds(SDL_DisplayID displayID, SDL_Rect *rect);
 */
  getDisplayBounds: lib.symbols.SDL_GetDisplayBounds,

/**
 * Get the usable desktop area represented by a display, in screen
 * coordinates.
 *
 * This is the same area as SDL_GetDisplayBounds() reports, but with portions
 * reserved by the system removed. For example, on Apple's macOS, this
 * subtracts the area occupied by the menu bar and dock.
 *
 * Setting a window to be fullscreen generally bypasses these unusable areas,
 * so these are good guidelines for the maximum space available to a
 * non-fullscreen window.
 *
 * @param displayID the instance ID of the display to query.
 * @param rect the SDL_Rect structure filled in with the display bounds.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplayBounds
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:691 bool SDL_GetDisplayUsableBounds(SDL_DisplayID displayID, SDL_Rect *rect);
 */
  getDisplayUsableBounds: lib.symbols.SDL_GetDisplayUsableBounds,

/**
 * Get the orientation of a display when it is unrotated.
 *
 * @param displayID the instance ID of the display to query.
 * @returns the SDL_DisplayOrientation enum value of the display, or
 *          `SDL_ORIENTATION_UNKNOWN` if it isn't available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:706 SDL_DisplayOrientation SDL_GetNaturalDisplayOrientation(SDL_DisplayID displayID);
 */
  getNaturalDisplayOrientation: lib.symbols.SDL_GetNaturalDisplayOrientation,

/**
 * Get the orientation of a display.
 *
 * @param displayID the instance ID of the display to query.
 * @returns the SDL_DisplayOrientation enum value of the display, or
 *          `SDL_ORIENTATION_UNKNOWN` if it isn't available.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:721 SDL_DisplayOrientation SDL_GetCurrentDisplayOrientation(SDL_DisplayID displayID);
 */
  getCurrentDisplayOrientation: lib.symbols.SDL_GetCurrentDisplayOrientation,

/**
 * Get the content scale of a display.
 *
 * The content scale is the expected scale for content based on the DPI
 * settings of the display. For example, a 4K display might have a 2.0 (200%)
 * display scale, which means that the user expects UI elements to be twice as
 * big on this display, to aid in readability.
 *
 * After window creation, SDL_GetWindowDisplayScale() should be used to query
 * the content scale factor for individual windows instead of querying the
 * display for a window and calling this function, as the per-window content
 * scale factor may differ from the base value of the display it is on,
 * particularly on high-DPI and/or multi-monitor desktop configurations.
 *
 * @param displayID the instance ID of the display to query.
 * @returns the content scale of the display, or 0.0f on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowDisplayScale
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:748 float SDL_GetDisplayContentScale(SDL_DisplayID displayID);
 */
  getDisplayContentScale: lib.symbols.SDL_GetDisplayContentScale,

/**
 * Get a list of fullscreen display modes available on a display.
 *
 * The display modes are sorted in this priority:
 *
 * - w -> largest to smallest
 * - h -> largest to smallest
 * - bits per pixel -> more colors to fewer colors
 * - packed pixel layout -> largest to smallest
 * - refresh rate -> highest to lowest
 * - pixel density -> lowest to highest
 *
 * @param displayID the instance ID of the display to query.
 * @param count a pointer filled in with the number of display modes returned,
 *              may be NULL.
 * @returns a NULL terminated array of display mode pointers or NULL on
 *          failure; call SDL_GetError() for more information. This is a
 *          single allocation that should be freed with SDL_free() when it is
 *          no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:776 SDL_DisplayMode ** SDL_GetFullscreenDisplayModes(SDL_DisplayID displayID, int *count);
 */
  getFullscreenDisplayModes: lib.symbols.SDL_GetFullscreenDisplayModes,

/**
 * Get the closest match to the requested display mode.
 *
 * The available display modes are scanned and `closest` is filled in with the
 * closest mode matching the requested mode and returned. The mode format and
 * refresh rate default to the desktop mode if they are set to 0. The modes
 * are scanned with size being first priority, format being second priority,
 * and finally checking the refresh rate. If all the available modes are too
 * small, then false is returned.
 *
 * @param displayID the instance ID of the display to query.
 * @param w the width in pixels of the desired display mode.
 * @param h the height in pixels of the desired display mode.
 * @param refresh_rate the refresh rate of the desired display mode, or 0.0f
 *                     for the desktop refresh rate.
 * @param include_high_density_modes boolean to include high density modes in
 *                                   the search.
 * @param closest a pointer filled in with the closest display mode equal to
 *                or larger than the desired mode.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplays
 * @sa SDL_GetFullscreenDisplayModes
 *
 * @from SDL_video.h:807 bool SDL_GetClosestFullscreenDisplayMode(SDL_DisplayID displayID, int w, int h, float refresh_rate, bool include_high_density_modes, SDL_DisplayMode *closest);
 */
  getClosestFullscreenDisplayMode: lib.symbols.SDL_GetClosestFullscreenDisplayMode,

/**
 * Get information about the desktop's display mode.
 *
 * There's a difference between this function and SDL_GetCurrentDisplayMode()
 * when SDL runs fullscreen and has changed the resolution. In that case this
 * function will return the previous native display mode, and not the current
 * display mode.
 *
 * @param displayID the instance ID of the display to query.
 * @returns a pointer to the desktop display mode or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetCurrentDisplayMode
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:828 const SDL_DisplayMode * SDL_GetDesktopDisplayMode(SDL_DisplayID displayID);
 */
  getDesktopDisplayMode: lib.symbols.SDL_GetDesktopDisplayMode,

/**
 * Get information about the current display mode.
 *
 * There's a difference between this function and SDL_GetDesktopDisplayMode()
 * when SDL runs fullscreen and has changed the resolution. In that case this
 * function will return the current display mode, and not the previous native
 * display mode.
 *
 * @param displayID the instance ID of the display to query.
 * @returns a pointer to the desktop display mode or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDesktopDisplayMode
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:849 const SDL_DisplayMode * SDL_GetCurrentDisplayMode(SDL_DisplayID displayID);
 */
  getCurrentDisplayMode: lib.symbols.SDL_GetCurrentDisplayMode,

/**
 * Get the display containing a point.
 *
 * @param point the point to query.
 * @returns the instance ID of the display containing the point or 0 on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplayBounds
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:865 SDL_DisplayID SDL_GetDisplayForPoint(const SDL_Point *point);
 */
  getDisplayForPoint: lib.symbols.SDL_GetDisplayForPoint,

/**
 * Get the display primarily containing a rect.
 *
 * @param rect the rect to query.
 * @returns the instance ID of the display entirely containing the rect or
 *          closest to the center of the rect on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplayBounds
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:882 SDL_DisplayID SDL_GetDisplayForRect(const SDL_Rect *rect);
 */
  getDisplayForRect: lib.symbols.SDL_GetDisplayForRect,

/**
 * Get the display associated with a window.
 *
 * @param window the window to query.
 * @returns the instance ID of the display containing the center of the window
 *          on success or 0 on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetDisplayBounds
 * @sa SDL_GetDisplays
 *
 * @from SDL_video.h:899 SDL_DisplayID SDL_GetDisplayForWindow(SDL_Window *window);
 */
  getDisplayForWindow: lib.symbols.SDL_GetDisplayForWindow,

/**
 * Get the pixel density of a window.
 *
 * This is a ratio of pixel size to window size. For example, if the window is
 * 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it
 * would have a pixel density of 2.0.
 *
 * @param window the window to query.
 * @returns the pixel density or 0.0f on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowDisplayScale
 *
 * @from SDL_video.h:918 float SDL_GetWindowPixelDensity(SDL_Window *window);
 */
  getWindowPixelDensity: lib.symbols.SDL_GetWindowPixelDensity,

/**
 * Get the content display scale relative to a window's pixel size.
 *
 * This is a combination of the window pixel density and the display content
 * scale, and is the expected scale for displaying content in this window. For
 * example, if a 3840x2160 window had a display scale of 2.0, the user expects
 * the content to take twice as many pixels and be the same physical size as
 * if it were being displayed in a 1920x1080 window with a display scale of
 * 1.0.
 *
 * Conceptually this value corresponds to the scale display setting, and is
 * updated when that setting is changed, or the window moves to a display with
 * a different scale setting.
 *
 * @param window the window to query.
 * @returns the display scale, or 0.0f on failure; call SDL_GetError() for
 *          more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:942 float SDL_GetWindowDisplayScale(SDL_Window *window);
 */
  getWindowDisplayScale: lib.symbols.SDL_GetWindowDisplayScale,

/**
 * Set the display mode to use when a window is visible and fullscreen.
 *
 * This only affects the display mode used when the window is fullscreen. To
 * change the window size when the window is not fullscreen, use
 * SDL_SetWindowSize().
 *
 * If the window is currently in the fullscreen state, this request is
 * asynchronous on some windowing systems and the new mode dimensions may not
 * be applied immediately upon the return of this function. If an immediate
 * change is required, call SDL_SyncWindow() to block until the changes have
 * taken effect.
 *
 * When the new mode takes effect, an SDL_EVENT_WINDOW_RESIZED and/or an
 * SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode
 * dimensions.
 *
 * @param window the window to affect.
 * @param mode a pointer to the display mode to use, which can be NULL for
 *             borderless fullscreen desktop mode, or one of the fullscreen
 *             modes returned by SDL_GetFullscreenDisplayModes() to set an
 *             exclusive fullscreen mode.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowFullscreenMode
 * @sa SDL_SetWindowFullscreen
 * @sa SDL_SyncWindow
 *
 * @from SDL_video.h:977 bool SDL_SetWindowFullscreenMode(SDL_Window *window, const SDL_DisplayMode *mode);
 */
  setWindowFullscreenMode: lib.symbols.SDL_SetWindowFullscreenMode,

/**
 * Query the display mode to use when a window is visible at fullscreen.
 *
 * @param window the window to query.
 * @returns a pointer to the exclusive fullscreen mode to use or NULL for
 *          borderless fullscreen desktop mode.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowFullscreenMode
 * @sa SDL_SetWindowFullscreen
 *
 * @from SDL_video.h:993 const SDL_DisplayMode * SDL_GetWindowFullscreenMode(SDL_Window *window);
 */
  getWindowFullscreenMode: lib.symbols.SDL_GetWindowFullscreenMode,

/**
 * Get the raw ICC profile data for the screen the window is currently on.
 *
 * @param window the window to query.
 * @param size the size of the ICC profile.
 * @returns the raw ICC profile data on success or NULL on failure; call
 *          SDL_GetError() for more information. This should be freed with
 *          SDL_free() when it is no longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:1008 void * SDL_GetWindowICCProfile(SDL_Window *window, size_t *size);
 */
  getWindowIccProfile: lib.symbols.SDL_GetWindowICCProfile,

/**
 * Get the pixel format associated with the window.
 *
 * @param window the window to query.
 * @returns the pixel format of the window on success or
 *          SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:1022 SDL_PixelFormat SDL_GetWindowPixelFormat(SDL_Window *window);
 */
  getWindowPixelFormat: lib.symbols.SDL_GetWindowPixelFormat,

/**
 * Get a list of valid windows.
 *
 * @param count a pointer filled in with the number of windows returned, may
 *              be NULL.
 * @returns a NULL terminated array of SDL_Window pointers or NULL on failure;
 *          call SDL_GetError() for more information. This is a single
 *          allocation that should be freed with SDL_free() when it is no
 *          longer needed.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:1038 SDL_Window ** SDL_GetWindows(int *count);
 */
  getWindows: lib.symbols.SDL_GetWindows,

/**
 * Create a window with the specified dimensions and flags.
 *
 * `flags` may be any of the following OR'd together:
 *
 * - `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution
 * - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
 * - `SDL_WINDOW_OCCLUDED`: window partially or completely obscured by another
 *   window
 * - `SDL_WINDOW_HIDDEN`: window is not visible
 * - `SDL_WINDOW_BORDERLESS`: no window decoration
 * - `SDL_WINDOW_RESIZABLE`: window can be resized
 * - `SDL_WINDOW_MINIMIZED`: window is minimized
 * - `SDL_WINDOW_MAXIMIZED`: window is maximized
 * - `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus
 * - `SDL_WINDOW_INPUT_FOCUS`: window has input focus
 * - `SDL_WINDOW_MOUSE_FOCUS`: window has mouse focus
 * - `SDL_WINDOW_EXTERNAL`: window not created by SDL
 * - `SDL_WINDOW_MODAL`: window is modal
 * - `SDL_WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back
 *   buffer if possible
 * - `SDL_WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to
 *   MOUSE_GRABBED)
 * - `SDL_WINDOW_ALWAYS_ON_TOP`: window should always be above others
 * - `SDL_WINDOW_UTILITY`: window should be treated as a utility window, not
 *   showing in the task bar and window list
 * - `SDL_WINDOW_TOOLTIP`: window should be treated as a tooltip and does not
 *   get mouse or keyboard focus, requires a parent window
 * - `SDL_WINDOW_POPUP_MENU`: window should be treated as a popup menu,
 *   requires a parent window
 * - `SDL_WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input
 * - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
 * - `SDL_WINDOW_METAL`: window usable with a Metal instance
 * - `SDL_WINDOW_TRANSPARENT`: window with transparent buffer
 * - `SDL_WINDOW_NOT_FOCUSABLE`: window should not be focusable
 *
 * The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.
 *
 * On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
 * property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
 *
 * The window pixel size may differ from its window coordinate size if the
 * window is on a high pixel density display. Use SDL_GetWindowSize() to query
 * the client area's size in window coordinates, and
 * SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the
 * drawable size in pixels. Note that the drawable size can vary after the
 * window is created and should be queried again if you get an
 * SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.
 *
 * If the window is created with any of the SDL_WINDOW_OPENGL or
 * SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
 * (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
 * corresponding UnloadLibrary function is called by SDL_DestroyWindow().
 *
 * If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
 * SDL_CreateWindow() will fail, because SDL_Vulkan_LoadLibrary() will fail.
 *
 * If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
 * SDL_CreateWindow() will fail.
 *
 * If you intend to use this window with an SDL_Renderer, you should use
 * SDL_CreateWindowAndRenderer() instead of this function, to avoid window
 * flicker.
 *
 * On non-Apple devices, SDL requires you to either not link to the Vulkan
 * loader or link to a dynamic library version. This limitation may be removed
 * in a future version of SDL.
 *
 * @param title the title of the window, in UTF-8 encoding.
 * @param w the width of the window.
 * @param h the height of the window.
 * @param flags 0, or one or more SDL_WindowFlags OR'd together.
 * @returns the window that was created or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateWindowAndRenderer
 * @sa SDL_CreatePopupWindow
 * @sa SDL_CreateWindowWithProperties
 * @sa SDL_DestroyWindow
 *
 * @from SDL_video.h:1124 SDL_Window * SDL_CreateWindow(const char *title, int w, int h, SDL_WindowFlags flags);
 */
  createWindow: lib.symbols.SDL_CreateWindow,

/**
 * Create a child popup window of the specified parent window.
 *
 * The flags parameter **must** contain at least one of the following:
 *
 * - `SDL_WINDOW_TOOLTIP`: The popup window is a tooltip and will not pass any
 *   input events.
 * - `SDL_WINDOW_POPUP_MENU`: The popup window is a popup menu. The topmost
 *   popup menu will implicitly gain the keyboard focus.
 *
 * The following flags are not relevant to popup window creation and will be
 * ignored:
 *
 * - `SDL_WINDOW_MINIMIZED`
 * - `SDL_WINDOW_MAXIMIZED`
 * - `SDL_WINDOW_FULLSCREEN`
 * - `SDL_WINDOW_BORDERLESS`
 *
 * The following flags are incompatible with popup window creation and will
 * cause it to fail:
 *
 * - `SDL_WINDOW_UTILITY`
 * - `SDL_WINDOW_MODAL`
 *
 * The parent parameter **must** be non-null and a valid window. The parent of
 * a popup window can be either a regular, toplevel window, or another popup
 * window.
 *
 * Popup windows cannot be minimized, maximized, made fullscreen, raised,
 * flash, be made a modal window, be the parent of a toplevel window, or grab
 * the mouse and/or keyboard. Attempts to do so will fail.
 *
 * Popup windows implicitly do not have a border/decorations and do not appear
 * on the taskbar/dock or in lists of windows such as alt-tab menus.
 *
 * If a parent window is hidden or destroyed, any child popup windows will be
 * recursively hidden or destroyed as well. Child popup windows not explicitly
 * hidden will be restored when the parent is shown.
 *
 * @param parent the parent of the window, must not be NULL.
 * @param offset_x the x position of the popup window relative to the origin
 *                 of the parent.
 * @param offset_y the y position of the popup window relative to the origin
 *                 of the parent window.
 * @param w the width of the window.
 * @param h the height of the window.
 * @param flags SDL_WINDOW_TOOLTIP or SDL_WINDOW_POPUP_MENU, and zero or more
 *              additional SDL_WindowFlags OR'd together.
 * @returns the window that was created or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateWindow
 * @sa SDL_CreateWindowWithProperties
 * @sa SDL_DestroyWindow
 * @sa SDL_GetWindowParent
 *
 * @from SDL_video.h:1186 SDL_Window * SDL_CreatePopupWindow(SDL_Window *parent, int offset_x, int offset_y, int w, int h, SDL_WindowFlags flags);
 */
  createPopupWindow: lib.symbols.SDL_CreatePopupWindow,

/**
 * Create a window with the specified properties.
 *
 * These are the supported properties:
 *
 * - `SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should
 *   be always on top
 * - `SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN`: true if the window has no
 *   window decoration
 * - `SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the
 *   window will be used with an externally managed graphics context.
 * - `SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN`: true if the window should
 *   accept keyboard input (defaults true)
 * - `SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN`: true if the window should
 *   start in fullscreen mode at desktop resolution
 * - `SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER`: the height of the window
 * - `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN`: true if the window should start
 *   hidden
 * - `SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window
 *   uses a high pixel density buffer if possible
 * - `SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN`: true if the window should
 *   start maximized
 * - `SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN`: true if the window is a popup menu
 * - `SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN`: true if the window will be used
 *   with Metal rendering
 * - `SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN`: true if the window should
 *   start minimized
 * - `SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN`: true if the window is modal to
 *   its parent
 * - `SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts
 *   with grabbed mouse focus
 * - `SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`: true if the window will be used
 *   with OpenGL rendering
 * - `SDL_PROP_WINDOW_CREATE_PARENT_POINTER`: an SDL_Window that will be the
 *   parent of this window, required for windows with the "tooltip", "menu",
 *   and "modal" properties
 * - `SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN`: true if the window should be
 *   resizable
 * - `SDL_PROP_WINDOW_CREATE_TITLE_STRING`: the title of the window, in UTF-8
 *   encoding
 * - `SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN`: true if the window show
 *   transparent in the areas with alpha of 0
 * - `SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip
 * - `SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN`: true if the window is a utility
 *   window, not showing in the task bar and window list
 * - `SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN`: true if the window will be used
 *   with Vulkan rendering
 * - `SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER`: the width of the window
 * - `SDL_PROP_WINDOW_CREATE_X_NUMBER`: the x position of the window, or
 *   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
 *   relative to the parent for windows with the "tooltip" or "menu" property
 *   set.
 * - `SDL_PROP_WINDOW_CREATE_Y_NUMBER`: the y position of the window, or
 *   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
 *   relative to the parent for windows with the "tooltip" or "menu" property
 *   set.
 *
 * These are additional supported properties on macOS:
 *
 * - `SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER`: the
 *   `(__unsafe_unretained)` NSWindow associated with the window, if you want
 *   to wrap an existing window.
 * - `SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`
 *   NSView associated with the window, defaults to `[window contentView]`
 *
 * These are additional supported properties on Wayland:
 *
 * - `SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if
 *   the application wants to use the Wayland surface for a custom role and
 *   does not want it attached to an XDG toplevel window. See
 *   [README/wayland](README/wayland) for more information on using custom
 *   surfaces.
 * - `SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the
 *   application wants an associated `wl_egl_window` object to be created and
 *   attached to the window, even if the window does not have the OpenGL
 *   property or `SDL_WINDOW_OPENGL` flag set.
 * - `SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface
 *   associated with the window, if you want to wrap an existing window. See
 *   [README/wayland](README/wayland) for more information.
 *
 * These are additional supported properties on Windows:
 *
 * - `SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER`: the HWND associated with the
 *   window, if you want to wrap an existing window.
 * - `SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,
 *   another window to share pixel format with, useful for OpenGL windows
 *
 * These are additional supported properties with X11:
 *
 * - `SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER`: the X11 Window associated
 *   with the window, if you want to wrap an existing window.
 *
 * The window is implicitly shown if the "hidden" property is not set.
 *
 * Windows with the "tooltip" and "menu" properties are popup windows and have
 * the behaviors and guidelines outlined in SDL_CreatePopupWindow().
 *
 * If this window is being created to be used with an SDL_Renderer, you should
 * not add a graphics API specific property
 * (`SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that
 * internally when it chooses a renderer. However, SDL might need to recreate
 * your window at that point, which may cause the window to appear briefly,
 * and then flicker as it is recreated. The correct approach to this is to
 * create the window with the `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN` property
 * set to true, then create the renderer, then show the window with
 * SDL_ShowWindow().
 *
 * @param props the properties to use.
 * @returns the window that was created or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateProperties
 * @sa SDL_CreateWindow
 * @sa SDL_DestroyWindow
 *
 * @from SDL_video.h:1307 SDL_Window * SDL_CreateWindowWithProperties(SDL_PropertiesID props);
 */
  createWindowWithProperties: lib.symbols.SDL_CreateWindowWithProperties,

/**
 * Get the numeric ID of a window.
 *
 * The numeric ID is what SDL_WindowEvent references, and is necessary to map
 * these events to specific SDL_Window objects.
 *
 * @param window the window to query.
 * @returns the ID of the window on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowFromID
 *
 * @from SDL_video.h:1360 SDL_WindowID SDL_GetWindowID(SDL_Window *window);
 */
  getWindowId: lib.symbols.SDL_GetWindowID,

/**
 * Get a window from a stored ID.
 *
 * The numeric ID is what SDL_WindowEvent references, and is necessary to map
 * these events to specific SDL_Window objects.
 *
 * @param id the ID of the window.
 * @returns the window associated with `id` or NULL if it doesn't exist; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowID
 *
 * @from SDL_video.h:1378 SDL_Window * SDL_GetWindowFromID(SDL_WindowID id);
 */
  getWindowFromId: lib.symbols.SDL_GetWindowFromID,

/**
 * Get parent of a window.
 *
 * @param window the window to query.
 * @returns the parent of the window on success or NULL if the window has no
 *          parent.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreatePopupWindow
 *
 * @from SDL_video.h:1393 SDL_Window * SDL_GetWindowParent(SDL_Window *window);
 */
  getWindowParent: lib.symbols.SDL_GetWindowParent,

/**
 * Get the properties associated with a window.
 *
 * The following read-only properties are provided by SDL:
 *
 * - `SDL_PROP_WINDOW_SHAPE_POINTER`: the surface associated with a shaped
 *   window
 * - `SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN`: true if the window has HDR
 *   headroom above the SDR white point. This property can change dynamically
 *   when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the
 *   SDL_COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the
 *   SDR white level in scRGB colorspace, and on Apple platforms this is
 *   always 1.0 for EDR content. This property can change dynamically when
 *   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 * - `SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT`: the additional high dynamic range
 *   that can be displayed, in terms of the SDR white point. When HDR is not
 *   enabled, this will be 1.0. This property can change dynamically when
 *   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 *
 * On Android:
 *
 * - `SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER`: the ANativeWindow associated
 *   with the window
 * - `SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER`: the EGLSurface associated with
 *   the window
 *
 * On iOS:
 *
 * - `SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`
 *   UIWindow associated with the window
 * - `SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
 *   associated with metal views on the window
 * - `SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's
 *   framebuffer object. It must be bound when rendering to the screen using
 *   OpenGL.
 * - `SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's
 *   renderbuffer object. It must be bound when SDL_GL_SwapWindow is called.
 * - `SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL
 *   view's resolve framebuffer, when MSAA is used.
 *
 * On KMS/DRM:
 *
 * - `SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated
 *   with the window (e.g. the X in /dev/dri/cardX)
 * - `SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the
 *   window
 * - `SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated
 *   with the window
 *
 * On macOS:
 *
 * - `SDL_PROP_WINDOW_COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`
 *   NSWindow associated with the window
 * - `SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
 *   assocated with metal views on the window
 *
 * On OpenVR:
 *
 * - `SDL_PROP_WINDOW_OPENVR_OVERLAY_ID`: the OpenVR Overlay Handle ID for the
 *   associated overlay window.
 *
 * On Vivante:
 *
 * - `SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType
 *   associated with the window
 * - `SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType
 *   associated with the window
 * - `SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER`: the EGLSurface associated with
 *   the window
 *
 * On Windows:
 *
 * - `SDL_PROP_WINDOW_WIN32_HWND_POINTER`: the HWND associated with the window
 * - `SDL_PROP_WINDOW_WIN32_HDC_POINTER`: the HDC associated with the window
 * - `SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER`: the HINSTANCE associated with
 *   the window
 *
 * On Wayland:
 *
 * Note: The `xdg_*` window objects do not internally persist across window
 * show/hide calls. They will be null if the window is hidden and must be
 * queried each time it is shown.
 *
 * - `SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER`: the wl_display associated with
 *   the window
 * - `SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER`: the wl_surface associated with
 *   the window
 * - `SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER`: the wp_viewport associated
 *   with the window
 * - `SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window
 *   associated with the window
 * - `SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated
 *   with the window
 * - `SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role
 *   associated with the window
 * - 'SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export
 *   handle associated with the window
 * - `SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role
 *   associated with the window
 * - `SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner
 *   associated with the window, in popup mode
 *
 * On X11:
 *
 * - `SDL_PROP_WINDOW_X11_DISPLAY_POINTER`: the X11 Display associated with
 *   the window
 * - `SDL_PROP_WINDOW_X11_SCREEN_NUMBER`: the screen number associated with
 *   the window
 * - `SDL_PROP_WINDOW_X11_WINDOW_NUMBER`: the X11 Window associated with the
 *   window
 *
 * @param window the window to query.
 * @returns a valid property ID on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:1515 SDL_PropertiesID SDL_GetWindowProperties(SDL_Window *window);
 */
  getWindowProperties: lib.symbols.SDL_GetWindowProperties,

/**
 * Get the window flags.
 *
 * @param window the window to query.
 * @returns a mask of the SDL_WindowFlags associated with `window`.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateWindow
 * @sa SDL_HideWindow
 * @sa SDL_MaximizeWindow
 * @sa SDL_MinimizeWindow
 * @sa SDL_SetWindowFullscreen
 * @sa SDL_SetWindowMouseGrab
 * @sa SDL_ShowWindow
 *
 * @from SDL_video.h:1571 SDL_WindowFlags SDL_GetWindowFlags(SDL_Window *window);
 */
  getWindowFlags: lib.symbols.SDL_GetWindowFlags,

/**
 * Set the title of a window.
 *
 * This string is expected to be in UTF-8 encoding.
 *
 * @param window the window to change.
 * @param title the desired window title in UTF-8 format.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowTitle
 *
 * @from SDL_video.h:1589 bool SDL_SetWindowTitle(SDL_Window *window, const char *title);
 */
  setWindowTitle: lib.symbols.SDL_SetWindowTitle,

/**
 * Get the title of a window.
 *
 * @param window the window to query.
 * @returns the title of the window in UTF-8 format or "" if there is no
 *          title.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowTitle
 *
 * @from SDL_video.h:1604 const char * SDL_GetWindowTitle(SDL_Window *window);
 */
  getWindowTitle: lib.symbols.SDL_GetWindowTitle,

/**
 * Set the icon for a window.
 *
 * If this function is passed a surface with alternate representations, the
 * surface will be interpreted as the content to be used for 100% display
 * scale, and the alternate representations will be used for high DPI
 * situations. For example, if the original surface is 32x32, then on a 2x
 * macOS display or 200% display scale on Windows, a 64x64 version of the
 * image will be used, if available. If a matching version of the image isn't
 * available, the closest larger size image will be downscaled to the
 * appropriate size and be used instead, if available. Otherwise, the closest
 * smaller image will be upscaled and be used instead.
 *
 * @param window the window to change.
 * @param icon an SDL_Surface structure containing the icon for the window.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:1628 bool SDL_SetWindowIcon(SDL_Window *window, SDL_Surface *icon);
 */
  setWindowIcon: lib.symbols.SDL_SetWindowIcon,

/**
 * Request that the window's position be set.
 *
 * If the window is in an exclusive fullscreen or maximized state, this
 * request has no effect.
 *
 * This can be used to reposition fullscreen-desktop windows onto a different
 * display, however, as exclusive fullscreen windows are locked to a specific
 * display, they can only be repositioned programmatically via
 * SDL_SetWindowFullscreenMode().
 *
 * On some windowing systems this request is asynchronous and the new
 * coordinates may not have have been applied immediately upon the return of
 * this function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window position changes, an SDL_EVENT_WINDOW_MOVED event will be
 * emitted with the window's new coordinates. Note that the new coordinates
 * may not match the exact coordinates requested, as some windowing systems
 * can restrict the position of the window in certain scenarios (e.g.
 * constraining the position so the window is always within desktop bounds).
 * Additionally, as this is just a request, it can be denied by the windowing
 * system.
 *
 * @param window the window to reposition.
 * @param x the x coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or
 *          `SDL_WINDOWPOS_UNDEFINED`.
 * @param y the y coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or
 *          `SDL_WINDOWPOS_UNDEFINED`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowPosition
 * @sa SDL_SyncWindow
 *
 * @from SDL_video.h:1669 bool SDL_SetWindowPosition(SDL_Window *window, int x, int y);
 */
  setWindowPosition: lib.symbols.SDL_SetWindowPosition,

/**
 * Get the position of a window.
 *
 * This is the current position of the window as last reported by the
 * windowing system.
 *
 * If you do not need the value for one of the positions a NULL may be passed
 * in the `x` or `y` parameter.
 *
 * @param window the window to query.
 * @param x a pointer filled in with the x position of the window, may be
 *          NULL.
 * @param y a pointer filled in with the y position of the window, may be
 *          NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowPosition
 *
 * @from SDL_video.h:1694 bool SDL_GetWindowPosition(SDL_Window *window, int *x, int *y);
 */
  getWindowPosition: lib.symbols.SDL_GetWindowPosition,

/**
 * Request that the size of a window's client area be set.
 *
 * If the window is in a fullscreen or maximized state, this request has no
 * effect.
 *
 * To change the exclusive fullscreen mode of a window, use
 * SDL_SetWindowFullscreenMode().
 *
 * On some windowing systems, this request is asynchronous and the new window
 * size may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be
 * emitted with the new window dimensions. Note that the new dimensions may
 * not match the exact size requested, as some windowing systems can restrict
 * the window size in certain scenarios (e.g. constraining the size of the
 * content area to remain within the usable desktop bounds). Additionally, as
 * this is just a request, it can be denied by the windowing system.
 *
 * @param window the window to change.
 * @param w the width of the window, must be > 0.
 * @param h the height of the window, must be > 0.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowSize
 * @sa SDL_SetWindowFullscreenMode
 * @sa SDL_SyncWindow
 *
 * @from SDL_video.h:1731 bool SDL_SetWindowSize(SDL_Window *window, int w, int h);
 */
  setWindowSize: lib.symbols.SDL_SetWindowSize,

/**
 * Get the size of a window's client area.
 *
 * The window pixel size may differ from its window coordinate size if the
 * window is on a high pixel density display. Use SDL_GetWindowSizeInPixels()
 * or SDL_GetRenderOutputSize() to get the real client area size in pixels.
 *
 * @param window the window to query the width and height from.
 * @param w a pointer filled in with the width of the window, may be NULL.
 * @param h a pointer filled in with the height of the window, may be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetRenderOutputSize
 * @sa SDL_GetWindowSizeInPixels
 * @sa SDL_SetWindowSize
 *
 * @from SDL_video.h:1754 bool SDL_GetWindowSize(SDL_Window *window, int *w, int *h);
 */
  getWindowSize: lib.symbols.SDL_GetWindowSize,

/**
 * Get the safe area for this window.
 *
 * Some devices have portions of the screen which are partially obscured or
 * not interactive, possibly due to on-screen controls, curved edges, camera
 * notches, TV overscan, etc. This function provides the area of the window
 * which is safe to have interactable content. You should continue rendering
 * into the rest of the window, but it should not contain visually important
 * or interactible content.
 *
 * @param window the window to query.
 * @param rect a pointer filled in with the client area that is safe for
 *             interactive content.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:1776 bool SDL_GetWindowSafeArea(SDL_Window *window, SDL_Rect *rect);
 */
  getWindowSafeArea: lib.symbols.SDL_GetWindowSafeArea,

/**
 * Request that the aspect ratio of a window's client area be set.
 *
 * The aspect ratio is the ratio of width divided by height, e.g. 2560x1600
 * would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are
 * narrower.
 *
 * If, at the time of this request, the window in a fixed-size state, such as
 * maximized or fullscreen, the request will be deferred until the window
 * exits this state and becomes resizable again.
 *
 * On some windowing systems, this request is asynchronous and the new window
 * aspect ratio may not have have been applied immediately upon the return of
 * this function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be
 * emitted with the new window dimensions. Note that the new dimensions may
 * not match the exact aspect ratio requested, as some windowing systems can
 * restrict the window size in certain scenarios (e.g. constraining the size
 * of the content area to remain within the usable desktop bounds).
 * Additionally, as this is just a request, it can be denied by the windowing
 * system.
 *
 * @param window the window to change.
 * @param min_aspect the minimum aspect ratio of the window, or 0.0f for no
 *                   limit.
 * @param max_aspect the maximum aspect ratio of the window, or 0.0f for no
 *                   limit.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowAspectRatio
 * @sa SDL_SyncWindow
 *
 * @from SDL_video.h:1817 bool SDL_SetWindowAspectRatio(SDL_Window *window, float min_aspect, float max_aspect);
 */
  setWindowAspectRatio: lib.symbols.SDL_SetWindowAspectRatio,

/**
 * Get the size of a window's client area.
 *
 * @param window the window to query the width and height from.
 * @param min_aspect a pointer filled in with the minimum aspect ratio of the
 *                   window, may be NULL.
 * @param max_aspect a pointer filled in with the maximum aspect ratio of the
 *                   window, may be NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowAspectRatio
 *
 * @from SDL_video.h:1836 bool SDL_GetWindowAspectRatio(SDL_Window *window, float *min_aspect, float *max_aspect);
 */
  getWindowAspectRatio: lib.symbols.SDL_GetWindowAspectRatio,

/**
 * Get the size of a window's borders (decorations) around the client area.
 *
 * Note: If this function fails (returns false), the size values will be
 * initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
 * window in question was borderless.
 *
 * Note: This function may fail on systems where the window has not yet been
 * decorated by the display server (for example, immediately after calling
 * SDL_CreateWindow). It is recommended that you wait at least until the
 * window has been presented and composited, so that the window system has a
 * chance to decorate the window and provide the border dimensions to SDL.
 *
 * This function also returns false if getting the information is not
 * supported.
 *
 * @param window the window to query the size values of the border
 *               (decorations) from.
 * @param top pointer to variable for storing the size of the top border; NULL
 *            is permitted.
 * @param left pointer to variable for storing the size of the left border;
 *             NULL is permitted.
 * @param bottom pointer to variable for storing the size of the bottom
 *               border; NULL is permitted.
 * @param right pointer to variable for storing the size of the right border;
 *              NULL is permitted.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowSize
 *
 * @from SDL_video.h:1873 bool SDL_GetWindowBordersSize(SDL_Window *window, int *top, int *left, int *bottom, int *right);
 */
  getWindowBordersSize: lib.symbols.SDL_GetWindowBordersSize,

/**
 * Get the size of a window's client area, in pixels.
 *
 * @param window the window from which the drawable size should be queried.
 * @param w a pointer to variable for storing the width in pixels, may be
 *          NULL.
 * @param h a pointer to variable for storing the height in pixels, may be
 *          NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreateWindow
 * @sa SDL_GetWindowSize
 *
 * @from SDL_video.h:1893 bool SDL_GetWindowSizeInPixels(SDL_Window *window, int *w, int *h);
 */
  getWindowSizeInPixels: lib.symbols.SDL_GetWindowSizeInPixels,

/**
 * Set the minimum size of a window's client area.
 *
 * @param window the window to change.
 * @param min_w the minimum width of the window, or 0 for no limit.
 * @param min_h the minimum height of the window, or 0 for no limit.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowMinimumSize
 * @sa SDL_SetWindowMaximumSize
 *
 * @from SDL_video.h:1911 bool SDL_SetWindowMinimumSize(SDL_Window *window, int min_w, int min_h);
 */
  setWindowMinimumSize: lib.symbols.SDL_SetWindowMinimumSize,

/**
 * Get the minimum size of a window's client area.
 *
 * @param window the window to query.
 * @param w a pointer filled in with the minimum width of the window, may be
 *          NULL.
 * @param h a pointer filled in with the minimum height of the window, may be
 *          NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowMaximumSize
 * @sa SDL_SetWindowMinimumSize
 *
 * @from SDL_video.h:1931 bool SDL_GetWindowMinimumSize(SDL_Window *window, int *w, int *h);
 */
  getWindowMinimumSize: lib.symbols.SDL_GetWindowMinimumSize,

/**
 * Set the maximum size of a window's client area.
 *
 * @param window the window to change.
 * @param max_w the maximum width of the window, or 0 for no limit.
 * @param max_h the maximum height of the window, or 0 for no limit.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowMaximumSize
 * @sa SDL_SetWindowMinimumSize
 *
 * @from SDL_video.h:1949 bool SDL_SetWindowMaximumSize(SDL_Window *window, int max_w, int max_h);
 */
  setWindowMaximumSize: lib.symbols.SDL_SetWindowMaximumSize,

/**
 * Get the maximum size of a window's client area.
 *
 * @param window the window to query.
 * @param w a pointer filled in with the maximum width of the window, may be
 *          NULL.
 * @param h a pointer filled in with the maximum height of the window, may be
 *          NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowMinimumSize
 * @sa SDL_SetWindowMaximumSize
 *
 * @from SDL_video.h:1969 bool SDL_GetWindowMaximumSize(SDL_Window *window, int *w, int *h);
 */
  getWindowMaximumSize: lib.symbols.SDL_GetWindowMaximumSize,

/**
 * Set the border state of a window.
 *
 * This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
 * or remove the border from the actual window. This is a no-op if the
 * window's border already matches the requested state.
 *
 * You can't change the border state of a fullscreen window.
 *
 * @param window the window of which to change the border state.
 * @param bordered false to remove border, true to add border.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowFlags
 *
 * @from SDL_video.h:1991 bool SDL_SetWindowBordered(SDL_Window *window, bool bordered);
 */
  setWindowBordered: lib.symbols.SDL_SetWindowBordered,

/**
 * Set the user-resizable state of a window.
 *
 * This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
 * allow/disallow user resizing of the window. This is a no-op if the window's
 * resizable state already matches the requested state.
 *
 * You can't change the resizable state of a fullscreen window.
 *
 * @param window the window of which to change the resizable state.
 * @param resizable true to allow resizing, false to disallow.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowFlags
 *
 * @from SDL_video.h:2013 bool SDL_SetWindowResizable(SDL_Window *window, bool resizable);
 */
  setWindowResizable: lib.symbols.SDL_SetWindowResizable,

/**
 * Set the window to always be above the others.
 *
 * This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
 * will bring the window to the front and keep the window above the rest.
 *
 * @param window the window of which to change the always on top state.
 * @param on_top true to set the window always on top, false to disable.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowFlags
 *
 * @from SDL_video.h:2032 bool SDL_SetWindowAlwaysOnTop(SDL_Window *window, bool on_top);
 */
  setWindowAlwaysOnTop: lib.symbols.SDL_SetWindowAlwaysOnTop,

/**
 * Show a window.
 *
 * @param window the window to show.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_HideWindow
 * @sa SDL_RaiseWindow
 *
 * @from SDL_video.h:2048 bool SDL_ShowWindow(SDL_Window *window);
 */
  showWindow: lib.symbols.SDL_ShowWindow,

/**
 * Hide a window.
 *
 * @param window the window to hide.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_ShowWindow
 * @sa SDL_WINDOW_HIDDEN
 *
 * @from SDL_video.h:2064 bool SDL_HideWindow(SDL_Window *window);
 */
  hideWindow: lib.symbols.SDL_HideWindow,

/**
 * Request that a window be raised above other windows and gain the input
 * focus.
 *
 * The result of this request is subject to desktop window manager policy,
 * particularly if raising the requested window would result in stealing focus
 * from another application. If the window is successfully raised and gains
 * input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and
 * the window will have the SDL_WINDOW_INPUT_FOCUS flag set.
 *
 * @param window the window to raise.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:2084 bool SDL_RaiseWindow(SDL_Window *window);
 */
  raiseWindow: lib.symbols.SDL_RaiseWindow,

/**
 * Request that the window be made as large as possible.
 *
 * Non-resizable windows can't be maximized. The window must have the
 * SDL_WINDOW_RESIZABLE flag set, or this will have no effect.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * When maximizing a window, whether the constraints set via
 * SDL_SetWindowMaximumSize() are honored depends on the policy of the window
 * manager. Win32 and macOS enforce the constraints when maximizing, while X11
 * and Wayland window managers may vary.
 *
 * @param window the window to maximize.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_MinimizeWindow
 * @sa SDL_RestoreWindow
 * @sa SDL_SyncWindow
 *
 * @from SDL_video.h:2118 bool SDL_MaximizeWindow(SDL_Window *window);
 */
  maximizeWindow: lib.symbols.SDL_MaximizeWindow,

/**
 * Request that the window be minimized to an iconic representation.
 *
 * If the window is in a fullscreen state, this request has no direct effect.
 * It may alter the state the window is returned to when leaving fullscreen.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have been applied immediately upon the return of this
 * function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * @param window the window to minimize.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_MaximizeWindow
 * @sa SDL_RestoreWindow
 * @sa SDL_SyncWindow
 *
 * @from SDL_video.h:2147 bool SDL_MinimizeWindow(SDL_Window *window);
 */
  minimizeWindow: lib.symbols.SDL_MinimizeWindow,

/**
 * Request that the size and position of a minimized or maximized window be
 * restored.
 *
 * If the window is in a fullscreen state, this request has no direct effect.
 * It may alter the state the window is returned to when leaving fullscreen.
 *
 * On some windowing systems this request is asynchronous and the new window
 * state may not have have been applied immediately upon the return of this
 * function. If an immediate change is required, call SDL_SyncWindow() to
 * block until the changes have taken effect.
 *
 * When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be
 * emitted. Note that, as this is just a request, the windowing system can
 * deny the state change.
 *
 * @param window the window to restore.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_MaximizeWindow
 * @sa SDL_MinimizeWindow
 * @sa SDL_SyncWindow
 *
 * @from SDL_video.h:2177 bool SDL_RestoreWindow(SDL_Window *window);
 */
  restoreWindow: lib.symbols.SDL_RestoreWindow,

/**
 * Request that the window's fullscreen state be changed.
 *
 * By default a window in fullscreen state uses borderless fullscreen desktop
 * mode, but a specific exclusive display mode can be set using
 * SDL_SetWindowFullscreenMode().
 *
 * On some windowing systems this request is asynchronous and the new
 * fullscreen state may not have have been applied immediately upon the return
 * of this function. If an immediate change is required, call SDL_SyncWindow()
 * to block until the changes have taken effect.
 *
 * When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or
 * SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this
 * is just a request, it can be denied by the windowing system.
 *
 * @param window the window to change.
 * @param fullscreen true for fullscreen mode, false for windowed mode.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowFullscreenMode
 * @sa SDL_SetWindowFullscreenMode
 * @sa SDL_SyncWindow
 * @sa SDL_WINDOW_FULLSCREEN
 *
 * @from SDL_video.h:2209 bool SDL_SetWindowFullscreen(SDL_Window *window, bool fullscreen);
 */
  setWindowFullscreen: lib.symbols.SDL_SetWindowFullscreen,

/**
 * Block until any pending window state is finalized.
 *
 * On asynchronous windowing systems, this acts as a synchronization barrier
 * for pending window state. It will attempt to wait until any pending window
 * state has been applied and is guaranteed to return within finite time. Note
 * that for how long it can potentially block depends on the underlying window
 * system, as window state changes may involve somewhat lengthy animations
 * that must complete before the window is in its final requested state.
 *
 * On windowing systems where changes are immediate, this does nothing.
 *
 * @param window the window for which to wait for the pending state to be
 *               applied.
 * @returns true on success or false if the operation timed out before the
 *          window was in the requested state.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowSize
 * @sa SDL_SetWindowPosition
 * @sa SDL_SetWindowFullscreen
 * @sa SDL_MinimizeWindow
 * @sa SDL_MaximizeWindow
 * @sa SDL_RestoreWindow
 * @sa SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS
 *
 * @from SDL_video.h:2240 bool SDL_SyncWindow(SDL_Window *window);
 */
  syncWindow: lib.symbols.SDL_SyncWindow,

/**
 * Return whether the window has a surface associated with it.
 *
 * @param window the window to query.
 * @returns true if there is a surface associated with the window, or false
 *          otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowSurface
 *
 * @from SDL_video.h:2255 bool SDL_WindowHasSurface(SDL_Window *window);
 */
  windowHasSurface: lib.symbols.SDL_WindowHasSurface,

/**
 * Get the SDL surface associated with the window.
 *
 * A new surface will be created with the optimal format for the window, if
 * necessary. This surface will be freed when the window is destroyed. Do not
 * free this surface.
 *
 * This surface will be invalidated if the window is resized. After resizing a
 * window this function must be called again to return a valid surface.
 *
 * You may not combine this with 3D or the rendering API on this window.
 *
 * This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
 *
 * @param window the window to query.
 * @returns the surface associated with the window, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DestroyWindowSurface
 * @sa SDL_WindowHasSurface
 * @sa SDL_UpdateWindowSurface
 * @sa SDL_UpdateWindowSurfaceRects
 *
 * @from SDL_video.h:2284 SDL_Surface * SDL_GetWindowSurface(SDL_Window *window);
 */
  getWindowSurface: lib.symbols.SDL_GetWindowSurface,

/**
 * Toggle VSync for the window surface.
 *
 * When a window surface is created, vsync defaults to
 * SDL_WINDOW_SURFACE_VSYNC_DISABLED.
 *
 * The `vsync` parameter can be 1 to synchronize present with every vertical
 * refresh, 2 to synchronize present with every second vertical refresh, etc.,
 * SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),
 * or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is
 * supported by every driver, so you should check the return value to see
 * whether the requested setting is supported.
 *
 * @param window the window.
 * @param vsync the vertical refresh sync interval.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowSurfaceVSync
 *
 * @from SDL_video.h:2310 bool SDL_SetWindowSurfaceVSync(SDL_Window *window, int vsync);
 */
  setWindowSurfaceVSync: lib.symbols.SDL_SetWindowSurfaceVSync,

/**
 * Get VSync for the window surface.
 *
 * @param window the window to query.
 * @param vsync an int filled with the current vertical refresh sync interval.
 *              See SDL_SetWindowSurfaceVSync() for the meaning of the value.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowSurfaceVSync
 *
 * @from SDL_video.h:2330 bool SDL_GetWindowSurfaceVSync(SDL_Window *window, int *vsync);
 */
  getWindowSurfaceVSync: lib.symbols.SDL_GetWindowSurfaceVSync,

/**
 * Copy the window surface to the screen.
 *
 * This is the function you use to reflect any changes to the surface on the
 * screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_Flip().
 *
 * @param window the window to update.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowSurface
 * @sa SDL_UpdateWindowSurfaceRects
 *
 * @from SDL_video.h:2351 bool SDL_UpdateWindowSurface(SDL_Window *window);
 */
  updateWindowSurface: lib.symbols.SDL_UpdateWindowSurface,

/**
 * Copy areas of the window surface to the screen.
 *
 * This is the function you use to reflect changes to portions of the surface
 * on the screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
 *
 * Note that this function will update _at least_ the rectangles specified,
 * but this is only intended as an optimization; in practice, this might
 * update more of the screen (or all of the screen!), depending on what method
 * SDL uses to send pixels to the system.
 *
 * @param window the window to update.
 * @param rects an array of SDL_Rect structures representing areas of the
 *              surface to copy, in pixels.
 * @param numrects the number of rectangles.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowSurface
 * @sa SDL_UpdateWindowSurface
 *
 * @from SDL_video.h:2380 bool SDL_UpdateWindowSurfaceRects(SDL_Window *window, const SDL_Rect *rects, int numrects);
 */
  updateWindowSurfaceRects: lib.symbols.SDL_UpdateWindowSurfaceRects,

/**
 * Destroy the surface associated with the window.
 *
 * @param window the window to update.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowSurface
 * @sa SDL_WindowHasSurface
 *
 * @from SDL_video.h:2396 bool SDL_DestroyWindowSurface(SDL_Window *window);
 */
  destroyWindowSurface: lib.symbols.SDL_DestroyWindowSurface,

/**
 * Set a window's keyboard grab mode.
 *
 * Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
 * the Meta/Super key. Note that not all system keyboard shortcuts can be
 * captured by applications (one example is Ctrl+Alt+Del on Windows).
 *
 * This is primarily intended for specialized applications such as VNC clients
 * or VM frontends. Normal games should not use keyboard grab.
 *
 * When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
 * window is full-screen to ensure the user is not trapped in your
 * application. If you have a custom keyboard shortcut to exit fullscreen
 * mode, you may suppress this behavior with
 * `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
 *
 * If the caller enables a grab while another window is currently grabbed, the
 * other window loses its grab in favor of the caller's window.
 *
 * @param window the window for which the keyboard grab mode should be set.
 * @param grabbed this is true to grab keyboard, and false to release.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowKeyboardGrab
 * @sa SDL_SetWindowMouseGrab
 *
 * @from SDL_video.h:2429 bool SDL_SetWindowKeyboardGrab(SDL_Window *window, bool grabbed);
 */
  setWindowKeyboardGrab: lib.symbols.SDL_SetWindowKeyboardGrab,

/**
 * Set a window's mouse grab mode.
 *
 * Mouse grab confines the mouse cursor to the window.
 *
 * @param window the window for which the mouse grab mode should be set.
 * @param grabbed this is true to grab mouse, and false to release.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowMouseRect
 * @sa SDL_SetWindowMouseRect
 * @sa SDL_SetWindowMouseGrab
 * @sa SDL_SetWindowKeyboardGrab
 *
 * @from SDL_video.h:2450 bool SDL_SetWindowMouseGrab(SDL_Window *window, bool grabbed);
 */
  setWindowMouseGrab: lib.symbols.SDL_SetWindowMouseGrab,

/**
 * Get a window's keyboard grab mode.
 *
 * @param window the window to query.
 * @returns true if keyboard is grabbed, and false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowKeyboardGrab
 *
 * @from SDL_video.h:2464 bool SDL_GetWindowKeyboardGrab(SDL_Window *window);
 */
  getWindowKeyboardGrab: lib.symbols.SDL_GetWindowKeyboardGrab,

/**
 * Get a window's mouse grab mode.
 *
 * @param window the window to query.
 * @returns true if mouse is grabbed, and false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowMouseRect
 * @sa SDL_SetWindowMouseRect
 * @sa SDL_SetWindowMouseGrab
 * @sa SDL_SetWindowKeyboardGrab
 *
 * @from SDL_video.h:2481 bool SDL_GetWindowMouseGrab(SDL_Window *window);
 */
  getWindowMouseGrab: lib.symbols.SDL_GetWindowMouseGrab,

/**
 * Get the window that currently has an input grab enabled.
 *
 * @returns the window if input is grabbed or NULL otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowMouseGrab
 * @sa SDL_SetWindowKeyboardGrab
 *
 * @from SDL_video.h:2495 SDL_Window * SDL_GetGrabbedWindow(void);
 */
  getGrabbedWindow: lib.symbols.SDL_GetGrabbedWindow,

/**
 * Confines the cursor to the specified area of a window.
 *
 * Note that this does NOT grab the cursor, it only defines the area a cursor
 * is restricted to when the window has mouse focus.
 *
 * @param window the window that will be associated with the barrier.
 * @param rect a rectangle area in window-relative coordinates. If NULL the
 *             barrier for the specified window will be destroyed.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowMouseRect
 * @sa SDL_GetWindowMouseGrab
 * @sa SDL_SetWindowMouseGrab
 *
 * @from SDL_video.h:2517 bool SDL_SetWindowMouseRect(SDL_Window *window, const SDL_Rect *rect);
 */
  setWindowMouseRect: lib.symbols.SDL_SetWindowMouseRect,

/**
 * Get the mouse confinement rectangle of a window.
 *
 * @param window the window to query.
 * @returns a pointer to the mouse confinement rectangle of a window, or NULL
 *          if there isn't one.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowMouseRect
 * @sa SDL_GetWindowMouseGrab
 * @sa SDL_SetWindowMouseGrab
 *
 * @from SDL_video.h:2534 const SDL_Rect * SDL_GetWindowMouseRect(SDL_Window *window);
 */
  getWindowMouseRect: lib.symbols.SDL_GetWindowMouseRect,

/**
 * Set the opacity for a window.
 *
 * The parameter `opacity` will be clamped internally between 0.0f
 * (transparent) and 1.0f (opaque).
 *
 * This function also returns false if setting the opacity isn't supported.
 *
 * @param window the window which will be made transparent or opaque.
 * @param opacity the opacity value (0.0f - transparent, 1.0f - opaque).
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GetWindowOpacity
 *
 * @from SDL_video.h:2555 bool SDL_SetWindowOpacity(SDL_Window *window, float opacity);
 */
  setWindowOpacity: lib.symbols.SDL_SetWindowOpacity,

/**
 * Get the opacity of a window.
 *
 * If transparency isn't supported on this platform, opacity will be returned
 * as 1.0f without error.
 *
 * @param window the window to get the current opacity value from.
 * @returns the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on
 *          failure; call SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowOpacity
 *
 * @from SDL_video.h:2573 float SDL_GetWindowOpacity(SDL_Window *window);
 */
  getWindowOpacity: lib.symbols.SDL_GetWindowOpacity,

/**
 * Set the window as a child of a parent window.
 *
 * If the window is already the child of an existing window, it will be
 * reparented to the new owner. Setting the parent window to NULL unparents
 * the window and removes child window status.
 *
 * If a parent window is hidden or destroyed, the operation will be
 * recursively applied to child windows. Child windows hidden with the parent
 * that did not have their hidden status explicitly set will be restored when
 * the parent is shown.
 *
 * Attempting to set the parent of a window that is currently in the modal
 * state will fail. Use SDL_SetWindowModal() to cancel the modal status before
 * attempting to change the parent.
 *
 * Popup windows cannot change parents and attempts to do so will fail.
 *
 * Setting a parent window that is currently the sibling or descendent of the
 * child window results in undefined behavior.
 *
 * @param window the window that should become the child of a parent.
 * @param parent the new parent window for the child window.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowModal
 *
 * @from SDL_video.h:2607 bool SDL_SetWindowParent(SDL_Window *window, SDL_Window *parent);
 */
  setWindowParent: lib.symbols.SDL_SetWindowParent,

/**
 * Toggle the state of the window as modal.
 *
 * To enable modal status on a window, the window must currently be the child
 * window of a parent, or toggling modal status on will fail.
 *
 * @param window the window on which to set the modal state.
 * @param modal true to toggle modal status on, false to toggle it off.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_SetWindowParent
 * @sa SDL_WINDOW_MODAL
 *
 * @from SDL_video.h:2627 bool SDL_SetWindowModal(SDL_Window *window, bool modal);
 */
  setWindowModal: lib.symbols.SDL_SetWindowModal,

/**
 * Set whether the window may have input focus.
 *
 * @param window the window to set focusable state.
 * @param focusable true to allow input focus, false to not allow input focus.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:2641 bool SDL_SetWindowFocusable(SDL_Window *window, bool focusable);
 */
  setWindowFocusable: lib.symbols.SDL_SetWindowFocusable,

/**
 * Display the system-level window menu.
 *
 * This default window menu is provided by the system and on some platforms
 * provides functionality for setting or changing privileged state on the
 * window, such as moving it between workspaces or displays, or toggling the
 * always-on-top property.
 *
 * On platforms or desktops where this is unsupported, this function does
 * nothing.
 *
 * @param window the window for which the menu will be displayed.
 * @param x the x coordinate of the menu, relative to the origin (top-left) of
 *          the client area.
 * @param y the y coordinate of the menu, relative to the origin (top-left) of
 *          the client area.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:2667 bool SDL_ShowWindowSystemMenu(SDL_Window *window, int x, int y);
 */
  showWindowSystemMenu: lib.symbols.SDL_ShowWindowSystemMenu,

/**
 * Set the shape of a transparent window.
 *
 * This sets the alpha channel of a transparent window and any fully
 * transparent areas are also transparent to mouse clicks. If you are using
 * something besides the SDL render API, then you are responsible for drawing
 * the alpha channel of the window to match the shape alpha channel to get
 * consistent cross-platform results.
 *
 * The shape is copied inside this function, so you can free it afterwards. If
 * your shape surface changes, you should call SDL_SetWindowShape() again to
 * update the window. This is an expensive operation, so should be done
 * sparingly.
 *
 * The window must have been created with the SDL_WINDOW_TRANSPARENT flag.
 *
 * @param window the window.
 * @param shape the surface representing the shape of the window, or NULL to
 *              remove any current shape.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:2776 bool SDL_SetWindowShape(SDL_Window *window, SDL_Surface *shape);
 */
  setWindowShape: lib.symbols.SDL_SetWindowShape,

/**
 * Request a window to demand attention from the user.
 *
 * @param window the window to be flashed.
 * @param operation the operation to perform.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:2790 bool SDL_FlashWindow(SDL_Window *window, SDL_FlashOperation operation);
 */
  flashWindow: lib.symbols.SDL_FlashWindow,

/**
 * Destroy a window.
 *
 * Any child windows owned by the window will be recursively destroyed as
 * well.
 *
 * Note that on some platforms, the visible window may not actually be removed
 * from the screen until the SDL event loop is pumped again, even though the
 * SDL_Window is no longer valid after this call.
 *
 * @param window the window to destroy.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_CreatePopupWindow
 * @sa SDL_CreateWindow
 * @sa SDL_CreateWindowWithProperties
 *
 * @from SDL_video.h:2812 void SDL_DestroyWindow(SDL_Window *window);
 */
  destroyWindow: lib.symbols.SDL_DestroyWindow,

/**
 * Check whether the screensaver is currently enabled.
 *
 * The screensaver is disabled by default.
 *
 * The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
 *
 * @returns true if the screensaver is enabled, false if it is disabled.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DisableScreenSaver
 * @sa SDL_EnableScreenSaver
 *
 * @from SDL_video.h:2831 bool SDL_ScreenSaverEnabled(void);
 */
  screenSaverEnabled: lib.symbols.SDL_ScreenSaverEnabled,

/**
 * Allow the screen to be blanked by a screen saver.
 *
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_DisableScreenSaver
 * @sa SDL_ScreenSaverEnabled
 *
 * @from SDL_video.h:2846 bool SDL_EnableScreenSaver(void);
 */
  enableScreenSaver: lib.symbols.SDL_EnableScreenSaver,

/**
 * Prevent the screen from being blanked by a screen saver.
 *
 * If you disable the screensaver, it is automatically re-enabled when SDL
 * quits.
 *
 * The screensaver is disabled by default, but this may by changed by
 * SDL_HINT_VIDEO_ALLOW_SCREENSAVER.
 *
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_EnableScreenSaver
 * @sa SDL_ScreenSaverEnabled
 *
 * @from SDL_video.h:2867 bool SDL_DisableScreenSaver(void);
 */
  disableScreenSaver: lib.symbols.SDL_DisableScreenSaver,

/**
 * Dynamically load an OpenGL library.
 *
 * This should be done after initializing the video driver, but before
 * creating any OpenGL windows. If no OpenGL library is loaded, the default
 * library will be loaded upon creation of the first OpenGL window.
 *
 * If you do this, you need to retrieve all of the GL functions used in your
 * program from the dynamic library using SDL_GL_GetProcAddress().
 *
 * @param path the platform dependent OpenGL library name, or NULL to open the
 *             default OpenGL library.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GL_GetProcAddress
 * @sa SDL_GL_UnloadLibrary
 *
 * @from SDL_video.h:2897 bool SDL_GL_LoadLibrary(const char *path);
 */
  glLoadLibrary: lib.symbols.SDL_GL_LoadLibrary,

/**
 * Get an OpenGL function by name.
 *
 * If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
 * GL functions must be retrieved this way. Usually this is used to retrieve
 * function pointers to OpenGL extensions.
 *
 * There are some quirks to looking up OpenGL functions that require some
 * extra care from the application. If you code carefully, you can handle
 * these quirks without any platform-specific code, though:
 *
 * - On Windows, function pointers are specific to the current GL context;
 *   this means you need to have created a GL context and made it current
 *   before calling SDL_GL_GetProcAddress(). If you recreate your context or
 *   create a second context, you should assume that any existing function
 *   pointers aren't valid to use with it. This is (currently) a
 *   Windows-specific limitation, and in practice lots of drivers don't suffer
 *   this limitation, but it is still the way the wgl API is documented to
 *   work and you should expect crashes if you don't respect it. Store a copy
 *   of the function pointers that comes and goes with context lifespan.
 * - On X11, function pointers returned by this function are valid for any
 *   context, and can even be looked up before a context is created at all.
 *   This means that, for at least some common OpenGL implementations, if you
 *   look up a function that doesn't exist, you'll get a non-NULL result that
 *   is _NOT_ safe to call. You must always make sure the function is actually
 *   available for a given GL context before calling it, by checking for the
 *   existence of the appropriate extension with SDL_GL_ExtensionSupported(),
 *   or verifying that the version of OpenGL you're using offers the function
 *   as core functionality.
 * - Some OpenGL drivers, on all platforms, *will* return NULL if a function
 *   isn't supported, but you can't count on this behavior. Check for
 *   extensions you use, and if you get a NULL anyway, act as if that
 *   extension wasn't available. This is probably a bug in the driver, but you
 *   can code defensively for this scenario anyhow.
 * - Just because you're on Linux/Unix, don't assume you'll be using X11.
 *   Next-gen display servers are waiting to replace it, and may or may not
 *   make the same promises about function pointers.
 * - OpenGL function pointers must be declared `APIENTRY` as in the example
 *   code. This will ensure the proper calling convention is followed on
 *   platforms where this matters (Win32) thereby avoiding stack corruption.
 *
 * @param proc the name of an OpenGL function.
 * @returns a pointer to the named OpenGL function. The returned pointer
 *          should be cast to the appropriate function signature.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GL_ExtensionSupported
 * @sa SDL_GL_LoadLibrary
 * @sa SDL_GL_UnloadLibrary
 *
 * @from SDL_video.h:2952 SDL_FunctionPointer SDL_GL_GetProcAddress(const char *proc);
 */
  glGetProcAddress: lib.symbols.SDL_GL_GetProcAddress,

/**
 * Get an EGL library function by name.
 *
 * If an EGL library is loaded, this function allows applications to get entry
 * points for EGL functions. This is useful to provide to an EGL API and
 * extension loader.
 *
 * @param proc the name of an EGL function.
 * @returns a pointer to the named EGL function. The returned pointer should
 *          be cast to the appropriate function signature.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_EGL_GetCurrentDisplay
 *
 * @from SDL_video.h:2971 SDL_FunctionPointer SDL_EGL_GetProcAddress(const char *proc);
 */
  eglGetProcAddress: lib.symbols.SDL_EGL_GetProcAddress,

/**
 * Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GL_LoadLibrary
 *
 * @from SDL_video.h:2982 void SDL_GL_UnloadLibrary(void);
 */
  glUnloadLibrary: lib.symbols.SDL_GL_UnloadLibrary,

/**
 * Check if an OpenGL extension is supported for the current context.
 *
 * This function operates on the current GL context; you must have created a
 * context and it must be current before calling this function. Do not assume
 * that all contexts you create will have the same set of extensions
 * available, or that recreating an existing context will offer the same
 * extensions again.
 *
 * While it's probably not a massive overhead, this function is not an O(1)
 * operation. Check the extensions you care about after creating the GL
 * context and save that information somewhere instead of calling the function
 * every time you need to know.
 *
 * @param extension the name of the extension to check.
 * @returns true if the extension is supported, false otherwise.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:3005 bool SDL_GL_ExtensionSupported(const char *extension);
 */
  glExtensionSupported: lib.symbols.SDL_GL_ExtensionSupported,

/**
 * Reset all previously set OpenGL context attributes to their default values.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GL_GetAttribute
 * @sa SDL_GL_SetAttribute
 *
 * @from SDL_video.h:3017 void SDL_GL_ResetAttributes(void);
 */
  glResetAttributes: lib.symbols.SDL_GL_ResetAttributes,

/**
 * Set an OpenGL window attribute before window creation.
 *
 * This function sets the OpenGL attribute `attr` to `value`. The requested
 * attributes should be set before creating an OpenGL window. You should use
 * SDL_GL_GetAttribute() to check the values after creating the OpenGL
 * context, since the values obtained can differ from the requested ones.
 *
 * @param attr an SDL_GLAttr enum value specifying the OpenGL attribute to
 *             set.
 * @param value the desired value for the attribute.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GL_GetAttribute
 * @sa SDL_GL_ResetAttributes
 *
 * @from SDL_video.h:3040 bool SDL_GL_SetAttribute(SDL_GLAttr attr, int value);
 */
  glSetAttribute: lib.symbols.SDL_GL_SetAttribute,

/**
 * Get the actual value for an attribute from the current context.
 *
 * @param attr an SDL_GLAttr enum value specifying the OpenGL attribute to
 *             get.
 * @param value a pointer filled in with the current value of `attr`.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GL_ResetAttributes
 * @sa SDL_GL_SetAttribute
 *
 * @from SDL_video.h:3058 bool SDL_GL_GetAttribute(SDL_GLAttr attr, int *value);
 */
  glGetAttribute: lib.symbols.SDL_GL_GetAttribute,

/**
 * Get the currently active OpenGL window.
 *
 * @returns the currently active OpenGL window on success or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:3112 SDL_Window * SDL_GL_GetCurrentWindow(void);
 */
  glGetCurrentWindow: lib.symbols.SDL_GL_GetCurrentWindow,

/**
 * Sets the callbacks for defining custom EGLAttrib arrays for EGL
 * initialization.
 *
 * Callbacks that aren't needed can be set to NULL.
 *
 * NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.
 *
 * @param platformAttribCallback callback for attributes to pass to
 *                               eglGetPlatformDisplay. May be NULL.
 * @param surfaceAttribCallback callback for attributes to pass to
 *                              eglCreateSurface. May be NULL.
 * @param contextAttribCallback callback for attributes to pass to
 *                              eglCreateContext. May be NULL.
 * @param userdata a pointer that is passed to the callbacks.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:3185 void SDL_EGL_SetAttributeCallbacks(SDL_EGLAttribArrayCallback platformAttribCallback,                                                               SDL_EGLIntArrayCallback surfaceAttribCallback,                                                               SDL_EGLIntArrayCallback contextAttribCallback, void *userdata);
 */
  eglSetAttributeCallbacks: lib.symbols.SDL_EGL_SetAttributeCallbacks,

/**
 * Set the swap interval for the current OpenGL context.
 *
 * Some systems allow specifying -1 for the interval, to enable adaptive
 * vsync. Adaptive vsync works the same as vsync, but if you've already missed
 * the vertical retrace for a given frame, it swaps buffers immediately, which
 * might be less jarring for the user during occasional framerate drops. If an
 * application requests adaptive vsync and the system does not support it,
 * this function will fail and return false. In such a case, you should
 * probably retry the call with 1 for the interval.
 *
 * Adaptive vsync is implemented for some glX drivers with
 * GLX_EXT_swap_control_tear, and for some Windows drivers with
 * WGL_EXT_swap_control_tear.
 *
 * Read more on the Khronos wiki:
 * https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
 *
 * @param interval 0 for immediate updates, 1 for updates synchronized with
 *                 the vertical retrace, -1 for adaptive vsync.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GL_GetSwapInterval
 *
 * @from SDL_video.h:3218 bool SDL_GL_SetSwapInterval(int interval);
 */
  glSetSwapInterval: lib.symbols.SDL_GL_SetSwapInterval,

/**
 * Get the swap interval for the current OpenGL context.
 *
 * If the system can't determine the swap interval, or there isn't a valid
 * current context, this function will set *interval to 0 as a safe default.
 *
 * @param interval output interval value. 0 if there is no vertical retrace
 *                 synchronization, 1 if the buffer swap is synchronized with
 *                 the vertical retrace, and -1 if late swaps happen
 *                 immediately instead of waiting for the next retrace.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_GL_SetSwapInterval
 *
 * @from SDL_video.h:3239 bool SDL_GL_GetSwapInterval(int *interval);
 */
  glGetSwapInterval: lib.symbols.SDL_GL_GetSwapInterval,

/**
 * Update a window with OpenGL rendering.
 *
 * This is used with double-buffered OpenGL contexts, which are the default.
 *
 * On macOS, make sure you bind 0 to the draw framebuffer before swapping the
 * window, otherwise nothing will happen. If you aren't using
 * glBindFramebuffer(), this is the default and you won't have to do anything
 * extra.
 *
 * @param window the window to change.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function should only be called on the main thread.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_video.h:3259 bool SDL_GL_SwapWindow(SDL_Window *window);
 */
  glSwapWindow: lib.symbols.SDL_GL_SwapWindow,



/*--- SDL_vulkan ---*/

/**
 * Dynamically load the Vulkan loader library.
 *
 * This should be called after initializing the video driver, but before
 * creating any Vulkan windows. If no Vulkan loader library is loaded, the
 * default library will be loaded upon creation of the first Vulkan window.
 *
 * SDL keeps a counter of how many times this function has been successfully
 * called, so it is safe to call this function multiple times, so long as it
 * is eventually paired with an equivalent number of calls to
 * SDL_Vulkan_UnloadLibrary. The `path` argument is ignored unless there is no
 * library currently loaded, and and the library isn't actually unloaded until
 * there have been an equivalent number of calls to SDL_Vulkan_UnloadLibrary.
 *
 * It is fairly common for Vulkan applications to link with libvulkan instead
 * of explicitly loading it at run time. This will work with SDL provided the
 * application links to a dynamic library and both it and SDL use the same
 * search path.
 *
 * If you specify a non-NULL `path`, an application should retrieve all of the
 * Vulkan functions it uses from the dynamic library using
 * SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points
 * to the same vulkan loader library the application linked to.
 *
 * On Apple devices, if `path` is NULL, SDL will attempt to find the
 * `vkGetInstanceProcAddr` address within all the Mach-O images of the current
 * process. This is because it is fairly common for Vulkan applications to
 * link with libvulkan (and historically MoltenVK was provided as a static
 * library). If it is not found, on macOS, SDL will attempt to load
 * `vulkan.framework/vulkan`, `libvulkan.1.dylib`,
 * `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On
 * iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a
 * dynamic framework or .dylib must ensure it is included in its application
 * bundle.
 *
 * On non-Apple devices, application linking with a static libvulkan is not
 * supported. Either do not link to the Vulkan loader or link to a dynamic
 * library version.
 *
 * @param path the platform dependent Vulkan loader library name or NULL.
 * @returns true on success or false on failure; call SDL_GetError() for more
 *          information.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Vulkan_GetVkGetInstanceProcAddr
 * @sa SDL_Vulkan_UnloadLibrary
 *
 * @from SDL_vulkan.h:132 bool SDL_Vulkan_LoadLibrary(const char *path);
 */
  vulkanLoadLibrary: lib.symbols.SDL_Vulkan_LoadLibrary,

/**
 * Get the address of the `vkGetInstanceProcAddr` function.
 *
 * This should be called after either calling SDL_Vulkan_LoadLibrary() or
 * creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.
 *
 * The actual type of the returned function pointer is
 * PFN_vkGetInstanceProcAddr, but that isn't available because the Vulkan
 * headers are not included here. You should cast the return value of this
 * function to that type, e.g.
 *
 * `vkGetInstanceProcAddr =
 * (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();`
 *
 * @returns the function pointer for `vkGetInstanceProcAddr` or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @from SDL_vulkan.h:153 SDL_FunctionPointer SDL_Vulkan_GetVkGetInstanceProcAddr(void);
 */
  vulkanGetVkGetInstanceProcAddr: lib.symbols.SDL_Vulkan_GetVkGetInstanceProcAddr,

/**
 * Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary().
 *
 * SDL keeps a counter of how many times this function has been called, so it
 * is safe to call this function multiple times, so long as it is paired with
 * an equivalent number of calls to SDL_Vulkan_LoadLibrary. The library isn't
 * actually unloaded until there have been an equivalent number of calls to
 * SDL_Vulkan_UnloadLibrary.
 *
 * Once the library has actually been unloaded, if any Vulkan instances
 * remain, they will likely crash the program. Clean up any existing Vulkan
 * resources, and destroy appropriate windows, renderers and GPU devices
 * before calling this function.
 *
 * @threadsafety This function is not thread safe.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Vulkan_LoadLibrary
 *
 * @from SDL_vulkan.h:175 void SDL_Vulkan_UnloadLibrary(void);
 */
  vulkanUnloadLibrary: lib.symbols.SDL_Vulkan_UnloadLibrary,

/**
 * Get the Vulkan instance extensions needed for vkCreateInstance.
 *
 * This should be called after either calling SDL_Vulkan_LoadLibrary() or
 * creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.
 *
 * On return, the variable pointed to by `count` will be set to the number of
 * elements returned, suitable for using with
 * VkInstanceCreateInfo::enabledExtensionCount, and the returned array can be
 * used with VkInstanceCreateInfo::ppEnabledExtensionNames, for calling
 * Vulkan's vkCreateInstance API.
 *
 * You should not free the returned array; it is owned by SDL.
 *
 * @param count a pointer filled in with the number of extensions returned.
 * @returns an array of extension name strings on success, NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * @since This function is available since SDL 3.2.0.
 *
 * @sa SDL_Vulkan_CreateSurface
 *
 * @from SDL_vulkan.h:199 char const * const * SDL_Vulkan_GetInstanceExtensions(Uint32 *count);
 */
  vulkanGetInstanceExtensions: lib.symbols.SDL_Vulkan_GetInstanceExtensions,

};
